{"ast":null,"code":"import { isComputedProp, isObservableProp, createAtom, action, _allowStateChangesInsideComputed, reaction, computed, runInAction, observable, values, entries, isObservableArray, $mobx, getAtom, ObservableMap, _interceptReads, intercept, observe, _getAdministration, set } from 'mobx';\nvar livelinessChecking = \"warn\";\n/**\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\n\nfunction setLivelinessChecking(mode) {\n  livelinessChecking = mode;\n}\n/**\n * Returns the current liveliness checking mode.\n *\n * @returns `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\n\n\nfunction getLivelinessChecking() {\n  return livelinessChecking;\n}\n/**\n * @deprecated use setLivelinessChecking instead\n * @hidden\n *\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\n\n\nfunction setLivelynessChecking(mode) {\n  setLivelinessChecking(mode);\n}\n/**\n * @hidden\n */\n\n\nvar Hook;\n\n(function (Hook) {\n  Hook[\"afterCreate\"] = \"afterCreate\";\n  Hook[\"afterAttach\"] = \"afterAttach\";\n  Hook[\"afterCreationFinalization\"] = \"afterCreationFinalization\";\n  Hook[\"beforeDetach\"] = \"beforeDetach\";\n  Hook[\"beforeDestroy\"] = \"beforeDestroy\";\n})(Hook || (Hook = {}));\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __values(o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n/**\n * Returns the _actual_ type of the given tree node. (Or throws)\n *\n * @param object\n * @returns\n */\n\n\nfunction getType(object) {\n  assertIsStateTreeNode(object, 1);\n  return getStateTreeNode(object).type;\n}\n/**\n * Returns the _declared_ type of the given sub property of an object, array or map.\n * In the case of arrays and maps the property name is optional and will be ignored.\n *\n * Example:\n * ```ts\n * const Box = types.model({ x: 0, y: 0 })\n * const box = Box.create()\n *\n * console.log(getChildType(box, \"x\").name) // 'number'\n * ```\n *\n * @param object\n * @param propertyName\n * @returns\n */\n\n\nfunction getChildType(object, propertyName) {\n  assertIsStateTreeNode(object, 1);\n  return getStateTreeNode(object).getChildType(propertyName);\n}\n/**\n * Registers a function that will be invoked for each mutation that is applied to the provided model instance, or to any of its children.\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details. onPatch events are emitted immediately and will not await the end of a transaction.\n * Patches can be used to deep observe a model tree.\n *\n * @param target the model instance from which to receive patches\n * @param callback the callback that is invoked for each patch. The reversePatch is a patch that would actually undo the emitted patch\n * @returns function to remove the listener\n */\n\n\nfunction onPatch(target, callback) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  assertIsFunction(callback, 2);\n  return getStateTreeNode(target).onPatch(callback);\n}\n/**\n * Registers a function that is invoked whenever a new snapshot for the given model instance is available.\n * The listener will only be fire at the end of the current MobX (trans)action.\n * See [snapshots](https://github.com/mobxjs/mobx-state-tree#snapshots) for more details.\n *\n * @param target\n * @param callback\n * @returns\n */\n\n\nfunction onSnapshot(target, callback) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  assertIsFunction(callback, 2);\n  return getStateTreeNode(target).onSnapshot(callback);\n}\n/**\n * Applies a JSON-patch to the given model instance or bails out if the patch couldn't be applied\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details.\n *\n * Can apply a single past, or an array of patches.\n *\n * @param target\n * @param patch\n * @returns\n */\n\n\nfunction applyPatch(target, patch) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  assertArg(patch, function (p) {\n    return typeof p === \"object\";\n  }, \"object or array\", 2);\n  getStateTreeNode(target).applyPatches(asArray(patch));\n}\n/**\n * Small abstraction around `onPatch` and `applyPatch`, attaches a patch listener to a tree and records all the patches.\n * Returns an recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IPatchRecorder {\n *      // the recorded patches\n *      patches: IJsonPatch[]\n *      // the inverse of the recorded patches\n *      inversePatches: IJsonPatch[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording patches\n *      stop(): void\n *      // resume recording patches\n *      resume(): void\n *      // apply all the recorded patches on the given target (the original subject if omitted)\n *      replay(target?: IAnyStateTreeNode): void\n *      // reverse apply the recorded patches on the given target  (the original subject if omitted)\n *      // stops the recorder if not already stopped\n *      undo(): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain patches.\n *\n * @param subject\n * @param filter\n * @returns\n */\n\n\nfunction recordPatches(subject, filter) {\n  // check all arguments\n  assertIsStateTreeNode(subject, 1);\n  var data = {\n    patches: [],\n    reversedInversePatches: []\n  }; // we will generate the immutable copy of patches on demand for public consumption\n\n  var publicData = {};\n  var disposer;\n  var recorder = {\n    get recording() {\n      return !!disposer;\n    },\n\n    get patches() {\n      if (!publicData.patches) {\n        publicData.patches = data.patches.slice();\n      }\n\n      return publicData.patches;\n    },\n\n    get reversedInversePatches() {\n      if (!publicData.reversedInversePatches) {\n        publicData.reversedInversePatches = data.reversedInversePatches.slice();\n      }\n\n      return publicData.reversedInversePatches;\n    },\n\n    get inversePatches() {\n      if (!publicData.inversePatches) {\n        publicData.inversePatches = data.reversedInversePatches.slice().reverse();\n      }\n\n      return publicData.inversePatches;\n    },\n\n    stop: function () {\n      if (disposer) {\n        disposer();\n        disposer = undefined;\n      }\n    },\n    resume: function () {\n      if (disposer) return;\n      disposer = onPatch(subject, function (patch, inversePatch) {\n        // skip patches that are asked to be filtered if there's a filter in place\n        if (filter && !filter(patch, inversePatch, getRunningActionContext())) {\n          return;\n        }\n\n        data.patches.push(patch);\n        data.reversedInversePatches.unshift(inversePatch); // mark immutable public patches as dirty\n\n        publicData.patches = undefined;\n        publicData.inversePatches = undefined;\n        publicData.reversedInversePatches = undefined;\n      });\n    },\n    replay: function (target) {\n      applyPatch(target || subject, data.patches);\n    },\n    undo: function (target) {\n      applyPatch(target || subject, data.reversedInversePatches);\n    }\n  };\n  recorder.resume();\n  return recorder;\n}\n/**\n * The inverse of `unprotect`.\n *\n * @param target\n */\n\n\nfunction protect(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  var node = getStateTreeNode(target);\n  if (!node.isRoot) throw fail$1(\"`protect` can only be invoked on root nodes\");\n  node.isProtectionEnabled = true;\n}\n/**\n * By default it is not allowed to directly modify a model. Models can only be modified through actions.\n * However, in some cases you don't care about the advantages (like replayability, traceability, etc) this yields.\n * For example because you are building a PoC or don't have any middleware attached to your tree.\n *\n * In that case you can disable this protection by calling `unprotect` on the root of your tree.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *     done: false\n * }).actions(self => ({\n *     toggle() {\n *         self.done = !self.done\n *     }\n * }))\n *\n * const todo = Todo.create()\n * todo.done = true // throws!\n * todo.toggle() // OK\n * unprotect(todo)\n * todo.done = false // OK\n * ```\n */\n\n\nfunction unprotect(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  var node = getStateTreeNode(target);\n  if (!node.isRoot) throw fail$1(\"`unprotect` can only be invoked on root nodes\");\n  node.isProtectionEnabled = false;\n}\n/**\n * Returns true if the object is in protected mode, @see protect\n */\n\n\nfunction isProtected(target) {\n  return getStateTreeNode(target).isProtected;\n}\n/**\n * Applies a snapshot to a given model instances. Patch and snapshot listeners will be invoked as usual.\n *\n * @param target\n * @param snapshot\n * @returns\n */\n\n\nfunction applySnapshot(target, snapshot) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  return getStateTreeNode(target).applySnapshot(snapshot);\n}\n/**\n * Calculates a snapshot from the given model instance. The snapshot will always reflect the latest state but use\n * structural sharing where possible. Doesn't require MobX transactions to be completed.\n *\n * @param target\n * @param applyPostProcess If true (the default) then postProcessSnapshot gets applied.\n * @returns\n */\n\n\nfunction getSnapshot(target, applyPostProcess) {\n  if (applyPostProcess === void 0) {\n    applyPostProcess = true;\n  } // check all arguments\n\n\n  assertIsStateTreeNode(target, 1);\n  var node = getStateTreeNode(target);\n  if (applyPostProcess) return node.snapshot;\n  return freeze(node.type.getSnapshot(node, false));\n}\n/**\n * Given a model instance, returns `true` if the object has a parent, that is, is part of another object, map or array.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\n\n\nfunction hasParent(target, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  } // check all arguments\n\n\n  assertIsStateTreeNode(target, 1);\n  assertIsNumber(depth, 2, 0);\n  var parent = getStateTreeNode(target).parent;\n\n  while (parent) {\n    if (--depth === 0) return true;\n    parent = parent.parent;\n  }\n\n  return false;\n}\n/**\n * Returns the immediate parent of this object, or throws.\n *\n * Note that the immediate parent can be either an object, map or array, and\n * doesn't necessarily refer to the parent model.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\n\n\nfunction getParent(target, depth) {\n  if (depth === void 0) {\n    depth = 1;\n  } // check all arguments\n\n\n  assertIsStateTreeNode(target, 1);\n  assertIsNumber(depth, 2, 0);\n  var d = depth;\n  var parent = getStateTreeNode(target).parent;\n\n  while (parent) {\n    if (--d === 0) return parent.storedValue;\n    parent = parent.parent;\n  }\n\n  throw fail$1(\"Failed to find the parent of \" + getStateTreeNode(target) + \" at depth \" + depth);\n}\n/**\n * Given a model instance, returns `true` if the object has a parent of given type, that is, is part of another object, map or array\n *\n * @param target\n * @param type\n * @returns\n */\n\n\nfunction hasParentOfType(target, type) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  assertIsType(type, 2);\n  var parent = getStateTreeNode(target).parent;\n\n  while (parent) {\n    if (type.is(parent.storedValue)) return true;\n    parent = parent.parent;\n  }\n\n  return false;\n}\n/**\n * Returns the target's parent of a given type, or throws.\n *\n * @param target\n * @param type\n * @returns\n */\n\n\nfunction getParentOfType(target, type) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  assertIsType(type, 2);\n  var parent = getStateTreeNode(target).parent;\n\n  while (parent) {\n    if (type.is(parent.storedValue)) return parent.storedValue;\n    parent = parent.parent;\n  }\n\n  throw fail$1(\"Failed to find the parent of \" + getStateTreeNode(target) + \" of a given type\");\n}\n/**\n * Given an object in a model tree, returns the root object of that tree.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @returns\n */\n\n\nfunction getRoot(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  return getStateTreeNode(target).root.storedValue;\n}\n/**\n * Returns the path of the given object in the model tree\n *\n * @param target\n * @returns\n */\n\n\nfunction getPath(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  return getStateTreeNode(target).path;\n}\n/**\n * Returns the path of the given object as unescaped string array.\n *\n * @param target\n * @returns\n */\n\n\nfunction getPathParts(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  return splitJsonPath(getStateTreeNode(target).path);\n}\n/**\n * Returns true if the given object is the root of a model tree.\n *\n * @param target\n * @returns\n */\n\n\nfunction isRoot(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  return getStateTreeNode(target).isRoot;\n}\n/**\n * Resolves a path relatively to a given object.\n * Returns undefined if no value can be found.\n *\n * @param target\n * @param path escaped json path\n * @returns\n */\n\n\nfunction resolvePath(target, path) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  assertIsString(path, 2);\n  var node = resolveNodeByPath(getStateTreeNode(target), path);\n  return node ? node.value : undefined;\n}\n/**\n * Resolves a model instance given a root target, the type and the identifier you are searching for.\n * Returns undefined if no value can be found.\n *\n * @param type\n * @param target\n * @param identifier\n * @returns\n */\n\n\nfunction resolveIdentifier(type, target, identifier) {\n  // check all arguments\n  assertIsType(type, 1);\n  assertIsStateTreeNode(target, 2);\n  assertIsValidIdentifier(identifier, 3);\n  var node = getStateTreeNode(target).root.identifierCache.resolve(type, normalizeIdentifier(identifier));\n  return node ? node.value : undefined;\n}\n/**\n * Returns the identifier of the target node.\n * This is the *string normalized* identifier, which might not match the type of the identifier attribute\n *\n * @param target\n * @returns\n */\n\n\nfunction getIdentifier(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  return getStateTreeNode(target).identifier;\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns such reference if it the check passes,\n * else it returns undefined.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\n\n\nfunction tryReference(getter, checkIfAlive) {\n  if (checkIfAlive === void 0) {\n    checkIfAlive = true;\n  }\n\n  try {\n    var node = getter();\n\n    if (node === undefined || node === null) {\n      return undefined;\n    } else if (isStateTreeNode(node)) {\n      if (!checkIfAlive) {\n        return node;\n      } else {\n        return isAlive(node) ? node : undefined;\n      }\n    } else {\n      throw fail$1(\"The reference to be checked is not one of node, null or undefined\");\n    }\n  } catch (e) {\n    if (e instanceof InvalidReferenceError) {\n      return undefined;\n    }\n\n    throw e;\n  }\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns if the check passes or not.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\n\n\nfunction isValidReference(getter, checkIfAlive) {\n  if (checkIfAlive === void 0) {\n    checkIfAlive = true;\n  }\n\n  try {\n    var node = getter();\n\n    if (node === undefined || node === null) {\n      return false;\n    } else if (isStateTreeNode(node)) {\n      return checkIfAlive ? isAlive(node) : true;\n    } else {\n      throw fail$1(\"The reference to be checked is not one of node, null or undefined\");\n    }\n  } catch (e) {\n    if (e instanceof InvalidReferenceError) {\n      return false;\n    }\n\n    throw e;\n  }\n}\n/**\n * Try to resolve a given path relative to a given node.\n *\n * @param target\n * @param path\n * @returns\n */\n\n\nfunction tryResolve(target, path) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  assertIsString(path, 2);\n  var node = resolveNodeByPath(getStateTreeNode(target), path, false);\n  if (node === undefined) return undefined;\n\n  try {\n    return node.value;\n  } catch (e) {\n    // For what ever reason not resolvable (e.g. totally not existing path, or value that cannot be fetched)\n    // see test / issue: 'try resolve doesn't work #686'\n    return undefined;\n  }\n}\n/**\n * Given two state tree nodes that are part of the same tree,\n * returns the shortest jsonpath needed to navigate from the one to the other\n *\n * @param base\n * @param target\n * @returns\n */\n\n\nfunction getRelativePath(base, target) {\n  // check all arguments\n  assertIsStateTreeNode(base, 1);\n  assertIsStateTreeNode(target, 2);\n  return getRelativePathBetweenNodes(getStateTreeNode(base), getStateTreeNode(target));\n}\n/**\n * Returns a deep copy of the given state tree node as new tree.\n * Short hand for `snapshot(x) = getType(x).create(getSnapshot(x))`\n *\n * _Tip: clone will create a literal copy, including the same identifiers. To modify identifiers etc during cloning, don't use clone but take a snapshot of the tree, modify it, and create new instance_\n *\n * @param source\n * @param keepEnvironment indicates whether the clone should inherit the same environment (`true`, the default), or not have an environment (`false`). If an object is passed in as second argument, that will act as the environment for the cloned tree.\n * @returns\n */\n\n\nfunction clone(source, keepEnvironment) {\n  if (keepEnvironment === void 0) {\n    keepEnvironment = true;\n  } // check all arguments\n\n\n  assertIsStateTreeNode(source, 1);\n  var node = getStateTreeNode(source);\n  return node.type.create(node.snapshot, keepEnvironment === true ? node.root.environment : keepEnvironment === false ? undefined : keepEnvironment); // it's an object or something else\n}\n/**\n * Removes a model element from the state tree, and let it live on as a new state tree\n */\n\n\nfunction detach(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  getStateTreeNode(target).detach();\n  return target;\n}\n/**\n * Removes a model element from the state tree, and mark it as end-of-life; the element should not be used anymore\n */\n\n\nfunction destroy(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  var node = getStateTreeNode(target);\n  if (node.isRoot) node.die();else node.parent.removeChild(node.subpath);\n}\n/**\n * Returns true if the given state tree node is not killed yet.\n * This means that the node is still a part of a tree, and that `destroy`\n * has not been called. If a node is not alive anymore, the only thing one can do with it\n * is requesting it's last path and snapshot\n *\n * @param target\n * @returns\n */\n\n\nfunction isAlive(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  return getStateTreeNode(target).observableIsAlive;\n}\n/**\n * Use this utility to register a function that should be called whenever the\n * targeted state tree node is destroyed. This is a useful alternative to managing\n * cleanup methods yourself using the `beforeDestroy` hook.\n *\n * This methods returns the same disposer that was passed as argument.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string\n * }).actions(self => ({\n *   afterCreate() {\n *     const autoSaveDisposer = reaction(\n *       () => getSnapshot(self),\n *       snapshot => sendSnapshotToServerSomehow(snapshot)\n *     )\n *     // stop sending updates to server if this\n *     // instance is destroyed\n *     addDisposer(self, autoSaveDisposer)\n *   }\n * }))\n * ```\n *\n * @param target\n * @param disposer\n * @returns The same disposer that was passed as argument\n */\n\n\nfunction addDisposer(target, disposer) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  assertIsFunction(disposer, 2);\n  var node = getStateTreeNode(target);\n  node.addDisposer(disposer);\n  return disposer;\n}\n/**\n * Returns the environment of the current state tree. For more info on environments,\n * see [Dependency injection](https://github.com/mobxjs/mobx-state-tree#dependency-injection)\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired\n *\n * Returns an empty environment if the tree wasn't initialized with an environment\n *\n * @param target\n * @returns\n */\n\n\nfunction getEnv(target) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  var node = getStateTreeNode(target);\n  var env = node.root.environment;\n  if (!env) return EMPTY_OBJECT;\n  return env;\n}\n/**\n * Performs a depth first walk through a tree.\n */\n\n\nfunction walk(target, processor) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  assertIsFunction(processor, 2);\n  var node = getStateTreeNode(target); // tslint:disable-next-line:no_unused-variable\n\n  node.getChildren().forEach(function (child) {\n    if (isStateTreeNode(child.storedValue)) walk(child.storedValue, processor);\n  });\n  processor(node.storedValue);\n}\n/**\n * Returns a reflection of the model type properties and name for either a model type or model node.\n *\n * @param typeOrNode\n * @returns\n */\n\n\nfunction getPropertyMembers(typeOrNode) {\n  var type;\n\n  if (isStateTreeNode(typeOrNode)) {\n    type = getType(typeOrNode);\n  } else {\n    type = typeOrNode;\n  }\n\n  assertArg(type, function (t) {\n    return isModelType(t);\n  }, \"model type or model instance\", 1);\n  return {\n    name: type.name,\n    properties: __assign({}, type.properties)\n  };\n}\n/**\n * Returns a reflection of the model node, including name, properties, views, volatile and actions.\n *\n * @param target\n * @returns\n */\n\n\nfunction getMembers(target) {\n  var type = getStateTreeNode(target).type;\n\n  var reflected = __assign(__assign({}, getPropertyMembers(type)), {\n    actions: [],\n    volatile: [],\n    views: []\n  });\n\n  var props = Object.getOwnPropertyNames(target);\n  props.forEach(function (key) {\n    if (key in reflected.properties) return;\n    var descriptor = Object.getOwnPropertyDescriptor(target, key);\n\n    if (descriptor.get) {\n      if (isComputedProp(target, key)) reflected.views.push(key);else reflected.volatile.push(key);\n      return;\n    }\n\n    if (descriptor.value._isMSTAction === true) reflected.actions.push(key);else if (isObservableProp(target, key)) reflected.volatile.push(key);else reflected.views.push(key);\n  });\n  return reflected;\n}\n/**\n * Casts a node snapshot or instance type to an instance type so it can be assigned to a type instance.\n * Note that this is just a cast for the type system, this is, it won't actually convert a snapshot to an instance,\n * but just fool typescript into thinking so.\n * Either way, casting when outside an assignation operation won't compile.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * }).actions(self => ({\n *   someAction() {\n *     // this will allow the compiler to assign a snapshot to the property\n *     self.innerModel = cast({ a: 5 })\n *   }\n * }))\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object casted as an instance\n */\n\n\nfunction cast(snapshotOrInstance) {\n  return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to an snapshot type so it can be assigned to a type snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * })\n *\n * const a = ModelA.create({ n: 5 });\n * // this will allow the compiler to use a model as if it were a snapshot\n * const b = ModelB.create({ innerModel: castToSnapshot(a)})\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object casted as an input (creation) snapshot\n */\n\n\nfunction castToSnapshot(snapshotOrInstance) {\n  return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to a reference snapshot type so it can be assigned to a refernence snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a refererence snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   id: types.identifier,\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   refA: types.reference(ModelA)\n * })\n *\n * const a = ModelA.create({ id: 'someId', n: 5 });\n * // this will allow the compiler to use a model as if it were a reference snapshot\n * const b = ModelB.create({ refA: castToReference(a)})\n * ```\n *\n * @param instance Instance\n * @returns The same object casted as an reference snapshot (string or number)\n */\n\n\nfunction castToReferenceSnapshot(instance) {\n  return instance;\n}\n/**\n * Returns the unique node id (not to be confused with the instance identifier) for a\n * given instance.\n * This id is a number that is unique for each instance.\n *\n * @export\n * @param target\n * @returns\n */\n\n\nfunction getNodeId(target) {\n  assertIsStateTreeNode(target, 1);\n  return getStateTreeNode(target).nodeId;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar BaseNode =\n/** @class */\nfunction () {\n  function BaseNode(type, parent, subpath, environment) {\n    this.type = type;\n    this.environment = environment;\n    this._state = NodeLifeCycle.INITIALIZING;\n    this.environment = environment;\n    this.baseSetParent(parent, subpath);\n  }\n\n  Object.defineProperty(BaseNode.prototype, \"subpath\", {\n    get: function () {\n      return this._subpath;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseNode.prototype, \"subpathUponDeath\", {\n    get: function () {\n      return this._subpathUponDeath;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseNode.prototype, \"pathUponDeath\", {\n    get: function () {\n      return this._pathUponDeath;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseNode.prototype, \"value\", {\n    get: function () {\n      return this.type.getValue(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseNode.prototype, \"state\", {\n    get: function () {\n      return this._state;\n    },\n    set: function (val) {\n      var wasAlive = this.isAlive;\n      this._state = val;\n      var isAlive = this.isAlive;\n\n      if (this.aliveAtom && wasAlive !== isAlive) {\n        this.aliveAtom.reportChanged();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BaseNode.prototype.fireInternalHook = function (name) {\n    if (this._hookSubscribers) {\n      this._hookSubscribers.emit(name, this, name);\n    }\n  };\n\n  BaseNode.prototype.registerHook = function (hook, hookHandler) {\n    if (!this._hookSubscribers) {\n      this._hookSubscribers = new EventHandlers();\n    }\n\n    return this._hookSubscribers.register(hook, hookHandler);\n  };\n\n  Object.defineProperty(BaseNode.prototype, \"parent\", {\n    get: function () {\n      return this._parent;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BaseNode.prototype.baseSetParent = function (parent, subpath) {\n    this._parent = parent;\n    this._subpath = subpath;\n    this._escapedSubpath = undefined; // regenerate when needed\n\n    if (this.pathAtom) {\n      this.pathAtom.reportChanged();\n    }\n  };\n\n  Object.defineProperty(BaseNode.prototype, \"path\", {\n    /*\n     * Returns (escaped) path representation as string\n     */\n    get: function () {\n      return this.getEscapedPath(true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BaseNode.prototype.getEscapedPath = function (reportObserved) {\n    if (reportObserved) {\n      if (!this.pathAtom) {\n        this.pathAtom = createAtom(\"path\");\n      }\n\n      this.pathAtom.reportObserved();\n    }\n\n    if (!this.parent) return \"\"; // regenerate escaped subpath if needed\n\n    if (this._escapedSubpath === undefined) {\n      this._escapedSubpath = !this._subpath ? \"\" : escapeJsonPath(this._subpath);\n    }\n\n    return this.parent.getEscapedPath(reportObserved) + \"/\" + this._escapedSubpath;\n  };\n\n  Object.defineProperty(BaseNode.prototype, \"isRoot\", {\n    get: function () {\n      return this.parent === null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseNode.prototype, \"isAlive\", {\n    get: function () {\n      return this.state !== NodeLifeCycle.DEAD;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseNode.prototype, \"isDetaching\", {\n    get: function () {\n      return this.state === NodeLifeCycle.DETACHING;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseNode.prototype, \"observableIsAlive\", {\n    get: function () {\n      if (!this.aliveAtom) {\n        this.aliveAtom = createAtom(\"alive\");\n      }\n\n      this.aliveAtom.reportObserved();\n      return this.isAlive;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BaseNode.prototype.baseFinalizeCreation = function (whenFinalized) {\n    if (devMode()) {\n      if (!this.isAlive) {\n        // istanbul ignore next\n        throw fail(\"assertion failed: cannot finalize the creation of a node that is already dead\");\n      }\n    } // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already\n\n\n    if (this.state === NodeLifeCycle.CREATED) {\n      if (this.parent) {\n        if (this.parent.state !== NodeLifeCycle.FINALIZED) {\n          // parent not ready yet, postpone\n          return;\n        }\n\n        this.fireHook(Hook.afterAttach);\n      }\n\n      this.state = NodeLifeCycle.FINALIZED;\n\n      if (whenFinalized) {\n        whenFinalized();\n      }\n    }\n  };\n\n  BaseNode.prototype.baseFinalizeDeath = function () {\n    if (this._hookSubscribers) {\n      this._hookSubscribers.clearAll();\n    }\n\n    this._subpathUponDeath = this._subpath;\n    this._pathUponDeath = this.getEscapedPath(false);\n    this.baseSetParent(null, \"\");\n    this.state = NodeLifeCycle.DEAD;\n  };\n\n  BaseNode.prototype.baseAboutToDie = function () {\n    this.fireHook(Hook.beforeDestroy);\n  };\n\n  return BaseNode;\n}();\n/**\n * @internal\n * @hidden\n */\n\n\nvar ScalarNode =\n/** @class */\nfunction (_super) {\n  __extends(ScalarNode, _super);\n\n  function ScalarNode(simpleType, parent, subpath, environment, initialSnapshot) {\n    var _this = _super.call(this, simpleType, parent, subpath, environment) || this;\n\n    try {\n      _this.storedValue = simpleType.createNewInstance(initialSnapshot);\n    } catch (e) {\n      // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n      _this.state = NodeLifeCycle.DEAD;\n      throw e;\n    }\n\n    _this.state = NodeLifeCycle.CREATED; // for scalar nodes there's no point in firing this event since it would fire on the constructor, before\n    // anybody can actually register for/listen to it\n    // this.fireHook(Hook.AfterCreate)\n\n    _this.finalizeCreation();\n\n    return _this;\n  }\n\n  Object.defineProperty(ScalarNode.prototype, \"root\", {\n    get: function () {\n      // future optimization: store root ref in the node and maintain it\n      if (!this.parent) throw fail$1(\"This scalar node is not part of a tree\");\n      return this.parent.root;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ScalarNode.prototype.setParent = function (newParent, subpath) {\n    var parentChanged = this.parent !== newParent;\n    var subpathChanged = this.subpath !== subpath;\n\n    if (!parentChanged && !subpathChanged) {\n      return;\n    }\n\n    if (devMode()) {\n      if (!subpath) {\n        // istanbul ignore next\n        throw fail$1(\"assertion failed: subpath expected\");\n      }\n\n      if (!newParent) {\n        // istanbul ignore next\n        throw fail$1(\"assertion failed: parent expected\");\n      }\n\n      if (parentChanged) {\n        // istanbul ignore next\n        throw fail$1(\"assertion failed: scalar nodes cannot change their parent\");\n      }\n    }\n\n    this.environment = undefined; // use parent's\n\n    this.baseSetParent(this.parent, subpath);\n  };\n\n  Object.defineProperty(ScalarNode.prototype, \"snapshot\", {\n    get: function () {\n      return freeze(this.getSnapshot());\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ScalarNode.prototype.getSnapshot = function () {\n    return this.type.getSnapshot(this);\n  };\n\n  ScalarNode.prototype.toString = function () {\n    var path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n    return this.type.name + \"@\" + path + (this.isAlive ? \"\" : \" [dead]\");\n  };\n\n  ScalarNode.prototype.die = function () {\n    if (!this.isAlive || this.state === NodeLifeCycle.DETACHING) return;\n    this.aboutToDie();\n    this.finalizeDeath();\n  };\n\n  ScalarNode.prototype.finalizeCreation = function () {\n    this.baseFinalizeCreation();\n  };\n\n  ScalarNode.prototype.aboutToDie = function () {\n    this.baseAboutToDie();\n  };\n\n  ScalarNode.prototype.finalizeDeath = function () {\n    this.baseFinalizeDeath();\n  };\n\n  ScalarNode.prototype.fireHook = function (name) {\n    this.fireInternalHook(name);\n  };\n\n  __decorate([action], ScalarNode.prototype, \"die\", null);\n\n  return ScalarNode;\n}(BaseNode);\n\nvar nextNodeId = 1;\nvar snapshotReactionOptions = {\n  onError: function (e) {\n    throw e;\n  }\n};\n/**\n * @internal\n * @hidden\n */\n\nvar ObjectNode =\n/** @class */\nfunction (_super) {\n  __extends(ObjectNode, _super);\n\n  function ObjectNode(complexType, parent, subpath, environment, initialValue) {\n    var _this = _super.call(this, complexType, parent, subpath, environment) || this;\n\n    _this.nodeId = ++nextNodeId;\n    _this.isProtectionEnabled = true;\n    _this._autoUnbox = true; // unboxing is disabled when reading child nodes\n\n    _this._isRunningAction = false; // only relevant for root\n\n    _this._hasSnapshotReaction = false;\n    _this._observableInstanceState = 0\n    /* UNINITIALIZED */\n    ;\n    _this._cachedInitialSnapshotCreated = false;\n    _this.unbox = _this.unbox.bind(_this);\n    _this._initialSnapshot = freeze(initialValue);\n    _this.identifierAttribute = complexType.identifierAttribute;\n\n    if (!parent) {\n      _this.identifierCache = new IdentifierCache();\n    }\n\n    _this._childNodes = complexType.initializeChildNodes(_this, _this._initialSnapshot); // identifier can not be changed during lifecycle of a node\n    // so we safely can read it from initial snapshot\n\n    _this.identifier = null;\n    _this.unnormalizedIdentifier = null;\n\n    if (_this.identifierAttribute && _this._initialSnapshot) {\n      var id = _this._initialSnapshot[_this.identifierAttribute];\n\n      if (id === undefined) {\n        // try with the actual node if not (for optional identifiers)\n        var childNode = _this._childNodes[_this.identifierAttribute];\n\n        if (childNode) {\n          id = childNode.value;\n        }\n      }\n\n      if (typeof id !== \"string\" && typeof id !== \"number\") {\n        throw fail$1(\"Instance identifier '\" + _this.identifierAttribute + \"' for type '\" + _this.type.name + \"' must be a string or a number\");\n      } // normalize internal identifier to string\n\n\n      _this.identifier = normalizeIdentifier(id);\n      _this.unnormalizedIdentifier = id;\n    }\n\n    if (!parent) {\n      _this.identifierCache.addNodeToCache(_this);\n    } else {\n      parent.root.identifierCache.addNodeToCache(_this);\n    }\n\n    return _this;\n  }\n\n  ObjectNode.prototype.applyPatches = function (patches) {\n    this.createObservableInstanceIfNeeded();\n\n    this._applyPatches(patches);\n  };\n\n  ObjectNode.prototype.applySnapshot = function (snapshot) {\n    this.createObservableInstanceIfNeeded();\n\n    this._applySnapshot(snapshot);\n  };\n\n  ObjectNode.prototype.createObservableInstanceIfNeeded = function () {\n    if (this._observableInstanceState === 0\n    /* UNINITIALIZED */\n    ) {\n        this.createObservableInstance();\n      }\n  };\n\n  ObjectNode.prototype.createObservableInstance = function () {\n    var e_1, _a;\n\n    if (devMode()) {\n      if (this.state !== NodeLifeCycle.INITIALIZING) {\n        // istanbul ignore next\n        throw fail$1(\"assertion failed: the creation of the observable instance must be done on the initializing phase\");\n      }\n    }\n\n    this._observableInstanceState = 1\n    /* CREATING */\n    ; // make sure the parent chain is created as well\n    // array with parent chain from parent to child\n\n    var parentChain = [];\n    var parent = this.parent; // for performance reasons we never go back further than the most direct\n    // uninitialized parent\n    // this is done to avoid traversing the whole tree to the root when using\n    // the same reference again\n\n    while (parent && parent._observableInstanceState === 0\n    /* UNINITIALIZED */\n    ) {\n      parentChain.unshift(parent);\n      parent = parent.parent;\n    }\n\n    try {\n      // initialize the uninitialized parent chain from parent to child\n      for (var parentChain_1 = __values(parentChain), parentChain_1_1 = parentChain_1.next(); !parentChain_1_1.done; parentChain_1_1 = parentChain_1.next()) {\n        var p = parentChain_1_1.value;\n        p.createObservableInstanceIfNeeded();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (parentChain_1_1 && !parentChain_1_1.done && (_a = parentChain_1.return)) _a.call(parentChain_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var type = this.type;\n\n    try {\n      this.storedValue = type.createNewInstance(this._childNodes);\n      this.preboot();\n      this._isRunningAction = true;\n      type.finalizeNewInstance(this, this.storedValue);\n    } catch (e) {\n      // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n      this.state = NodeLifeCycle.DEAD;\n      throw e;\n    } finally {\n      this._isRunningAction = false;\n    }\n\n    this._observableInstanceState = 2\n    /* CREATED */\n    ; // NOTE: we need to touch snapshot, because non-observable\n    // \"_observableInstanceState\" field was touched\n\n    invalidateComputed(this, \"snapshot\");\n    if (this.isRoot) this._addSnapshotReaction();\n    this._childNodes = EMPTY_OBJECT;\n    this.state = NodeLifeCycle.CREATED;\n    this.fireHook(Hook.afterCreate);\n    this.finalizeCreation();\n  };\n\n  Object.defineProperty(ObjectNode.prototype, \"root\", {\n    get: function () {\n      var parent = this.parent;\n      return parent ? parent.root : this;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ObjectNode.prototype.clearParent = function () {\n    if (!this.parent) return; // detach if attached\n\n    this.fireHook(Hook.beforeDetach);\n    var previousState = this.state;\n    this.state = NodeLifeCycle.DETACHING;\n    var root = this.root;\n    var newEnv = root.environment;\n    var newIdCache = root.identifierCache.splitCache(this);\n\n    try {\n      this.parent.removeChild(this.subpath);\n      this.baseSetParent(null, \"\");\n      this.environment = newEnv;\n      this.identifierCache = newIdCache;\n    } finally {\n      this.state = previousState;\n    }\n  };\n\n  ObjectNode.prototype.setParent = function (newParent, subpath) {\n    var parentChanged = newParent !== this.parent;\n    var subpathChanged = subpath !== this.subpath;\n\n    if (!parentChanged && !subpathChanged) {\n      return;\n    }\n\n    if (devMode()) {\n      if (!subpath) {\n        // istanbul ignore next\n        throw fail$1(\"assertion failed: subpath expected\");\n      }\n\n      if (!newParent) {\n        // istanbul ignore next\n        throw fail$1(\"assertion failed: new parent expected\");\n      }\n\n      if (this.parent && parentChanged) {\n        throw fail$1(\"A node cannot exists twice in the state tree. Failed to add \" + this + \" to path '\" + newParent.path + \"/\" + subpath + \"'.\");\n      }\n\n      if (!this.parent && newParent.root === this) {\n        throw fail$1(\"A state tree is not allowed to contain itself. Cannot assign \" + this + \" to path '\" + newParent.path + \"/\" + subpath + \"'\");\n      }\n\n      if (!this.parent && !!this.environment && this.environment !== newParent.root.environment) {\n        throw fail$1(\"A state tree cannot be made part of another state tree as long as their environments are different.\");\n      }\n    }\n\n    if (parentChanged) {\n      // attach to new parent\n      this.environment = undefined; // will use root's\n\n      newParent.root.identifierCache.mergeCache(this);\n      this.baseSetParent(newParent, subpath);\n      this.fireHook(Hook.afterAttach);\n    } else if (subpathChanged) {\n      // moving to a new subpath on the same parent\n      this.baseSetParent(this.parent, subpath);\n    }\n  };\n\n  ObjectNode.prototype.fireHook = function (name) {\n    var _this = this;\n\n    this.fireInternalHook(name);\n    var fn = this.storedValue && typeof this.storedValue === \"object\" && this.storedValue[name];\n\n    if (typeof fn === \"function\") {\n      // we check for it to allow old mobx peer dependencies that don't have the method to work (even when still bugged)\n      if (_allowStateChangesInsideComputed) {\n        _allowStateChangesInsideComputed(function () {\n          fn.apply(_this.storedValue);\n        });\n      } else {\n        fn.apply(this.storedValue);\n      }\n    }\n  };\n\n  Object.defineProperty(ObjectNode.prototype, \"snapshot\", {\n    // advantage of using computed for a snapshot is that nicely respects transactions etc.\n    get: function () {\n      return freeze(this.getSnapshot());\n    },\n    enumerable: true,\n    configurable: true\n  }); // NOTE: we use this method to get snapshot without creating @computed overhead\n\n  ObjectNode.prototype.getSnapshot = function () {\n    if (!this.isAlive) return this._snapshotUponDeath;\n    return this._observableInstanceState === 2\n    /* CREATED */\n    ? this._getActualSnapshot() : this._getCachedInitialSnapshot();\n  };\n\n  ObjectNode.prototype._getActualSnapshot = function () {\n    return this.type.getSnapshot(this);\n  };\n\n  ObjectNode.prototype._getCachedInitialSnapshot = function () {\n    if (!this._cachedInitialSnapshotCreated) {\n      var type = this.type;\n      var childNodes = this._childNodes;\n      var snapshot = this._initialSnapshot;\n      this._cachedInitialSnapshot = type.processInitialSnapshot(childNodes, snapshot);\n      this._cachedInitialSnapshotCreated = true;\n    }\n\n    return this._cachedInitialSnapshot;\n  };\n\n  ObjectNode.prototype.isRunningAction = function () {\n    if (this._isRunningAction) return true;\n    if (this.isRoot) return false;\n    return this.parent.isRunningAction();\n  };\n\n  ObjectNode.prototype.assertAlive = function (context) {\n    var livelinessChecking = getLivelinessChecking();\n\n    if (!this.isAlive && livelinessChecking !== \"ignore\") {\n      var error = this._getAssertAliveError(context);\n\n      switch (livelinessChecking) {\n        case \"error\":\n          throw fail$1(error);\n\n        case \"warn\":\n          warnError(error);\n      }\n    }\n  };\n\n  ObjectNode.prototype._getAssertAliveError = function (context) {\n    var escapedPath = this.getEscapedPath(false) || this.pathUponDeath || \"\";\n    var subpath = context.subpath && escapeJsonPath(context.subpath) || \"\";\n    var actionContext = context.actionContext || getCurrentActionContext(); // try to use a real action context if possible since it includes the action name\n\n    if (actionContext && actionContext.type !== \"action\" && actionContext.parentActionEvent) {\n      actionContext = actionContext.parentActionEvent;\n    }\n\n    var actionFullPath = \"\";\n\n    if (actionContext && actionContext.name != null) {\n      // try to use the context, and if it not available use the node one\n      var actionPath = actionContext && actionContext.context && getPath(actionContext.context) || escapedPath;\n      actionFullPath = actionPath + \".\" + actionContext.name + \"()\";\n    }\n\n    return \"You are trying to read or write to an object that is no longer part of a state tree. (Object type: '\" + this.type.name + \"', Path upon death: '\" + escapedPath + \"', Subpath: '\" + subpath + \"', Action: '\" + actionFullPath + \"'). Either detach nodes first, or don't use objects after removing / replacing them in the tree.\";\n  };\n\n  ObjectNode.prototype.getChildNode = function (subpath) {\n    this.assertAlive({\n      subpath: subpath\n    });\n    this._autoUnbox = false;\n\n    try {\n      return this._observableInstanceState === 2\n      /* CREATED */\n      ? this.type.getChildNode(this, subpath) : this._childNodes[subpath];\n    } finally {\n      this._autoUnbox = true;\n    }\n  };\n\n  ObjectNode.prototype.getChildren = function () {\n    this.assertAlive(EMPTY_OBJECT);\n    this._autoUnbox = false;\n\n    try {\n      return this._observableInstanceState === 2\n      /* CREATED */\n      ? this.type.getChildren(this) : convertChildNodesToArray(this._childNodes);\n    } finally {\n      this._autoUnbox = true;\n    }\n  };\n\n  ObjectNode.prototype.getChildType = function (propertyName) {\n    return this.type.getChildType(propertyName);\n  };\n\n  Object.defineProperty(ObjectNode.prototype, \"isProtected\", {\n    get: function () {\n      return this.root.isProtectionEnabled;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ObjectNode.prototype.assertWritable = function (context) {\n    this.assertAlive(context);\n\n    if (!this.isRunningAction() && this.isProtected) {\n      throw fail$1(\"Cannot modify '\" + this + \"', the object is protected and can only be modified by using an action.\");\n    }\n  };\n\n  ObjectNode.prototype.removeChild = function (subpath) {\n    this.type.removeChild(this, subpath);\n  }; // bound on the constructor\n\n\n  ObjectNode.prototype.unbox = function (childNode) {\n    if (!childNode) return childNode;\n    this.assertAlive({\n      subpath: childNode.subpath || childNode.subpathUponDeath\n    });\n    return this._autoUnbox ? childNode.value : childNode;\n  };\n\n  ObjectNode.prototype.toString = function () {\n    var path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n    var identifier = this.identifier ? \"(id: \" + this.identifier + \")\" : \"\";\n    return this.type.name + \"@\" + path + identifier + (this.isAlive ? \"\" : \" [dead]\");\n  };\n\n  ObjectNode.prototype.finalizeCreation = function () {\n    var _this = this;\n\n    this.baseFinalizeCreation(function () {\n      var e_2, _a;\n\n      try {\n        for (var _b = __values(_this.getChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          child.finalizeCreation();\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      _this.fireInternalHook(Hook.afterCreationFinalization);\n    });\n  };\n\n  ObjectNode.prototype.detach = function () {\n    if (!this.isAlive) throw fail$1(\"Error while detaching, node is not alive.\");\n    this.clearParent();\n  };\n\n  ObjectNode.prototype.preboot = function () {\n    var self = this;\n    this._applyPatches = createActionInvoker(this.storedValue, \"@APPLY_PATCHES\", function (patches) {\n      patches.forEach(function (patch) {\n        var parts = splitJsonPath(patch.path);\n        var node = resolveNodeByPathParts(self, parts.slice(0, -1));\n        node.applyPatchLocally(parts[parts.length - 1], patch);\n      });\n    });\n    this._applySnapshot = createActionInvoker(this.storedValue, \"@APPLY_SNAPSHOT\", function (snapshot) {\n      // if the snapshot is the same as the current one, avoid performing a reconcile\n      if (snapshot === self.snapshot) return; // else, apply it by calling the type logic\n\n      return self.type.applySnapshot(self, snapshot);\n    });\n    addHiddenFinalProp(this.storedValue, \"$treenode\", this);\n    addHiddenFinalProp(this.storedValue, \"toJSON\", toJSON);\n  };\n\n  ObjectNode.prototype.die = function () {\n    if (!this.isAlive || this.state === NodeLifeCycle.DETACHING) return;\n    this.aboutToDie();\n    this.finalizeDeath();\n  };\n\n  ObjectNode.prototype.aboutToDie = function () {\n    if (this._observableInstanceState === 0\n    /* UNINITIALIZED */\n    ) {\n        return;\n      }\n\n    this.getChildren().forEach(function (node) {\n      node.aboutToDie();\n    }); // beforeDestroy should run before the disposers since else we could end up in a situation where\n    // a disposer added with addDisposer at this stage (beforeDestroy) is actually never released\n\n    this.baseAboutToDie();\n\n    this._internalEventsEmit(\"dispose\"\n    /* Dispose */\n    );\n\n    this._internalEventsClear(\"dispose\"\n    /* Dispose */\n    );\n  };\n\n  ObjectNode.prototype.finalizeDeath = function () {\n    // invariant: not called directly but from \"die\"\n    this.getChildren().forEach(function (node) {\n      node.finalizeDeath();\n    });\n    this.root.identifierCache.notifyDied(this); // \"kill\" the computed prop and just store the last snapshot\n\n    var snapshot = this.snapshot;\n    this._snapshotUponDeath = snapshot;\n\n    this._internalEventsClearAll();\n\n    this.baseFinalizeDeath();\n  };\n\n  ObjectNode.prototype.onSnapshot = function (onChange) {\n    this._addSnapshotReaction();\n\n    return this._internalEventsRegister(\"snapshot\"\n    /* Snapshot */\n    , onChange);\n  };\n\n  ObjectNode.prototype.emitSnapshot = function (snapshot) {\n    this._internalEventsEmit(\"snapshot\"\n    /* Snapshot */\n    , snapshot);\n  };\n\n  ObjectNode.prototype.onPatch = function (handler) {\n    return this._internalEventsRegister(\"patch\"\n    /* Patch */\n    , handler);\n  };\n\n  ObjectNode.prototype.emitPatch = function (basePatch, source) {\n    if (this._internalEventsHasSubscribers(\"patch\"\n    /* Patch */\n    )) {\n      var localizedPatch = extend({}, basePatch, {\n        path: source.path.substr(this.path.length) + \"/\" + basePatch.path // calculate the relative path of the patch\n\n      });\n\n      var _a = __read(splitPatch(localizedPatch), 2),\n          patch = _a[0],\n          reversePatch = _a[1];\n\n      this._internalEventsEmit(\"patch\"\n      /* Patch */\n      , patch, reversePatch);\n    }\n\n    if (this.parent) this.parent.emitPatch(basePatch, source);\n  };\n\n  ObjectNode.prototype.hasDisposer = function (disposer) {\n    return this._internalEventsHas(\"dispose\"\n    /* Dispose */\n    , disposer);\n  };\n\n  ObjectNode.prototype.addDisposer = function (disposer) {\n    if (!this.hasDisposer(disposer)) {\n      this._internalEventsRegister(\"dispose\"\n      /* Dispose */\n      , disposer, true);\n\n      return;\n    }\n\n    throw fail$1(\"cannot add a disposer when it is already registered for execution\");\n  };\n\n  ObjectNode.prototype.removeDisposer = function (disposer) {\n    if (!this._internalEventsHas(\"dispose\"\n    /* Dispose */\n    , disposer)) {\n      throw fail$1(\"cannot remove a disposer which was never registered for execution\");\n    }\n\n    this._internalEventsUnregister(\"dispose\"\n    /* Dispose */\n    , disposer);\n  };\n\n  ObjectNode.prototype.removeMiddleware = function (middleware) {\n    if (this.middlewares) {\n      var index = this.middlewares.indexOf(middleware);\n\n      if (index >= 0) {\n        this.middlewares.splice(index, 1);\n      }\n    }\n  };\n\n  ObjectNode.prototype.addMiddleWare = function (handler, includeHooks) {\n    var _this = this;\n\n    if (includeHooks === void 0) {\n      includeHooks = true;\n    }\n\n    var middleware = {\n      handler: handler,\n      includeHooks: includeHooks\n    };\n    if (!this.middlewares) this.middlewares = [middleware];else this.middlewares.push(middleware);\n    return function () {\n      _this.removeMiddleware(middleware);\n    };\n  };\n\n  ObjectNode.prototype.applyPatchLocally = function (subpath, patch) {\n    this.assertWritable({\n      subpath: subpath\n    });\n    this.createObservableInstanceIfNeeded();\n    this.type.applyPatchLocally(this, subpath, patch);\n  };\n\n  ObjectNode.prototype._addSnapshotReaction = function () {\n    var _this = this;\n\n    if (!this._hasSnapshotReaction) {\n      var snapshotDisposer = reaction(function () {\n        return _this.snapshot;\n      }, function (snapshot) {\n        return _this.emitSnapshot(snapshot);\n      }, snapshotReactionOptions);\n      this.addDisposer(snapshotDisposer);\n      this._hasSnapshotReaction = true;\n    }\n  }; // we proxy the methods to avoid creating an EventHandlers instance when it is not needed\n\n\n  ObjectNode.prototype._internalEventsHasSubscribers = function (event) {\n    return !!this._internalEvents && this._internalEvents.hasSubscribers(event);\n  };\n\n  ObjectNode.prototype._internalEventsRegister = function (event, eventHandler, atTheBeginning) {\n    if (atTheBeginning === void 0) {\n      atTheBeginning = false;\n    }\n\n    if (!this._internalEvents) {\n      this._internalEvents = new EventHandlers();\n    }\n\n    return this._internalEvents.register(event, eventHandler, atTheBeginning);\n  };\n\n  ObjectNode.prototype._internalEventsHas = function (event, eventHandler) {\n    return !!this._internalEvents && this._internalEvents.has(event, eventHandler);\n  };\n\n  ObjectNode.prototype._internalEventsUnregister = function (event, eventHandler) {\n    if (this._internalEvents) {\n      this._internalEvents.unregister(event, eventHandler);\n    }\n  };\n\n  ObjectNode.prototype._internalEventsEmit = function (event) {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (this._internalEvents) {\n      (_a = this._internalEvents).emit.apply(_a, __spread([event], args));\n    }\n  };\n\n  ObjectNode.prototype._internalEventsClear = function (event) {\n    if (this._internalEvents) {\n      this._internalEvents.clear(event);\n    }\n  };\n\n  ObjectNode.prototype._internalEventsClearAll = function () {\n    if (this._internalEvents) {\n      this._internalEvents.clearAll();\n    }\n  };\n\n  __decorate([action], ObjectNode.prototype, \"createObservableInstance\", null);\n\n  __decorate([computed], ObjectNode.prototype, \"snapshot\", null);\n\n  __decorate([action], ObjectNode.prototype, \"detach\", null);\n\n  __decorate([action], ObjectNode.prototype, \"die\", null);\n\n  return ObjectNode;\n}(BaseNode);\n/**\n * @internal\n * @hidden\n */\n\n\nvar TypeFlags;\n\n(function (TypeFlags) {\n  TypeFlags[TypeFlags[\"String\"] = 1] = \"String\";\n  TypeFlags[TypeFlags[\"Number\"] = 2] = \"Number\";\n  TypeFlags[TypeFlags[\"Boolean\"] = 4] = \"Boolean\";\n  TypeFlags[TypeFlags[\"Date\"] = 8] = \"Date\";\n  TypeFlags[TypeFlags[\"Literal\"] = 16] = \"Literal\";\n  TypeFlags[TypeFlags[\"Array\"] = 32] = \"Array\";\n  TypeFlags[TypeFlags[\"Map\"] = 64] = \"Map\";\n  TypeFlags[TypeFlags[\"Object\"] = 128] = \"Object\";\n  TypeFlags[TypeFlags[\"Frozen\"] = 256] = \"Frozen\";\n  TypeFlags[TypeFlags[\"Optional\"] = 512] = \"Optional\";\n  TypeFlags[TypeFlags[\"Reference\"] = 1024] = \"Reference\";\n  TypeFlags[TypeFlags[\"Identifier\"] = 2048] = \"Identifier\";\n  TypeFlags[TypeFlags[\"Late\"] = 4096] = \"Late\";\n  TypeFlags[TypeFlags[\"Refinement\"] = 8192] = \"Refinement\";\n  TypeFlags[TypeFlags[\"Union\"] = 16384] = \"Union\";\n  TypeFlags[TypeFlags[\"Null\"] = 32768] = \"Null\";\n  TypeFlags[TypeFlags[\"Undefined\"] = 65536] = \"Undefined\";\n  TypeFlags[TypeFlags[\"Integer\"] = 131072] = \"Integer\";\n  TypeFlags[TypeFlags[\"Custom\"] = 262144] = \"Custom\";\n  TypeFlags[TypeFlags[\"SnapshotProcessor\"] = 524288] = \"SnapshotProcessor\";\n})(TypeFlags || (TypeFlags = {}));\n/**\n * @internal\n * @hidden\n */\n\n\nvar cannotDetermineSubtype = \"cannotDetermine\";\n/**\n * A base type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\n\nvar BaseType =\n/** @class */\nfunction () {\n  function BaseType(name) {\n    this.isType = true;\n    this.name = name;\n  }\n\n  BaseType.prototype.create = function (snapshot, environment) {\n    typecheckInternal(this, snapshot);\n    return this.instantiate(null, \"\", environment, snapshot).value;\n  };\n\n  BaseType.prototype.getSnapshot = function (node, applyPostProcess) {\n    // istanbul ignore next\n    throw fail$1(\"unimplemented method\");\n  };\n\n  BaseType.prototype.isAssignableFrom = function (type) {\n    return type === this;\n  };\n\n  BaseType.prototype.validate = function (value, context) {\n    var node = getStateTreeNodeSafe(value);\n\n    if (node) {\n      var valueType = getType(value);\n      return this.isAssignableFrom(valueType) ? typeCheckSuccess() : typeCheckFailure(context, value); // it is tempting to compare snapshots, but in that case we should always clone on assignments...\n    }\n\n    return this.isValidSnapshot(value, context);\n  };\n\n  BaseType.prototype.is = function (thing) {\n    return this.validate(thing, [{\n      path: \"\",\n      type: this\n    }]).length === 0;\n  };\n\n  Object.defineProperty(BaseType.prototype, \"Type\", {\n    get: function () {\n      // istanbul ignore next\n      throw fail$1(\"Factory.Type should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.Type`\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseType.prototype, \"TypeWithoutSTN\", {\n    get: function () {\n      // istanbul ignore next\n      throw fail$1(\"Factory.TypeWithoutSTN should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.TypeWithoutSTN`\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseType.prototype, \"SnapshotType\", {\n    get: function () {\n      // istanbul ignore next\n      throw fail$1(\"Factory.SnapshotType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.SnapshotType`\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseType.prototype, \"CreationType\", {\n    get: function () {\n      // istanbul ignore next\n      throw fail$1(\"Factory.CreationType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.CreationType`\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([action], BaseType.prototype, \"create\", null);\n\n  return BaseType;\n}();\n/**\n * A complex type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\n\n\nvar ComplexType =\n/** @class */\nfunction (_super) {\n  __extends(ComplexType, _super);\n\n  function ComplexType(name) {\n    return _super.call(this, name) || this;\n  }\n\n  ComplexType.prototype.create = function (snapshot, environment) {\n    if (snapshot === void 0) {\n      snapshot = this.getDefaultSnapshot();\n    }\n\n    return _super.prototype.create.call(this, snapshot, environment);\n  };\n\n  ComplexType.prototype.getValue = function (node) {\n    node.createObservableInstanceIfNeeded();\n    return node.storedValue;\n  };\n\n  ComplexType.prototype.tryToReconcileNode = function (current, newValue) {\n    if (current.isDetaching) return false;\n\n    if (current.snapshot === newValue) {\n      // newValue is the current snapshot of the node, noop\n      return true;\n    }\n\n    if (isStateTreeNode(newValue) && getStateTreeNode(newValue) === current) {\n      // the current node is the same as the new one\n      return true;\n    }\n\n    if (current.type === this && isMutable(newValue) && !isStateTreeNode(newValue) && (!current.identifierAttribute || current.identifier === normalizeIdentifier(newValue[current.identifierAttribute]))) {\n      // the newValue has no node, so can be treated like a snapshot\n      // we can reconcile\n      current.applySnapshot(newValue);\n      return true;\n    }\n\n    return false;\n  };\n\n  ComplexType.prototype.reconcile = function (current, newValue, parent, subpath) {\n    var nodeReconciled = this.tryToReconcileNode(current, newValue);\n\n    if (nodeReconciled) {\n      current.setParent(parent, subpath);\n      return current;\n    } // current node cannot be recycled in any way\n\n\n    current.die(); // noop if detaching\n    // attempt to reuse the new one\n\n    if (isStateTreeNode(newValue) && this.isAssignableFrom(getType(newValue))) {\n      // newValue is a Node as well, move it here..\n      var newNode = getStateTreeNode(newValue);\n      newNode.setParent(parent, subpath);\n      return newNode;\n    } // nothing to do, we have to create a new node\n\n\n    return this.instantiate(parent, subpath, undefined, newValue);\n  };\n\n  ComplexType.prototype.getSubTypes = function () {\n    return null;\n  };\n\n  __decorate([action], ComplexType.prototype, \"create\", null);\n\n  return ComplexType;\n}(BaseType);\n/**\n * @internal\n * @hidden\n */\n\n\nvar SimpleType =\n/** @class */\nfunction (_super) {\n  __extends(SimpleType, _super);\n\n  function SimpleType() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SimpleType.prototype.createNewInstance = function (snapshot) {\n    return snapshot;\n  };\n\n  SimpleType.prototype.getValue = function (node) {\n    // if we ever find a case where scalar nodes can be accessed without iterating through its parent\n    // uncomment this to make sure the parent chain is created when this is accessed\n    // if (node.parent) {\n    //     node.parent.createObservableInstanceIfNeeded()\n    // }\n    return node.storedValue;\n  };\n\n  SimpleType.prototype.getSnapshot = function (node) {\n    return node.storedValue;\n  };\n\n  SimpleType.prototype.reconcile = function (current, newValue, parent, subpath) {\n    // reconcile only if type and value are still the same, and only if the node is not detaching\n    if (!current.isDetaching && current.type === this && current.storedValue === newValue) {\n      return current;\n    }\n\n    var res = this.instantiate(parent, subpath, undefined, newValue);\n    current.die(); // noop if detaching\n\n    return res;\n  };\n\n  SimpleType.prototype.getSubTypes = function () {\n    return null;\n  };\n\n  return SimpleType;\n}(BaseType);\n/**\n * Returns if a given value represents a type.\n *\n * @param value Value to check.\n * @returns `true` if the value is a type.\n */\n\n\nfunction isType(value) {\n  return typeof value === \"object\" && value && value.isType === true;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction assertIsType(type, argNumber) {\n  assertArg(type, isType, \"mobx-state-tree type\", argNumber);\n}\n\nvar runningActions = new Map();\n/**\n * Note: Consider migrating to `createActionTrackingMiddleware2`, it is easier to use.\n *\n * Convenience utility to create action based middleware that supports async processes more easily.\n * All hooks are called for both synchronous and asynchronous actions. Except that either `onSuccess` or `onFail` is called\n *\n * The create middleware tracks the process of an action (assuming it passes the `filter`).\n * `onResume` can return any value, which will be passed as second argument to any other hook. This makes it possible to keep state during a process.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\n\nfunction createActionTrackingMiddleware(hooks) {\n  return function actionTrackingMiddleware(call, next, abort) {\n    switch (call.type) {\n      case \"action\":\n        {\n          if (!hooks.filter || hooks.filter(call) === true) {\n            var context = hooks.onStart(call);\n            hooks.onResume(call, context);\n            runningActions.set(call.id, {\n              call: call,\n              context: context,\n              async: false\n            });\n\n            try {\n              var res = next(call);\n              hooks.onSuspend(call, context);\n\n              if (runningActions.get(call.id).async === false) {\n                runningActions.delete(call.id);\n                hooks.onSuccess(call, context, res);\n              }\n\n              return res;\n            } catch (e) {\n              runningActions.delete(call.id);\n              hooks.onFail(call, context, e);\n              throw e;\n            }\n          } else {\n            return next(call);\n          }\n        }\n\n      case \"flow_spawn\":\n        {\n          var root = runningActions.get(call.rootId);\n          root.async = true;\n          return next(call);\n        }\n\n      case \"flow_resume\":\n      case \"flow_resume_error\":\n        {\n          var root = runningActions.get(call.rootId);\n          hooks.onResume(call, root.context);\n\n          try {\n            return next(call);\n          } finally {\n            hooks.onSuspend(call, root.context);\n          }\n        }\n\n      case \"flow_throw\":\n        {\n          var root = runningActions.get(call.rootId);\n          runningActions.delete(call.rootId);\n          hooks.onFail(call, root.context, call.args[0]);\n          return next(call);\n        }\n\n      case \"flow_return\":\n        {\n          var root = runningActions.get(call.rootId);\n          runningActions.delete(call.rootId);\n          hooks.onSuccess(call, root.context, call.args[0]);\n          return next(call);\n        }\n    }\n  };\n}\n\nvar RunningAction =\n/** @class */\nfunction () {\n  function RunningAction(hooks, call) {\n    this.hooks = hooks;\n    this.call = call;\n    this.flowsPending = 0;\n    this.running = true;\n\n    if (hooks) {\n      hooks.onStart(call);\n    }\n  }\n\n  RunningAction.prototype.finish = function (error) {\n    if (this.running) {\n      this.running = false;\n\n      if (this.hooks) {\n        this.hooks.onFinish(this.call, error);\n      }\n    }\n  };\n\n  RunningAction.prototype.incFlowsPending = function () {\n    this.flowsPending++;\n  };\n\n  RunningAction.prototype.decFlowsPending = function () {\n    this.flowsPending--;\n  };\n\n  Object.defineProperty(RunningAction.prototype, \"hasFlowsPending\", {\n    get: function () {\n      return this.flowsPending > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return RunningAction;\n}();\n/**\n * Convenience utility to create action based middleware that supports async processes more easily.\n * The flow is like this:\n * - for each action: if filter passes -> `onStart` -> (inner actions recursively) -> `onFinish`\n *\n * Example: if we had an action `a` that called inside an action `b1`, then `b2` the flow would be:\n * - `filter(a)`\n * - `onStart(a)`\n *   - `filter(b1)`\n *   - `onStart(b1)`\n *   - `onFinish(b1)`\n *   - `filter(b2)`\n *   - `onStart(b2)`\n *   - `onFinish(b2)`\n * - `onFinish(a)`\n *\n * The flow is the same no matter if the actions are sync or async.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\n\n\nfunction createActionTrackingMiddleware2(middlewareHooks) {\n  var runningActions = new WeakMap();\n  return function actionTrackingMiddleware(call, next) {\n    // find parentRunningAction\n    var parentRunningAction = call.parentActionEvent ? runningActions.get(call.parentActionEvent) : undefined;\n\n    if (call.type === \"action\") {\n      var newCall = __assign(__assign({}, call), {\n        // make a shallow copy of the parent action env\n        env: parentRunningAction && parentRunningAction.call.env,\n        parentCall: parentRunningAction && parentRunningAction.call\n      });\n\n      var passesFilter = !middlewareHooks.filter || middlewareHooks.filter(newCall);\n      var hooks = passesFilter ? middlewareHooks : undefined;\n      var runningAction = new RunningAction(hooks, newCall);\n      runningActions.set(call, runningAction);\n      var res = void 0;\n\n      try {\n        res = next(call);\n      } catch (e) {\n        runningAction.finish(e);\n        throw e;\n      }\n\n      if (!runningAction.hasFlowsPending) {\n        // sync action finished\n        runningAction.finish();\n      }\n\n      return res;\n    } else {\n      if (!parentRunningAction) {\n        return next(call);\n      }\n\n      switch (call.type) {\n        case \"flow_spawn\":\n          {\n            parentRunningAction.incFlowsPending();\n            return next(call);\n          }\n\n        case \"flow_resume\":\n        case \"flow_resume_error\":\n          {\n            return next(call);\n          }\n\n        case \"flow_throw\":\n          {\n            var error = call.args[0];\n\n            try {\n              return next(call);\n            } finally {\n              parentRunningAction.decFlowsPending();\n\n              if (!parentRunningAction.hasFlowsPending) {\n                parentRunningAction.finish(error);\n              }\n            }\n          }\n\n        case \"flow_return\":\n          {\n            try {\n              return next(call);\n            } finally {\n              parentRunningAction.decFlowsPending();\n\n              if (!parentRunningAction.hasFlowsPending) {\n                parentRunningAction.finish();\n              }\n            }\n          }\n      }\n    }\n  };\n}\n\nfunction serializeArgument(node, actionName, index, arg) {\n  if (arg instanceof Date) return {\n    $MST_DATE: arg.getTime()\n  };\n  if (isPrimitive(arg)) return arg; // We should not serialize MST nodes, even if we can, because we don't know if the receiving party can handle a raw snapshot instead of an\n  // MST type instance. So if one wants to serialize a MST node that was pass in, either explitly pass: 1: an id, 2: a (relative) path, 3: a snapshot\n\n  if (isStateTreeNode(arg)) return serializeTheUnserializable(\"[MSTNode: \" + getType(arg).name + \"]\");\n  if (typeof arg === \"function\") return serializeTheUnserializable(\"[function]\");\n  if (typeof arg === \"object\" && !isPlainObject(arg) && !isArray(arg)) return serializeTheUnserializable(\"[object \" + (arg && arg.constructor && arg.constructor.name || \"Complex Object\") + \"]\");\n\n  try {\n    // Check if serializable, cycle free etc...\n    // MWE: there must be a better way....\n    JSON.stringify(arg); // or throws\n\n    return arg;\n  } catch (e) {\n    return serializeTheUnserializable(\"\" + e);\n  }\n}\n\nfunction deserializeArgument(adm, value) {\n  if (value && typeof value === \"object\" && \"$MST_DATE\" in value) return new Date(value[\"$MST_DATE\"]);\n  return value;\n}\n\nfunction serializeTheUnserializable(baseType) {\n  return {\n    $MST_UNSERIALIZABLE: true,\n    type: baseType\n  };\n}\n/**\n * Applies an action or a series of actions in a single MobX transaction.\n * Does not return any value\n * Takes an action description as produced by the `onAction` middleware.\n *\n * @param target\n * @param actions\n */\n\n\nfunction applyAction(target, actions) {\n  // check all arguments\n  assertIsStateTreeNode(target, 1);\n  assertArg(actions, function (a) {\n    return typeof a === \"object\";\n  }, \"object or array\", 2);\n  runInAction(function () {\n    asArray(actions).forEach(function (action) {\n      return baseApplyAction(target, action);\n    });\n  });\n}\n\nfunction baseApplyAction(target, action) {\n  var resolvedTarget = tryResolve(target, action.path || \"\");\n  if (!resolvedTarget) throw fail$1(\"Invalid action path: \" + (action.path || \"\"));\n  var node = getStateTreeNode(resolvedTarget); // Reserved functions\n\n  if (action.name === \"@APPLY_PATCHES\") {\n    return applyPatch.call(null, resolvedTarget, action.args[0]);\n  }\n\n  if (action.name === \"@APPLY_SNAPSHOT\") {\n    return applySnapshot.call(null, resolvedTarget, action.args[0]);\n  }\n\n  if (!(typeof resolvedTarget[action.name] === \"function\")) throw fail$1(\"Action '\" + action.name + \"' does not exist in '\" + node.path + \"'\");\n  return resolvedTarget[action.name].apply(resolvedTarget, action.args ? action.args.map(function (v) {\n    return deserializeArgument(node, v);\n  }) : []);\n}\n/**\n * Small abstraction around `onAction` and `applyAction`, attaches an action listener to a tree and records all the actions emitted.\n * Returns an recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IActionRecorder {\n *      // the recorded actions\n *      actions: ISerializedActionCall[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording actions\n *      stop(): void\n *      // resume recording actions\n *      resume(): void\n *      // apply all the recorded actions on the given object\n *      replay(target: IAnyStateTreeNode): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain actions.\n *\n * @param subject\n * @returns\n */\n\n\nfunction recordActions(subject, filter) {\n  // check all arguments\n  assertIsStateTreeNode(subject, 1);\n  var actions = [];\n\n  var listener = function (call) {\n    var recordThis = filter ? filter(call, getRunningActionContext()) : true;\n\n    if (recordThis) {\n      actions.push(call);\n    }\n  };\n\n  var disposer;\n  var recorder = {\n    actions: actions,\n\n    get recording() {\n      return !!disposer;\n    },\n\n    stop: function () {\n      if (disposer) {\n        disposer();\n        disposer = undefined;\n      }\n    },\n    resume: function () {\n      if (disposer) return;\n      disposer = onAction(subject, listener);\n    },\n    replay: function (target) {\n      applyAction(target, actions);\n    }\n  };\n  recorder.resume();\n  return recorder;\n}\n/**\n * Registers a function that will be invoked for each action that is called on the provided model instance, or to any of its children.\n * See [actions](https://github.com/mobxjs/mobx-state-tree#actions) for more details. onAction events are emitted only for the outermost called action in the stack.\n * Action can also be intercepted by middleware using addMiddleware to change the function call before it will be run.\n *\n * Not all action arguments might be serializable. For unserializable arguments, a struct like `{ $MST_UNSERIALIZABLE: true, type: \"someType\" }` will be generated.\n * MST Nodes are considered non-serializable as well (they could be serialized as there snapshot, but it is uncertain whether an replaying party will be able to handle such a non-instantiated snapshot).\n * Rather, when using `onAction` middleware, one should consider in passing arguments which are 1: an id, 2: a (relative) path, or 3: a snapshot. Instead of a real MST node.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * }).actions(self => ({\n *   add(todo) {\n *     self.todos.push(todo);\n *   }\n * }))\n *\n * const s = TodoStore.create({ todos: [] })\n *\n * let disposer = onAction(s, (call) => {\n *   console.log(call);\n * })\n *\n * s.add({ task: \"Grab a coffee\" })\n * // Logs: { name: \"add\", path: \"\", args: [{ task: \"Grab a coffee\" }] }\n * ```\n *\n * @param target\n * @param listener\n * @param attachAfter (default false) fires the listener *after* the action has executed instead of before.\n * @returns\n */\n\n\nfunction onAction(target, listener, attachAfter) {\n  if (attachAfter === void 0) {\n    attachAfter = false;\n  } // check all arguments\n\n\n  assertIsStateTreeNode(target, 1);\n\n  if (devMode()) {\n    if (!isRoot(target)) warnError(\"Warning: Attaching onAction listeners to non root nodes is dangerous: No events will be emitted for actions initiated higher up in the tree.\");\n    if (!isProtected(target)) warnError(\"Warning: Attaching onAction listeners to non protected nodes is dangerous: No events will be emitted for direct modifications without action.\");\n  }\n\n  return addMiddleware(target, function handler(rawCall, next) {\n    if (rawCall.type === \"action\" && rawCall.id === rawCall.rootId) {\n      var sourceNode_1 = getStateTreeNode(rawCall.context);\n      var info = {\n        name: rawCall.name,\n        path: getRelativePathBetweenNodes(getStateTreeNode(target), sourceNode_1),\n        args: rawCall.args.map(function (arg, index) {\n          return serializeArgument(sourceNode_1, rawCall.name, index, arg);\n        })\n      };\n\n      if (attachAfter) {\n        var res = next(rawCall);\n        listener(info);\n        return res;\n      } else {\n        listener(info);\n        return next(rawCall);\n      }\n    } else {\n      return next(rawCall);\n    }\n  });\n}\n\nvar nextActionId = 1;\nvar currentActionContext;\n/**\n * @internal\n * @hidden\n */\n\nfunction getCurrentActionContext() {\n  return currentActionContext;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction getNextActionId() {\n  return nextActionId++;\n} // TODO: optimize away entire action context if there is no middleware in tree?\n\n/**\n * @internal\n * @hidden\n */\n\n\nfunction runWithActionContext(context, fn) {\n  var node = getStateTreeNode(context.context);\n\n  if (context.type === \"action\") {\n    node.assertAlive({\n      actionContext: context\n    });\n  }\n\n  var baseIsRunningAction = node._isRunningAction;\n  node._isRunningAction = true;\n  var previousContext = currentActionContext;\n  currentActionContext = context;\n\n  try {\n    return runMiddleWares(node, context, fn);\n  } finally {\n    currentActionContext = previousContext;\n    node._isRunningAction = baseIsRunningAction;\n  }\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction getParentActionContext(parentContext) {\n  if (!parentContext) return undefined;\n  if (parentContext.type === \"action\") return parentContext;\n  return parentContext.parentActionEvent;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction createActionInvoker(target, name, fn) {\n  var res = function () {\n    var id = getNextActionId();\n    var parentContext = currentActionContext;\n    var parentActionContext = getParentActionContext(parentContext);\n    return runWithActionContext({\n      type: \"action\",\n      name: name,\n      id: id,\n      args: argsToArray(arguments),\n      context: target,\n      tree: getRoot(target),\n      rootId: parentContext ? parentContext.rootId : id,\n      parentId: parentContext ? parentContext.id : 0,\n      allParentIds: parentContext ? __spread(parentContext.allParentIds, [parentContext.id]) : [],\n      parentEvent: parentContext,\n      parentActionEvent: parentActionContext\n    }, fn);\n  };\n\n  res._isMSTAction = true;\n  return res;\n}\n/**\n * Middleware can be used to intercept any action is invoked on the subtree where it is attached.\n * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.\n *\n * For more details, see the [middleware docs](concepts/middleware.md)\n *\n * @param target Node to apply the middleware to.\n * @param middleware Middleware to apply.\n * @returns A callable function to dispose the middleware.\n */\n\n\nfunction addMiddleware(target, handler, includeHooks) {\n  if (includeHooks === void 0) {\n    includeHooks = true;\n  }\n\n  var node = getStateTreeNode(target);\n\n  if (devMode()) {\n    if (!node.isProtectionEnabled) {\n      warnError(\"It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`\");\n    }\n  }\n\n  return node.addMiddleWare(handler, includeHooks);\n}\n/**\n * Binds middleware to a specific action.\n *\n * Example:\n * ```ts\n * type.actions(self => {\n *   function takeA____() {\n *       self.toilet.donate()\n *       self.wipe()\n *       self.wipe()\n *       self.toilet.flush()\n *   }\n *   return {\n *     takeA____: decorate(atomic, takeA____)\n *   }\n * })\n * ```\n *\n * @param handler\n * @param fn\n * @param includeHooks\n * @returns The original function\n */\n\n\nfunction decorate(handler, fn, includeHooks) {\n  if (includeHooks === void 0) {\n    includeHooks = true;\n  }\n\n  var middleware = {\n    handler: handler,\n    includeHooks: includeHooks\n  };\n  fn.$mst_middleware = fn.$mst_middleware || [];\n  fn.$mst_middleware.push(middleware);\n  return fn;\n}\n\nvar CollectedMiddlewares =\n/** @class */\nfunction () {\n  function CollectedMiddlewares(node, fn) {\n    this.arrayIndex = 0;\n    this.inArrayIndex = 0;\n    this.middlewares = []; // we just push middleware arrays into an array of arrays to avoid making copies\n\n    if (fn.$mst_middleware) {\n      this.middlewares.push(fn.$mst_middleware);\n    }\n\n    var n = node; // Find all middlewares. Optimization: cache this?\n\n    while (n) {\n      if (n.middlewares) this.middlewares.push(n.middlewares);\n      n = n.parent;\n    }\n  }\n\n  Object.defineProperty(CollectedMiddlewares.prototype, \"isEmpty\", {\n    get: function () {\n      return this.middlewares.length <= 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CollectedMiddlewares.prototype.getNextMiddleware = function () {\n    var array = this.middlewares[this.arrayIndex];\n    if (!array) return undefined;\n    var item = array[this.inArrayIndex++];\n\n    if (!item) {\n      this.arrayIndex++;\n      this.inArrayIndex = 0;\n      return this.getNextMiddleware();\n    }\n\n    return item;\n  };\n\n  return CollectedMiddlewares;\n}();\n\nfunction runMiddleWares(node, baseCall, originalFn) {\n  var middlewares = new CollectedMiddlewares(node, originalFn); // Short circuit\n\n  if (middlewares.isEmpty) return action(originalFn).apply(null, baseCall.args);\n  var result = null;\n\n  function runNextMiddleware(call) {\n    var middleware = middlewares.getNextMiddleware();\n    var handler = middleware && middleware.handler;\n\n    if (!handler) {\n      return action(originalFn).apply(null, call.args);\n    } // skip hooks if asked to\n\n\n    if (!middleware.includeHooks && Hook[call.name]) {\n      return runNextMiddleware(call);\n    }\n\n    var nextInvoked = false;\n\n    function next(call2, callback) {\n      nextInvoked = true; // the result can contain\n      // - the non manipulated return value from an action\n      // - the non manipulated abort value\n      // - one of the above but manipulated through the callback function\n\n      result = runNextMiddleware(call2);\n\n      if (callback) {\n        result = callback(result);\n      }\n    }\n\n    var abortInvoked = false;\n\n    function abort(value) {\n      abortInvoked = true; // overwrite the result\n      // can be manipulated through middlewares earlier in the queue using the callback fn\n\n      result = value;\n    }\n\n    handler(call, next, abort);\n\n    if (devMode()) {\n      if (!nextInvoked && !abortInvoked) {\n        var node2 = getStateTreeNode(call.tree);\n        throw fail$1(\"Neither the next() nor the abort() callback within the middleware \" + handler.name + \" for the action: \\\"\" + call.name + \"\\\" on the node: \" + node2.type.name + \" was invoked.\");\n      } else if (nextInvoked && abortInvoked) {\n        var node2 = getStateTreeNode(call.tree);\n        throw fail$1(\"The next() and abort() callback within the middleware \" + handler.name + \" for the action: \\\"\" + call.name + \"\\\" on the node: \" + node2.type.name + \" were invoked.\");\n      }\n    }\n\n    return result;\n  }\n\n  return runNextMiddleware(baseCall);\n}\n/**\n * Returns the currently executing MST action context, or undefined if none.\n */\n\n\nfunction getRunningActionContext() {\n  var current = getCurrentActionContext();\n\n  while (current && current.type !== \"action\") {\n    current = current.parentActionEvent;\n  }\n\n  return current;\n}\n\nfunction _isActionContextThisOrChildOf(actionContext, sameOrParent, includeSame) {\n  var parentId = typeof sameOrParent === \"number\" ? sameOrParent : sameOrParent.id;\n  var current = includeSame ? actionContext : actionContext.parentActionEvent;\n\n  while (current) {\n    if (current.id === parentId) {\n      return true;\n    }\n\n    current = current.parentActionEvent;\n  }\n\n  return false;\n}\n/**\n * Returns if the given action context is a parent of this action context.\n */\n\n\nfunction isActionContextChildOf(actionContext, parent) {\n  return _isActionContextThisOrChildOf(actionContext, parent, false);\n}\n/**\n * Returns if the given action context is this or a parent of this action context.\n */\n\n\nfunction isActionContextThisOrChildOf(actionContext, parentOrThis) {\n  return _isActionContextThisOrChildOf(actionContext, parentOrThis, true);\n}\n\nfunction safeStringify(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (e) {\n    // istanbul ignore next\n    return \"<Unserializable: \" + e + \">\";\n  }\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction prettyPrintValue(value) {\n  return typeof value === \"function\" ? \"<function\" + (value.name ? \" \" + value.name : \"\") + \">\" : isStateTreeNode(value) ? \"<\" + value + \">\" : \"`\" + safeStringify(value) + \"`\";\n}\n\nfunction shortenPrintValue(valueInString) {\n  return valueInString.length < 280 ? valueInString : valueInString.substring(0, 272) + \"......\" + valueInString.substring(valueInString.length - 8);\n}\n\nfunction toErrorString(error) {\n  var value = error.value;\n  var type = error.context[error.context.length - 1].type;\n  var fullPath = error.context.map(function (_a) {\n    var path = _a.path;\n    return path;\n  }).filter(function (path) {\n    return path.length > 0;\n  }).join(\"/\");\n  var pathPrefix = fullPath.length > 0 ? \"at path \\\"/\" + fullPath + \"\\\" \" : \"\";\n  var currentTypename = isStateTreeNode(value) ? \"value of type \" + getStateTreeNode(value).type.name + \":\" : isPrimitive(value) ? \"value\" : \"snapshot\";\n  var isSnapshotCompatible = type && isStateTreeNode(value) && type.is(getStateTreeNode(value).snapshot);\n  return \"\" + pathPrefix + currentTypename + \" \" + prettyPrintValue(value) + \" is not assignable \" + (type ? \"to type: `\" + type.name + \"`\" : \"\") + (error.message ? \" (\" + error.message + \")\" : \"\") + (type ? isPrimitiveType(type) || isPrimitive(value) ? \".\" : \", expected an instance of `\" + type.name + \"` or a snapshot like `\" + type.describe() + \"` instead.\" + (isSnapshotCompatible ? \" (Note that a snapshot of the provided value is compatible with the targeted type)\" : \"\") : \".\");\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction getContextForPath(context, path, type) {\n  return context.concat([{\n    path: path,\n    type: type\n  }]);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction typeCheckSuccess() {\n  return EMPTY_ARRAY;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction typeCheckFailure(context, value, message) {\n  return [{\n    context: context,\n    value: value,\n    message: message\n  }];\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction flattenTypeErrors(errors) {\n  return errors.reduce(function (a, i) {\n    return a.concat(i);\n  }, []);\n} // TODO; doublecheck: typecheck should only needed to be invoked from: type.create and array / map / value.property will change\n\n/**\n * @internal\n * @hidden\n */\n\n\nfunction typecheckInternal(type, value) {\n  // runs typeChecking if it is in dev-mode or through a process.env.ENABLE_TYPE_CHECK flag\n  if (isTypeCheckingEnabled()) {\n    typecheck(type, value);\n  }\n}\n/**\n * Run's the typechecker for the given type on the given value, which can be a snapshot or an instance.\n * Throws if the given value is not according the provided type specification.\n * Use this if you need typechecks even in a production build (by default all automatic runtime type checks will be skipped in production builds)\n *\n * @param type Type to check against.\n * @param value Value to be checked, either a snapshot or an instance.\n */\n\n\nfunction typecheck(type, value) {\n  var errors = type.validate(value, [{\n    path: \"\",\n    type: type\n  }]);\n\n  if (errors.length > 0) {\n    throw fail$1(validationErrorsToString(type, value, errors));\n  }\n}\n\nfunction validationErrorsToString(type, value, errors) {\n  if (errors.length === 0) {\n    return undefined;\n  }\n\n  return \"Error while converting \" + shortenPrintValue(prettyPrintValue(value)) + \" to `\" + type.name + \"`:\\n\\n    \" + errors.map(toErrorString).join(\"\\n    \");\n}\n\nvar identifierCacheId = 0;\n/**\n * @internal\n * @hidden\n */\n\nvar IdentifierCache =\n/** @class */\nfunction () {\n  function IdentifierCache() {\n    this.cacheId = identifierCacheId++; // n.b. in cache all identifiers are normalized to strings\n\n    this.cache = observable.map(); // last time the cache (array) for a given time changed\n    // n.b. it is not really the time, but just an integer that gets increased after each modification to the array\n\n    this.lastCacheModificationPerId = observable.map();\n  }\n\n  IdentifierCache.prototype.updateLastCacheModificationPerId = function (identifier) {\n    var lcm = this.lastCacheModificationPerId.get(identifier); // we start at 1 since 0 means no update since cache creation\n\n    this.lastCacheModificationPerId.set(identifier, lcm === undefined ? 1 : lcm + 1);\n  };\n\n  IdentifierCache.prototype.getLastCacheModificationPerId = function (identifier) {\n    var modificationId = this.lastCacheModificationPerId.get(identifier) || 0;\n    return this.cacheId + \"-\" + modificationId;\n  };\n\n  IdentifierCache.prototype.addNodeToCache = function (node, lastCacheUpdate) {\n    if (lastCacheUpdate === void 0) {\n      lastCacheUpdate = true;\n    }\n\n    if (node.identifierAttribute) {\n      var identifier = node.identifier;\n\n      if (!this.cache.has(identifier)) {\n        this.cache.set(identifier, observable.array([], mobxShallow));\n      }\n\n      var set = this.cache.get(identifier);\n      if (set.indexOf(node) !== -1) throw fail$1(\"Already registered\");\n      set.push(node);\n\n      if (lastCacheUpdate) {\n        this.updateLastCacheModificationPerId(identifier);\n      }\n    }\n  };\n\n  IdentifierCache.prototype.mergeCache = function (node) {\n    var _this = this;\n\n    values(node.identifierCache.cache).forEach(function (nodes) {\n      return nodes.forEach(function (child) {\n        _this.addNodeToCache(child);\n      });\n    });\n  };\n\n  IdentifierCache.prototype.notifyDied = function (node) {\n    if (node.identifierAttribute) {\n      var id = node.identifier;\n      var set = this.cache.get(id);\n\n      if (set) {\n        set.remove(node); // remove empty sets from cache\n\n        if (!set.length) {\n          this.cache.delete(id);\n        }\n\n        this.updateLastCacheModificationPerId(node.identifier);\n      }\n    }\n  };\n\n  IdentifierCache.prototype.splitCache = function (node) {\n    var _this = this;\n\n    var res = new IdentifierCache();\n    var basePath = node.path;\n    entries(this.cache).forEach(function (_a) {\n      var _b = __read(_a, 2),\n          id = _b[0],\n          nodes = _b[1];\n\n      var modified = false;\n\n      for (var i = nodes.length - 1; i >= 0; i--) {\n        if (nodes[i].path.indexOf(basePath) === 0) {\n          res.addNodeToCache(nodes[i], false); // no need to update lastUpdated since it is a whole new cache\n\n          nodes.splice(i, 1);\n          modified = true;\n        }\n      }\n\n      if (modified) {\n        _this.updateLastCacheModificationPerId(id);\n      }\n    });\n    return res;\n  };\n\n  IdentifierCache.prototype.has = function (type, identifier) {\n    var set = this.cache.get(identifier);\n    if (!set) return false;\n    return set.some(function (candidate) {\n      return type.isAssignableFrom(candidate.type);\n    });\n  };\n\n  IdentifierCache.prototype.resolve = function (type, identifier) {\n    var set = this.cache.get(identifier);\n    if (!set) return null;\n    var matches = set.filter(function (candidate) {\n      return type.isAssignableFrom(candidate.type);\n    });\n\n    switch (matches.length) {\n      case 0:\n        return null;\n\n      case 1:\n        return matches[0];\n\n      default:\n        throw fail$1(\"Cannot resolve a reference to type '\" + type.name + \"' with id: '\" + identifier + \"' unambigously, there are multiple candidates: \" + matches.map(function (n) {\n          return n.path;\n        }).join(\", \"));\n    }\n  };\n\n  return IdentifierCache;\n}();\n/**\n * @internal\n * @hidden\n */\n\n\nfunction createObjectNode(type, parent, subpath, environment, initialValue) {\n  var existingNode = getStateTreeNodeSafe(initialValue);\n\n  if (existingNode) {\n    if (existingNode.parent) {\n      // istanbul ignore next\n      throw fail$1(\"Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '\" + (parent ? parent.path : \"\") + \"/\" + subpath + \"', but it lives already at '\" + existingNode.path + \"'\");\n    }\n\n    if (parent) {\n      existingNode.setParent(parent, subpath);\n    } // else it already has no parent since it is a pre-requisite\n\n\n    return existingNode;\n  } // not a node, a snapshot\n\n\n  return new ObjectNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction createScalarNode(type, parent, subpath, environment, initialValue) {\n  return new ScalarNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction isNode(value) {\n  return value instanceof ScalarNode || value instanceof ObjectNode;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar NodeLifeCycle;\n\n(function (NodeLifeCycle) {\n  NodeLifeCycle[NodeLifeCycle[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n  NodeLifeCycle[NodeLifeCycle[\"CREATED\"] = 1] = \"CREATED\";\n  NodeLifeCycle[NodeLifeCycle[\"FINALIZED\"] = 2] = \"FINALIZED\";\n  NodeLifeCycle[NodeLifeCycle[\"DETACHING\"] = 3] = \"DETACHING\";\n  NodeLifeCycle[NodeLifeCycle[\"DEAD\"] = 4] = \"DEAD\"; // no coming back from this one\n})(NodeLifeCycle || (NodeLifeCycle = {}));\n/**\n * Returns true if the given value is a node in a state tree.\n * More precisely, that is, if the value is an instance of a\n * `types.model`, `types.array` or `types.map`.\n *\n * @param value\n * @returns true if the value is a state tree node.\n */\n\n\nfunction isStateTreeNode(value) {\n  return !!(value && value.$treenode);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction assertIsStateTreeNode(value, argNumber) {\n  assertArg(value, isStateTreeNode, \"mobx-state-tree node\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction getStateTreeNode(value) {\n  if (!isStateTreeNode(value)) {\n    // istanbul ignore next\n    throw fail$1(\"Value \" + value + \" is no MST Node\");\n  }\n\n  return value.$treenode;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction getStateTreeNodeSafe(value) {\n  return value && value.$treenode || null;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction toJSON() {\n  return getStateTreeNode(this).snapshot;\n}\n\nvar doubleDot = function (_) {\n  return \"..\";\n};\n/**\n * @internal\n * @hidden\n */\n\n\nfunction getRelativePathBetweenNodes(base, target) {\n  // PRE condition target is (a child of) base!\n  if (base.root !== target.root) {\n    throw fail$1(\"Cannot calculate relative path: objects '\" + base + \"' and '\" + target + \"' are not part of the same object tree\");\n  }\n\n  var baseParts = splitJsonPath(base.path);\n  var targetParts = splitJsonPath(target.path);\n  var common = 0;\n\n  for (; common < baseParts.length; common++) {\n    if (baseParts[common] !== targetParts[common]) break;\n  } // TODO: assert that no targetParts paths are \"..\", \".\" or \"\"!\n\n\n  return baseParts.slice(common).map(doubleDot).join(\"/\") + joinJsonPath(targetParts.slice(common));\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction resolveNodeByPath(base, path, failIfResolveFails) {\n  if (failIfResolveFails === void 0) {\n    failIfResolveFails = true;\n  }\n\n  return resolveNodeByPathParts(base, splitJsonPath(path), failIfResolveFails);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction resolveNodeByPathParts(base, pathParts, failIfResolveFails) {\n  if (failIfResolveFails === void 0) {\n    failIfResolveFails = true;\n  }\n\n  var current = base;\n\n  for (var i = 0; i < pathParts.length; i++) {\n    var part = pathParts[i];\n\n    if (part === \"..\") {\n      current = current.parent;\n      if (current) continue; // not everything has a parent\n    } else if (part === \".\") {\n      continue;\n    } else if (current) {\n      if (current instanceof ScalarNode) {\n        // check if the value of a scalar resolves to a state tree node (e.g. references)\n        // then we can continue resolving...\n        try {\n          var value = current.value;\n\n          if (isStateTreeNode(value)) {\n            current = getStateTreeNode(value); // fall through\n          }\n        } catch (e) {\n          if (!failIfResolveFails) {\n            return undefined;\n          }\n\n          throw e;\n        }\n      }\n\n      if (current instanceof ObjectNode) {\n        var subType = current.getChildType(part);\n\n        if (subType) {\n          current = current.getChildNode(part);\n          if (current) continue;\n        }\n      }\n    }\n\n    if (failIfResolveFails) throw fail$1(\"Could not resolve '\" + part + \"' in path '\" + (joinJsonPath(pathParts.slice(0, i)) || \"/\") + \"' while resolving '\" + joinJsonPath(pathParts) + \"'\");else return undefined;\n  }\n\n  return current;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction convertChildNodesToArray(childNodes) {\n  if (!childNodes) return EMPTY_ARRAY;\n  var keys = Object.keys(childNodes);\n  if (!keys.length) return EMPTY_ARRAY;\n  var result = new Array(keys.length);\n  keys.forEach(function (key, index) {\n    result[index] = childNodes[key];\n  });\n  return result;\n} // based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts\n\n/*\n    All contents of this file are deprecated.\n\n    The term `process` has been replaced with `flow` to avoid conflicts with the\n    global `process` object.\n\n    Refer to `flow.ts` for any further changes to this implementation.\n*/\n\n\nvar DEPRECATION_MESSAGE = \"See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information. \" + \"Note that the middleware event types starting with `process` now start with `flow`.\";\n/**\n * @hidden\n *\n * @deprecated has been renamed to `flow()`.\n * See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information.\n * Note that the middleware event types starting with `process` now start with `flow`.\n *\n * @returns {Promise}\n */\n\nfunction process$1(asyncAction) {\n  deprecated(\"process\", \"`process()` has been renamed to `flow()`. \" + DEPRECATION_MESSAGE);\n  return flow(asyncAction);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar EMPTY_ARRAY = Object.freeze([]);\n/**\n * @internal\n * @hidden\n */\n\nvar EMPTY_OBJECT = Object.freeze({});\n/**\n * @internal\n * @hidden\n */\n\nvar mobxShallow = typeof $mobx === \"string\" ? {\n  deep: false\n} : {\n  deep: false,\n  proxy: false\n};\nObject.freeze(mobxShallow);\n/**\n * @internal\n * @hidden\n */\n\nfunction fail$1(message) {\n  if (message === void 0) {\n    message = \"Illegal state\";\n  }\n\n  return new Error(\"[mobx-state-tree] \" + message);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction identity(_) {\n  return _;\n}\n/**\n * pollyfill (for IE) suggested in MDN:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n * @internal\n * @hidden\n */\n\n\nvar isInteger = Number.isInteger || function (value) {\n  return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n/**\n * @internal\n * @hidden\n */\n\n\nfunction isArray(val) {\n  return Array.isArray(val) || isObservableArray(val);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction asArray(val) {\n  if (!val) return EMPTY_ARRAY;\n  if (isArray(val)) return val;\n  return [val];\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction extend(a) {\n  var b = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    b[_i - 1] = arguments[_i];\n  }\n\n  for (var i = 0; i < b.length; i++) {\n    var current = b[i];\n\n    for (var key in current) a[key] = current[key];\n  }\n\n  return a;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction isPlainObject(value) {\n  if (value === null || typeof value !== \"object\") return false;\n  var proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || proto === null;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction isMutable(value) {\n  return value !== null && typeof value === \"object\" && !(value instanceof Date) && !(value instanceof RegExp);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction isPrimitive(value, includeDate) {\n  if (includeDate === void 0) {\n    includeDate = true;\n  }\n\n  if (value === null || value === undefined) return true;\n  if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || includeDate && value instanceof Date) return true;\n  return false;\n}\n/**\n * @internal\n * @hidden\n * Freeze a value and return it (if not in production)\n */\n\n\nfunction freeze(value) {\n  if (!devMode()) return value;\n  return isPrimitive(value) || isObservableArray(value) ? value : Object.freeze(value);\n}\n/**\n * @internal\n * @hidden\n * Recursively freeze a value (if not in production)\n */\n\n\nfunction deepFreeze(value) {\n  if (!devMode()) return value;\n  freeze(value);\n\n  if (isPlainObject(value)) {\n    Object.keys(value).forEach(function (propKey) {\n      if (!isPrimitive(value[propKey]) && !Object.isFrozen(value[propKey])) {\n        deepFreeze(value[propKey]);\n      }\n    });\n  }\n\n  return value;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction isSerializable(value) {\n  return typeof value !== \"function\";\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction addHiddenFinalProp(object, propName, value) {\n  Object.defineProperty(object, propName, {\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    value: value\n  });\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction addHiddenWritableProp(object, propName, value) {\n  Object.defineProperty(object, propName, {\n    enumerable: false,\n    writable: true,\n    configurable: true,\n    value: value\n  });\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar EventHandler =\n/** @class */\nfunction () {\n  function EventHandler() {\n    this.handlers = [];\n  }\n\n  Object.defineProperty(EventHandler.prototype, \"hasSubscribers\", {\n    get: function () {\n      return this.handlers.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  EventHandler.prototype.register = function (fn, atTheBeginning) {\n    var _this = this;\n\n    if (atTheBeginning === void 0) {\n      atTheBeginning = false;\n    }\n\n    if (atTheBeginning) {\n      this.handlers.unshift(fn);\n    } else {\n      this.handlers.push(fn);\n    }\n\n    return function () {\n      _this.unregister(fn);\n    };\n  };\n\n  EventHandler.prototype.has = function (fn) {\n    return this.handlers.indexOf(fn) >= 0;\n  };\n\n  EventHandler.prototype.unregister = function (fn) {\n    var index = this.handlers.indexOf(fn);\n\n    if (index >= 0) {\n      this.handlers.splice(index, 1);\n    }\n  };\n\n  EventHandler.prototype.clear = function () {\n    this.handlers.length = 0;\n  };\n\n  EventHandler.prototype.emit = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // make a copy just in case it changes\n\n\n    var handlers = this.handlers.slice();\n    handlers.forEach(function (f) {\n      return f.apply(void 0, __spread(args));\n    });\n  };\n\n  return EventHandler;\n}();\n/**\n * @internal\n * @hidden\n */\n\n\nvar EventHandlers =\n/** @class */\nfunction () {\n  function EventHandlers() {}\n\n  EventHandlers.prototype.hasSubscribers = function (event) {\n    var handler = this.eventHandlers && this.eventHandlers[event];\n    return !!handler && handler.hasSubscribers;\n  };\n\n  EventHandlers.prototype.register = function (event, fn, atTheBeginning) {\n    if (atTheBeginning === void 0) {\n      atTheBeginning = false;\n    }\n\n    if (!this.eventHandlers) {\n      this.eventHandlers = {};\n    }\n\n    var handler = this.eventHandlers[event];\n\n    if (!handler) {\n      handler = this.eventHandlers[event] = new EventHandler();\n    }\n\n    return handler.register(fn, atTheBeginning);\n  };\n\n  EventHandlers.prototype.has = function (event, fn) {\n    var handler = this.eventHandlers && this.eventHandlers[event];\n    return !!handler && handler.has(fn);\n  };\n\n  EventHandlers.prototype.unregister = function (event, fn) {\n    var handler = this.eventHandlers && this.eventHandlers[event];\n\n    if (handler) {\n      handler.unregister(fn);\n    }\n  };\n\n  EventHandlers.prototype.clear = function (event) {\n    if (this.eventHandlers) {\n      delete this.eventHandlers[event];\n    }\n  };\n\n  EventHandlers.prototype.clearAll = function () {\n    this.eventHandlers = undefined;\n  };\n\n  EventHandlers.prototype.emit = function (event) {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var handler = this.eventHandlers && this.eventHandlers[event];\n\n    if (handler) {\n      (_a = handler).emit.apply(_a, __spread(args));\n    }\n  };\n\n  return EventHandlers;\n}();\n/**\n * @internal\n * @hidden\n */\n\n\nfunction argsToArray(args) {\n  var res = new Array(args.length);\n\n  for (var i = 0; i < args.length; i++) res[i] = args[i];\n\n  return res;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction invalidateComputed(target, propName) {\n  var atom = getAtom(target, propName);\n  atom.trackAndCompute();\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction stringStartsWith(str, beginning) {\n  return str.indexOf(beginning) === 0;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar deprecated = function (id, message) {\n  // skip if running production\n  if (!devMode()) return; // warn if hasn't been warned before\n\n  if (deprecated.ids && !deprecated.ids.hasOwnProperty(id)) {\n    warnError(\"Deprecation warning: \" + message);\n  } // mark as warned to avoid duplicate warn message\n\n\n  if (deprecated.ids) deprecated.ids[id] = true;\n};\n\ndeprecated.ids = {};\n/**\n * @internal\n * @hidden\n */\n\nfunction warnError(msg) {\n  console.warn(new Error(\"[mobx-state-tree] \" + msg));\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction isTypeCheckingEnabled() {\n  return devMode() || typeof process !== \"undefined\" && process.env && process.env.ENABLE_TYPE_CHECK === \"true\";\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction devMode() {\n  return process.env.NODE_ENV !== \"production\";\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction assertArg(value, fn, typeName, argNumber) {\n  if (devMode()) {\n    if (!fn(value)) {\n      // istanbul ignore next\n      throw fail$1(\"expected \" + typeName + \" as argument \" + asArray(argNumber).join(\" or \") + \", got \" + value + \" instead\");\n    }\n  }\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction assertIsFunction(value, argNumber) {\n  assertArg(value, function (fn) {\n    return typeof fn === \"function\";\n  }, \"function\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction assertIsNumber(value, argNumber, min, max) {\n  assertArg(value, function (n) {\n    return typeof n === \"number\";\n  }, \"number\", argNumber);\n\n  if (min !== undefined) {\n    assertArg(value, function (n) {\n      return n >= min;\n    }, \"number greater than \" + min, argNumber);\n  }\n\n  if (max !== undefined) {\n    assertArg(value, function (n) {\n      return n <= max;\n    }, \"number lesser than \" + max, argNumber);\n  }\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction assertIsString(value, argNumber, canBeEmpty) {\n  if (canBeEmpty === void 0) {\n    canBeEmpty = true;\n  }\n\n  assertArg(value, function (s) {\n    return typeof s === \"string\";\n  }, \"string\", argNumber);\n\n  if (!canBeEmpty) {\n    assertArg(value, function (s) {\n      return s !== \"\";\n    }, \"not empty string\", argNumber);\n  }\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction setImmediateWithFallback(fn) {\n  if (typeof queueMicrotask === \"function\") {\n    queueMicrotask(fn);\n  } else if (typeof setImmediate === \"function\") {\n    setImmediate(fn);\n  } else {\n    setTimeout(fn, 1);\n  }\n}\n/**\n * See [asynchronous actions](concepts/async-actions.md).\n *\n * @returns The flow as a promise.\n */\n\n\nfunction flow(generator) {\n  return createFlowSpawner(generator.name, generator);\n}\n/**\n * @deprecated Not needed since TS3.6.\n * Used for TypeScript to make flows that return a promise return the actual promise result.\n *\n * @param val\n * @returns\n */\n\n\nfunction castFlowReturn(val) {\n  return val;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction createFlowSpawner(name, generator) {\n  var spawner = function flowSpawner() {\n    // Implementation based on https://github.com/tj/co/blob/master/index.js\n    var runId = getNextActionId();\n    var parentContext = getCurrentActionContext();\n\n    if (!parentContext) {\n      throw fail$1(\"a mst flow must always have a parent context\");\n    }\n\n    var parentActionContext = getParentActionContext(parentContext);\n\n    if (!parentActionContext) {\n      throw fail$1(\"a mst flow must always have a parent action context\");\n    }\n\n    var contextBase = {\n      name: name,\n      id: runId,\n      tree: parentContext.tree,\n      context: parentContext.context,\n      parentId: parentContext.id,\n      allParentIds: __spread(parentContext.allParentIds, [parentContext.id]),\n      rootId: parentContext.rootId,\n      parentEvent: parentContext,\n      parentActionEvent: parentActionContext\n    };\n    var args = arguments;\n\n    function wrap(fn, type, arg) {\n      fn.$mst_middleware = spawner.$mst_middleware; // pick up any middleware attached to the flow\n\n      runWithActionContext(__assign(__assign({}, contextBase), {\n        type: type,\n        args: [arg]\n      }), fn);\n    }\n\n    return new Promise(function (resolve, reject) {\n      var gen;\n\n      var init = function asyncActionInit() {\n        gen = generator.apply(null, arguments);\n        onFulfilled(undefined); // kick off the flow\n      };\n\n      init.$mst_middleware = spawner.$mst_middleware;\n      runWithActionContext(__assign(__assign({}, contextBase), {\n        type: \"flow_spawn\",\n        args: argsToArray(args)\n      }), init);\n\n      function onFulfilled(res) {\n        var ret;\n\n        try {\n          // prettier-ignore\n          wrap(function (r) {\n            ret = gen.next(r);\n          }, \"flow_resume\", res);\n        } catch (e) {\n          // prettier-ignore\n          setImmediateWithFallback(function () {\n            wrap(function (r) {\n              reject(e);\n            }, \"flow_throw\", e);\n          });\n          return;\n        }\n\n        next(ret);\n        return;\n      }\n\n      function onRejected(err) {\n        var ret;\n\n        try {\n          // prettier-ignore\n          wrap(function (r) {\n            ret = gen.throw(r);\n          }, \"flow_resume_error\", err); // or yieldError?\n        } catch (e) {\n          // prettier-ignore\n          setImmediateWithFallback(function () {\n            wrap(function (r) {\n              reject(e);\n            }, \"flow_throw\", e);\n          });\n          return;\n        }\n\n        next(ret);\n      }\n\n      function next(ret) {\n        if (ret.done) {\n          // prettier-ignore\n          setImmediateWithFallback(function () {\n            wrap(function (r) {\n              resolve(r);\n            }, \"flow_return\", ret.value);\n          });\n          return;\n        } // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100\n\n\n        if (!ret.value || typeof ret.value.then !== \"function\") {\n          // istanbul ignore next\n          throw fail$1(\"Only promises can be yielded to `async`, got: \" + ret);\n        }\n\n        return ret.value.then(onFulfilled, onRejected);\n      }\n    });\n  };\n\n  return spawner;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction splitPatch(patch) {\n  if (!(\"oldValue\" in patch)) throw fail$1(\"Patches without `oldValue` field cannot be inversed\");\n  return [stripPatch(patch), invertPatch(patch)];\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction stripPatch(patch) {\n  // strips `oldvalue` information from the patch, so that it becomes a patch conform the json-patch spec\n  // this removes the ability to undo the patch\n  switch (patch.op) {\n    case \"add\":\n      return {\n        op: \"add\",\n        path: patch.path,\n        value: patch.value\n      };\n\n    case \"remove\":\n      return {\n        op: \"remove\",\n        path: patch.path\n      };\n\n    case \"replace\":\n      return {\n        op: \"replace\",\n        path: patch.path,\n        value: patch.value\n      };\n  }\n}\n\nfunction invertPatch(patch) {\n  switch (patch.op) {\n    case \"add\":\n      return {\n        op: \"remove\",\n        path: patch.path\n      };\n\n    case \"remove\":\n      return {\n        op: \"add\",\n        path: patch.path,\n        value: patch.oldValue\n      };\n\n    case \"replace\":\n      return {\n        op: \"replace\",\n        path: patch.path,\n        value: patch.oldValue\n      };\n  }\n}\n/**\n * Simple simple check to check it is a number.\n */\n\n\nfunction isNumber(x) {\n  return typeof x === \"number\";\n}\n/**\n * Escape slashes and backslashes.\n *\n * http://tools.ietf.org/html/rfc6901\n */\n\n\nfunction escapeJsonPath(path) {\n  if (isNumber(path) === true) {\n    return \"\" + path;\n  }\n\n  if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1) return path;\n  return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescape slashes and backslashes.\n */\n\n\nfunction unescapeJsonPath(path) {\n  return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n/**\n * Generates a json-path compliant json path from path parts.\n *\n * @param path\n * @returns\n */\n\n\nfunction joinJsonPath(path) {\n  // `/` refers to property with an empty name, while `` refers to root itself!\n  if (path.length === 0) return \"\";\n\n  var getPathStr = function (p) {\n    return p.map(escapeJsonPath).join(\"/\");\n  };\n\n  if (path[0] === \".\" || path[0] === \"..\") {\n    // relative\n    return getPathStr(path);\n  } else {\n    // absolute\n    return \"/\" + getPathStr(path);\n  }\n}\n/**\n * Splits and decodes a json path into several parts.\n *\n * @param path\n * @returns\n */\n\n\nfunction splitJsonPath(path) {\n  // `/` refers to property with an empty name, while `` refers to root itself!\n  var parts = path.split(\"/\").map(unescapeJsonPath);\n  var valid = path === \"\" || path === \".\" || path === \"..\" || stringStartsWith(path, \"/\") || stringStartsWith(path, \"./\") || stringStartsWith(path, \"../\");\n\n  if (!valid) {\n    throw fail$1(\"a json path must be either rooted, empty or relative, but got '\" + path + \"'\");\n  } // '/a/b/c' -> [\"a\", \"b\", \"c\"]\n  // '../../b/c' -> [\"..\", \"..\", \"b\", \"c\"]\n  // '' -> []\n  // '/' -> ['']\n  // './a' -> [\".\", \"a\"]\n  // /./a' -> [\".\", \"a\"] equivalent to './a'\n\n\n  if (parts[0] === \"\") {\n    parts.shift();\n  }\n\n  return parts;\n}\n\nvar SnapshotProcessor =\n/** @class */\nfunction (_super) {\n  __extends(SnapshotProcessor, _super);\n\n  function SnapshotProcessor(_subtype, _processors, name) {\n    var _this = _super.call(this, name || _subtype.name) || this;\n\n    _this._subtype = _subtype;\n    _this._processors = _processors;\n    return _this;\n  }\n\n  Object.defineProperty(SnapshotProcessor.prototype, \"flags\", {\n    get: function () {\n      return this._subtype.flags | TypeFlags.SnapshotProcessor;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SnapshotProcessor.prototype.describe = function () {\n    return \"snapshotProcessor(\" + this._subtype.describe() + \")\";\n  };\n\n  SnapshotProcessor.prototype.preProcessSnapshot = function (sn) {\n    if (this._processors.preProcessor) {\n      return this._processors.preProcessor.call(null, sn);\n    }\n\n    return sn;\n  };\n\n  SnapshotProcessor.prototype.postProcessSnapshot = function (sn) {\n    if (this._processors.postProcessor) {\n      return this._processors.postProcessor.call(null, sn);\n    }\n\n    return sn;\n  };\n\n  SnapshotProcessor.prototype._fixNode = function (node) {\n    var _this = this; // the node has to use these methods rather than the original type ones\n\n\n    proxyNodeTypeMethods(node.type, this, \"isAssignableFrom\", \"create\");\n    var oldGetSnapshot = node.getSnapshot;\n\n    node.getSnapshot = function () {\n      return _this.postProcessSnapshot(oldGetSnapshot.call(node));\n    };\n  };\n\n  SnapshotProcessor.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    var processedInitialValue = isStateTreeNode(initialValue) ? initialValue : this.preProcessSnapshot(initialValue);\n\n    var node = this._subtype.instantiate(parent, subpath, environment, processedInitialValue);\n\n    this._fixNode(node);\n\n    return node;\n  };\n\n  SnapshotProcessor.prototype.reconcile = function (current, newValue, parent, subpath) {\n    var node = this._subtype.reconcile(current, isStateTreeNode(newValue) ? newValue : this.preProcessSnapshot(newValue), parent, subpath);\n\n    if (node !== current) {\n      this._fixNode(node);\n    }\n\n    return node;\n  };\n\n  SnapshotProcessor.prototype.getSnapshot = function (node, applyPostProcess) {\n    if (applyPostProcess === void 0) {\n      applyPostProcess = true;\n    }\n\n    var sn = this._subtype.getSnapshot(node);\n\n    return applyPostProcess ? this.postProcessSnapshot(sn) : sn;\n  };\n\n  SnapshotProcessor.prototype.isValidSnapshot = function (value, context) {\n    var processedSn = this.preProcessSnapshot(value);\n    return this._subtype.validate(processedSn, context);\n  };\n\n  SnapshotProcessor.prototype.getSubTypes = function () {\n    return this._subtype;\n  };\n\n  SnapshotProcessor.prototype.is = function (thing) {\n    var value = isType(thing) ? this._subtype : isStateTreeNode(thing) ? getSnapshot(thing, false) : this.preProcessSnapshot(thing);\n    return this._subtype.validate(value, [{\n      path: \"\",\n      type: this._subtype\n    }]).length === 0;\n  };\n\n  return SnapshotProcessor;\n}(BaseType);\n\nfunction proxyNodeTypeMethods(nodeType, snapshotProcessorType) {\n  var e_1, _a;\n\n  var methods = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    methods[_i - 2] = arguments[_i];\n  }\n\n  try {\n    for (var methods_1 = __values(methods), methods_1_1 = methods_1.next(); !methods_1_1.done; methods_1_1 = methods_1.next()) {\n      var method = methods_1_1.value;\n      nodeType[method] = snapshotProcessorType[method].bind(snapshotProcessorType);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (methods_1_1 && !methods_1_1.done && (_a = methods_1.return)) _a.call(methods_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n}\n/**\n * `types.snapshotProcessor` - Runs a pre/post snapshot processor before/after serializing a given type.\n *\n * Example:\n * ```ts\n * const Todo1 = types.model({ text: types.string })\n * // in the backend the text type must be null when empty\n * interface BackendTodo {\n *     text: string | null\n * }\n * const Todo2 = types.snapshotProcessor(Todo1, {\n *     // from snapshot to instance\n *     preProcessor(sn: BackendTodo) {\n *         return {\n *             text: sn.text || \"\";\n *         }\n *     },\n *     // from instance to snapshot\n *     postProcessor(sn): BackendTodo {\n *         return {\n *             text: !sn.text ? null : sn.text\n *         }\n *     }\n * })\n * ```\n *\n * @param type Type to run the processors over.\n * @param processors Processors to run.\n * @param name Type name, or undefined to inherit the inner type one.\n * @returns\n */\n\n\nfunction snapshotProcessor(type, processors, name) {\n  assertIsType(type, 1);\n\n  if (devMode()) {\n    if (processors.postProcessor && typeof processors.postProcessor !== \"function\") {\n      // istanbul ignore next\n      throw fail(\"postSnapshotProcessor must be a function\");\n    }\n\n    if (processors.preProcessor && typeof processors.preProcessor !== \"function\") {\n      // istanbul ignore next\n      throw fail(\"preSnapshotProcessor must be a function\");\n    }\n  }\n\n  return new SnapshotProcessor(type, processors, name);\n}\n\nvar needsIdentifierError = \"Map.put can only be used to store complex values that have an identifier type attribute\";\n\nfunction tryCollectModelTypes(type, modelTypes) {\n  var e_1, _a;\n\n  var subtypes = type.getSubTypes();\n\n  if (subtypes === cannotDetermineSubtype) {\n    return false;\n  }\n\n  if (subtypes) {\n    var subtypesArray = asArray(subtypes);\n\n    try {\n      for (var subtypesArray_1 = __values(subtypesArray), subtypesArray_1_1 = subtypesArray_1.next(); !subtypesArray_1_1.done; subtypesArray_1_1 = subtypesArray_1.next()) {\n        var subtype = subtypesArray_1_1.value;\n        if (!tryCollectModelTypes(subtype, modelTypes)) return false;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (subtypesArray_1_1 && !subtypesArray_1_1.done && (_a = subtypesArray_1.return)) _a.call(subtypesArray_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  if (type instanceof ModelType) {\n    modelTypes.push(type);\n  }\n\n  return true;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar MapIdentifierMode;\n\n(function (MapIdentifierMode) {\n  MapIdentifierMode[MapIdentifierMode[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  MapIdentifierMode[MapIdentifierMode[\"YES\"] = 1] = \"YES\";\n  MapIdentifierMode[MapIdentifierMode[\"NO\"] = 2] = \"NO\";\n})(MapIdentifierMode || (MapIdentifierMode = {}));\n\nvar MSTMap =\n/** @class */\nfunction (_super) {\n  __extends(MSTMap, _super);\n\n  function MSTMap(initialData) {\n    return _super.call(this, initialData, observable.ref.enhancer) || this;\n  }\n\n  MSTMap.prototype.get = function (key) {\n    // maybe this is over-enthousiastic? normalize numeric keys to strings\n    return _super.prototype.get.call(this, \"\" + key);\n  };\n\n  MSTMap.prototype.has = function (key) {\n    return _super.prototype.has.call(this, \"\" + key);\n  };\n\n  MSTMap.prototype.delete = function (key) {\n    return _super.prototype.delete.call(this, \"\" + key);\n  };\n\n  MSTMap.prototype.set = function (key, value) {\n    return _super.prototype.set.call(this, \"\" + key, value);\n  };\n\n  MSTMap.prototype.put = function (value) {\n    if (!value) throw fail$1(\"Map.put cannot be used to set empty values\");\n\n    if (isStateTreeNode(value)) {\n      var node = getStateTreeNode(value);\n\n      if (devMode()) {\n        if (!node.identifierAttribute) {\n          throw fail$1(needsIdentifierError);\n        }\n      }\n\n      if (node.identifier === null) {\n        throw fail$1(needsIdentifierError);\n      }\n\n      this.set(node.identifier, value);\n      return value;\n    } else if (!isMutable(value)) {\n      throw fail$1(\"Map.put can only be used to store complex values\");\n    } else {\n      var mapNode = getStateTreeNode(this);\n      var mapType = mapNode.type;\n\n      if (mapType.identifierMode !== MapIdentifierMode.YES) {\n        throw fail$1(needsIdentifierError);\n      }\n\n      var idAttr = mapType.mapIdentifierAttribute;\n      var id = value[idAttr];\n\n      if (!isValidIdentifier(id)) {\n        // try again but this time after creating a node for the value\n        // since it might be an optional identifier\n        var newNode = this.put(mapType.getChildType().create(value, mapNode.environment));\n        return this.put(getSnapshot(newNode));\n      }\n\n      var key = normalizeIdentifier(id);\n      this.set(key, value);\n      return this.get(key);\n    }\n  };\n\n  return MSTMap;\n}(ObservableMap);\n/**\n * @internal\n * @hidden\n */\n\n\nvar MapType =\n/** @class */\nfunction (_super) {\n  __extends(MapType, _super);\n\n  function MapType(name, _subType, hookInitializers) {\n    if (hookInitializers === void 0) {\n      hookInitializers = [];\n    }\n\n    var _this = _super.call(this, name) || this;\n\n    _this._subType = _subType;\n    _this.identifierMode = MapIdentifierMode.UNKNOWN;\n    _this.mapIdentifierAttribute = undefined;\n    _this.flags = TypeFlags.Map;\n    _this.hookInitializers = [];\n\n    _this._determineIdentifierMode();\n\n    _this.hookInitializers = hookInitializers;\n    return _this;\n  }\n\n  MapType.prototype.hooks = function (hooks) {\n    var hookInitializers = this.hookInitializers.length > 0 ? this.hookInitializers.concat(hooks) : [hooks];\n    return new MapType(this.name, this._subType, hookInitializers);\n  };\n\n  MapType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    this._determineIdentifierMode();\n\n    return createObjectNode(this, parent, subpath, environment, initialValue);\n  };\n\n  MapType.prototype._determineIdentifierMode = function () {\n    if (this.identifierMode !== MapIdentifierMode.UNKNOWN) {\n      return;\n    }\n\n    var modelTypes = [];\n\n    if (tryCollectModelTypes(this._subType, modelTypes)) {\n      var identifierAttribute_1 = undefined;\n      modelTypes.forEach(function (type) {\n        if (type.identifierAttribute) {\n          if (identifierAttribute_1 && identifierAttribute_1 !== type.identifierAttribute) {\n            throw fail$1(\"The objects in a map should all have the same identifier attribute, expected '\" + identifierAttribute_1 + \"', but child of type '\" + type.name + \"' declared attribute '\" + type.identifierAttribute + \"' as identifier\");\n          }\n\n          identifierAttribute_1 = type.identifierAttribute;\n        }\n      });\n\n      if (identifierAttribute_1) {\n        this.identifierMode = MapIdentifierMode.YES;\n        this.mapIdentifierAttribute = identifierAttribute_1;\n      } else {\n        this.identifierMode = MapIdentifierMode.NO;\n      }\n    }\n  };\n\n  MapType.prototype.initializeChildNodes = function (objNode, initialSnapshot) {\n    if (initialSnapshot === void 0) {\n      initialSnapshot = {};\n    }\n\n    var subType = objNode.type._subType;\n    var result = {};\n    Object.keys(initialSnapshot).forEach(function (name) {\n      result[name] = subType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n    });\n    return result;\n  };\n\n  MapType.prototype.createNewInstance = function (childNodes) {\n    return new MSTMap(childNodes);\n  };\n\n  MapType.prototype.finalizeNewInstance = function (node, instance) {\n    _interceptReads(instance, node.unbox);\n\n    var type = node.type;\n    type.hookInitializers.forEach(function (initializer) {\n      var hooks = initializer(instance);\n      Object.keys(hooks).forEach(function (name) {\n        var hook = hooks[name];\n        var actionInvoker = createActionInvoker(instance, name, hook);\n        (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n      });\n    });\n    intercept(instance, this.willChange);\n    observe(instance, this.didChange);\n  };\n\n  MapType.prototype.describe = function () {\n    return \"Map<string, \" + this._subType.describe() + \">\";\n  };\n\n  MapType.prototype.getChildren = function (node) {\n    // return (node.storedValue as ObservableMap<any>).values()\n    return values(node.storedValue);\n  };\n\n  MapType.prototype.getChildNode = function (node, key) {\n    var childNode = node.storedValue.get(\"\" + key);\n    if (!childNode) throw fail$1(\"Not a child \" + key);\n    return childNode;\n  };\n\n  MapType.prototype.willChange = function (change) {\n    var node = getStateTreeNode(change.object);\n    var key = change.name;\n    node.assertWritable({\n      subpath: key\n    });\n    var mapType = node.type;\n    var subType = mapType._subType;\n\n    switch (change.type) {\n      case \"update\":\n        {\n          var newValue = change.newValue;\n          var oldValue = change.object.get(key);\n          if (newValue === oldValue) return null;\n          typecheckInternal(subType, newValue);\n          change.newValue = subType.reconcile(node.getChildNode(key), change.newValue, node, key);\n          mapType.processIdentifier(key, change.newValue);\n        }\n        break;\n\n      case \"add\":\n        {\n          typecheckInternal(subType, change.newValue);\n          change.newValue = subType.instantiate(node, key, undefined, change.newValue);\n          mapType.processIdentifier(key, change.newValue);\n        }\n        break;\n    }\n\n    return change;\n  };\n\n  MapType.prototype.processIdentifier = function (expected, node) {\n    if (this.identifierMode === MapIdentifierMode.YES && node instanceof ObjectNode) {\n      var identifier = node.identifier;\n      if (identifier !== expected) throw fail$1(\"A map of objects containing an identifier should always store the object under their own identifier. Trying to store key '\" + identifier + \"', but expected: '\" + expected + \"'\");\n    }\n  };\n\n  MapType.prototype.getSnapshot = function (node) {\n    var res = {};\n    node.getChildren().forEach(function (childNode) {\n      res[childNode.subpath] = childNode.snapshot;\n    });\n    return res;\n  };\n\n  MapType.prototype.processInitialSnapshot = function (childNodes) {\n    var processed = {};\n    Object.keys(childNodes).forEach(function (key) {\n      processed[key] = childNodes[key].getSnapshot();\n    });\n    return processed;\n  };\n\n  MapType.prototype.didChange = function (change) {\n    var node = getStateTreeNode(change.object);\n\n    switch (change.type) {\n      case \"update\":\n        return void node.emitPatch({\n          op: \"replace\",\n          path: escapeJsonPath(change.name),\n          value: change.newValue.snapshot,\n          oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n        }, node);\n\n      case \"add\":\n        return void node.emitPatch({\n          op: \"add\",\n          path: escapeJsonPath(change.name),\n          value: change.newValue.snapshot,\n          oldValue: undefined\n        }, node);\n\n      case \"delete\":\n        // a node got deleted, get the old snapshot and make the node die\n        var oldSnapshot = change.oldValue.snapshot;\n        change.oldValue.die(); // emit the patch\n\n        return void node.emitPatch({\n          op: \"remove\",\n          path: escapeJsonPath(change.name),\n          oldValue: oldSnapshot\n        }, node);\n    }\n  };\n\n  MapType.prototype.applyPatchLocally = function (node, subpath, patch) {\n    var target = node.storedValue;\n\n    switch (patch.op) {\n      case \"add\":\n      case \"replace\":\n        target.set(subpath, patch.value);\n        break;\n\n      case \"remove\":\n        target.delete(subpath);\n        break;\n    }\n  };\n\n  MapType.prototype.applySnapshot = function (node, snapshot) {\n    typecheckInternal(this, snapshot);\n    var target = node.storedValue;\n    var currentKeys = {};\n    Array.from(target.keys()).forEach(function (key) {\n      currentKeys[key] = false;\n    });\n\n    if (snapshot) {\n      // Don't use target.replace, as it will throw away all existing items first\n      for (var key in snapshot) {\n        target.set(key, snapshot[key]);\n        currentKeys[\"\" + key] = true;\n      }\n    }\n\n    Object.keys(currentKeys).forEach(function (key) {\n      if (currentKeys[key] === false) target.delete(key);\n    });\n  };\n\n  MapType.prototype.getChildType = function () {\n    return this._subType;\n  };\n\n  MapType.prototype.isValidSnapshot = function (value, context) {\n    var _this = this;\n\n    if (!isPlainObject(value)) {\n      return typeCheckFailure(context, value, \"Value is not a plain object\");\n    }\n\n    return flattenTypeErrors(Object.keys(value).map(function (path) {\n      return _this._subType.validate(value[path], getContextForPath(context, path, _this._subType));\n    }));\n  };\n\n  MapType.prototype.getDefaultSnapshot = function () {\n    return EMPTY_OBJECT;\n  };\n\n  MapType.prototype.removeChild = function (node, subpath) {\n    node.storedValue.delete(subpath);\n  };\n\n  __decorate([action], MapType.prototype, \"applySnapshot\", null);\n\n  return MapType;\n}(ComplexType);\n/**\n * `types.map` - Creates a key based collection type who's children are all of a uniform declared type.\n * If the type stored in a map has an identifier, it is mandatory to store the child under that identifier in the map.\n *\n * This type will always produce [observable maps](https://mobx.js.org/refguide/map.html)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   id: types.identifier,\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.map(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: {} })\n * unprotect(s)\n * s.todos.set(17, { task: \"Grab coffee\", id: 17 })\n * s.todos.put({ task: \"Grab cookie\", id: 18 }) // put will infer key from the identifier\n * console.log(s.todos.get(17).task) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\n\n\nfunction map(subtype) {\n  return new MapType(\"map<string, \" + subtype.name + \">\", subtype);\n}\n/**\n * Returns if a given value represents a map type.\n *\n * @param type\n * @returns `true` if it is a map type.\n */\n\n\nfunction isMapType(type) {\n  return isType(type) && (type.flags & TypeFlags.Map) > 0;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar ArrayType =\n/** @class */\nfunction (_super) {\n  __extends(ArrayType, _super);\n\n  function ArrayType(name, _subType, hookInitializers) {\n    if (hookInitializers === void 0) {\n      hookInitializers = [];\n    }\n\n    var _this = _super.call(this, name) || this;\n\n    _this._subType = _subType;\n    _this.flags = TypeFlags.Array;\n    _this.hookInitializers = [];\n    _this.hookInitializers = hookInitializers;\n    return _this;\n  }\n\n  ArrayType.prototype.hooks = function (hooks) {\n    var hookInitializers = this.hookInitializers.length > 0 ? this.hookInitializers.concat(hooks) : [hooks];\n    return new ArrayType(this.name, this._subType, hookInitializers);\n  };\n\n  ArrayType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    return createObjectNode(this, parent, subpath, environment, initialValue);\n  };\n\n  ArrayType.prototype.initializeChildNodes = function (objNode, snapshot) {\n    if (snapshot === void 0) {\n      snapshot = [];\n    }\n\n    var subType = objNode.type._subType;\n    var result = {};\n    snapshot.forEach(function (item, index) {\n      var subpath = \"\" + index;\n      result[subpath] = subType.instantiate(objNode, subpath, undefined, item);\n    });\n    return result;\n  };\n\n  ArrayType.prototype.createNewInstance = function (childNodes) {\n    return observable.array(convertChildNodesToArray(childNodes), mobxShallow);\n  };\n\n  ArrayType.prototype.finalizeNewInstance = function (node, instance) {\n    _getAdministration(instance).dehancer = node.unbox;\n    var type = node.type;\n    type.hookInitializers.forEach(function (initializer) {\n      var hooks = initializer(instance);\n      Object.keys(hooks).forEach(function (name) {\n        var hook = hooks[name];\n        var actionInvoker = createActionInvoker(instance, name, hook);\n        (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n      });\n    });\n    intercept(instance, this.willChange);\n    observe(instance, this.didChange);\n  };\n\n  ArrayType.prototype.describe = function () {\n    return this._subType.describe() + \"[]\";\n  };\n\n  ArrayType.prototype.getChildren = function (node) {\n    return node.storedValue.slice();\n  };\n\n  ArrayType.prototype.getChildNode = function (node, key) {\n    var index = Number(key);\n    if (index < node.storedValue.length) return node.storedValue[index];\n    throw fail$1(\"Not a child: \" + key);\n  };\n\n  ArrayType.prototype.willChange = function (change) {\n    var node = getStateTreeNode(change.object);\n    node.assertWritable({\n      subpath: \"\" + change.index\n    });\n    var subType = node.type._subType;\n    var childNodes = node.getChildren();\n\n    switch (change.type) {\n      case \"update\":\n        {\n          if (change.newValue === change.object[change.index]) return null;\n          var updatedNodes = reconcileArrayChildren(node, subType, [childNodes[change.index]], [change.newValue], [change.index]);\n\n          if (!updatedNodes) {\n            return null;\n          }\n\n          change.newValue = updatedNodes[0];\n        }\n        break;\n\n      case \"splice\":\n        {\n          var index_1 = change.index,\n              removedCount = change.removedCount,\n              added = change.added;\n          var addedNodes = reconcileArrayChildren(node, subType, childNodes.slice(index_1, index_1 + removedCount), added, added.map(function (_, i) {\n            return index_1 + i;\n          }));\n\n          if (!addedNodes) {\n            return null;\n          }\n\n          change.added = addedNodes; // update paths of remaining items\n\n          for (var i = index_1 + removedCount; i < childNodes.length; i++) {\n            childNodes[i].setParent(node, \"\" + (i + added.length - removedCount));\n          }\n        }\n        break;\n    }\n\n    return change;\n  };\n\n  ArrayType.prototype.getSnapshot = function (node) {\n    return node.getChildren().map(function (childNode) {\n      return childNode.snapshot;\n    });\n  };\n\n  ArrayType.prototype.processInitialSnapshot = function (childNodes) {\n    var processed = [];\n    Object.keys(childNodes).forEach(function (key) {\n      processed.push(childNodes[key].getSnapshot());\n    });\n    return processed;\n  };\n\n  ArrayType.prototype.didChange = function (change) {\n    var node = getStateTreeNode(change.object);\n\n    switch (change.type) {\n      case \"update\":\n        return void node.emitPatch({\n          op: \"replace\",\n          path: \"\" + change.index,\n          value: change.newValue.snapshot,\n          oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n        }, node);\n\n      case \"splice\":\n        for (var i = change.removedCount - 1; i >= 0; i--) node.emitPatch({\n          op: \"remove\",\n          path: \"\" + (change.index + i),\n          oldValue: change.removed[i].snapshot\n        }, node);\n\n        for (var i = 0; i < change.addedCount; i++) node.emitPatch({\n          op: \"add\",\n          path: \"\" + (change.index + i),\n          value: node.getChildNode(\"\" + (change.index + i)).snapshot,\n          oldValue: undefined\n        }, node);\n\n        return;\n    }\n  };\n\n  ArrayType.prototype.applyPatchLocally = function (node, subpath, patch) {\n    var target = node.storedValue;\n    var index = subpath === \"-\" ? target.length : Number(subpath);\n\n    switch (patch.op) {\n      case \"replace\":\n        target[index] = patch.value;\n        break;\n\n      case \"add\":\n        target.splice(index, 0, patch.value);\n        break;\n\n      case \"remove\":\n        target.splice(index, 1);\n        break;\n    }\n  };\n\n  ArrayType.prototype.applySnapshot = function (node, snapshot) {\n    typecheckInternal(this, snapshot);\n    var target = node.storedValue;\n    target.replace(snapshot);\n  };\n\n  ArrayType.prototype.getChildType = function () {\n    return this._subType;\n  };\n\n  ArrayType.prototype.isValidSnapshot = function (value, context) {\n    var _this = this;\n\n    if (!isArray(value)) {\n      return typeCheckFailure(context, value, \"Value is not an array\");\n    }\n\n    return flattenTypeErrors(value.map(function (item, index) {\n      return _this._subType.validate(item, getContextForPath(context, \"\" + index, _this._subType));\n    }));\n  };\n\n  ArrayType.prototype.getDefaultSnapshot = function () {\n    return EMPTY_ARRAY;\n  };\n\n  ArrayType.prototype.removeChild = function (node, subpath) {\n    node.storedValue.splice(Number(subpath), 1);\n  };\n\n  __decorate([action], ArrayType.prototype, \"applySnapshot\", null);\n\n  return ArrayType;\n}(ComplexType);\n/**\n * `types.array` - Creates an index based collection type who's children are all of a uniform declared type.\n *\n * This type will always produce [observable arrays](https://mobx.js.org/refguide/array.html)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: [] })\n * unprotect(s) // needed to allow modifying outside of an action\n * s.todos.push({ task: \"Grab coffee\" })\n * console.log(s.todos[0]) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\n\n\nfunction array(subtype) {\n  assertIsType(subtype, 1);\n  return new ArrayType(subtype.name + \"[]\", subtype);\n}\n\nfunction reconcileArrayChildren(parent, childType, oldNodes, newValues, newPaths) {\n  var nothingChanged = true;\n\n  for (var i = 0;; i++) {\n    var hasNewNode = i <= newValues.length - 1;\n    var oldNode = oldNodes[i];\n    var newValue = hasNewNode ? newValues[i] : undefined;\n    var newPath = \"\" + newPaths[i]; // for some reason, instead of newValue we got a node, fallback to the storedValue\n    // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681\n\n    if (isNode(newValue)) newValue = newValue.storedValue;\n\n    if (!oldNode && !hasNewNode) {\n      // both are empty, end\n      break;\n    } else if (!hasNewNode) {\n      // new one does not exists\n      nothingChanged = false;\n      oldNodes.splice(i, 1);\n\n      if (oldNode instanceof ObjectNode) {\n        // since it is going to be returned by pop/splice/shift better create it before killing it\n        // so it doesn't end up in an undead state\n        oldNode.createObservableInstanceIfNeeded();\n      }\n\n      oldNode.die();\n      i--;\n    } else if (!oldNode) {\n      // there is no old node, create it\n      // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.\n      if (isStateTreeNode(newValue) && getStateTreeNode(newValue).parent === parent) {\n        // this node is owned by this parent, but not in the reconcilable set, so it must be double\n        throw fail$1(\"Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '\" + parent.path + \"/\" + newPath + \"', but it lives already at '\" + getStateTreeNode(newValue).path + \"'\");\n      }\n\n      nothingChanged = false;\n      var newNode = valueAsNode(childType, parent, newPath, newValue);\n      oldNodes.splice(i, 0, newNode);\n    } else if (areSame(oldNode, newValue)) {\n      // both are the same, reconcile\n      oldNodes[i] = valueAsNode(childType, parent, newPath, newValue, oldNode);\n    } else {\n      // nothing to do, try to reorder\n      var oldMatch = undefined; // find a possible candidate to reuse\n\n      for (var j = i; j < oldNodes.length; j++) {\n        if (areSame(oldNodes[j], newValue)) {\n          oldMatch = oldNodes.splice(j, 1)[0];\n          break;\n        }\n      }\n\n      nothingChanged = false;\n      var newNode = valueAsNode(childType, parent, newPath, newValue, oldMatch);\n      oldNodes.splice(i, 0, newNode);\n    }\n  }\n\n  return nothingChanged ? null : oldNodes;\n}\n/**\n * Convert a value to a node at given parent and subpath. Attempts to reuse old node if possible and given.\n */\n\n\nfunction valueAsNode(childType, parent, subpath, newValue, oldNode) {\n  // ensure the value is valid-ish\n  typecheckInternal(childType, newValue);\n\n  function getNewNode() {\n    // the new value has a MST node\n    if (isStateTreeNode(newValue)) {\n      var childNode = getStateTreeNode(newValue);\n      childNode.assertAlive(EMPTY_OBJECT); // the node lives here\n\n      if (childNode.parent !== null && childNode.parent === parent) {\n        childNode.setParent(parent, subpath);\n        return childNode;\n      }\n    } // there is old node and new one is a value/snapshot\n\n\n    if (oldNode) {\n      return childType.reconcile(oldNode, newValue, parent, subpath);\n    } // nothing to do, create from scratch\n\n\n    return childType.instantiate(parent, subpath, undefined, newValue);\n  }\n\n  var newNode = getNewNode();\n\n  if (oldNode && oldNode !== newNode) {\n    if (oldNode instanceof ObjectNode) {\n      // since it is going to be returned by pop/splice/shift better create it before killing it\n      // so it doesn't end up in an undead state\n      oldNode.createObservableInstanceIfNeeded();\n    }\n\n    oldNode.die();\n  }\n\n  return newNode;\n}\n/**\n * Check if a node holds a value.\n */\n\n\nfunction areSame(oldNode, newValue) {\n  // never consider dead old nodes for reconciliation\n  if (!oldNode.isAlive) {\n    return false;\n  } // the new value has the same node\n\n\n  if (isStateTreeNode(newValue)) {\n    var newNode = getStateTreeNode(newValue);\n    return newNode.isAlive && newNode === oldNode;\n  } // the provided value is the snapshot of the old node\n\n\n  if (oldNode.snapshot === newValue) {\n    return true;\n  } // new value is a snapshot with the correct identifier\n\n\n  return oldNode instanceof ObjectNode && oldNode.identifier !== null && oldNode.identifierAttribute && isPlainObject(newValue) && oldNode.identifier === normalizeIdentifier(newValue[oldNode.identifierAttribute]) && oldNode.type.is(newValue);\n}\n/**\n * Returns if a given value represents an array type.\n *\n * @param type\n * @returns `true` if the type is an array type.\n */\n\n\nfunction isArrayType(type) {\n  return isType(type) && (type.flags & TypeFlags.Array) > 0;\n}\n\nvar PRE_PROCESS_SNAPSHOT = \"preProcessSnapshot\";\nvar POST_PROCESS_SNAPSHOT = \"postProcessSnapshot\";\n\nfunction objectTypeToString() {\n  return getStateTreeNode(this).toString();\n}\n\nvar defaultObjectOptions = {\n  name: \"AnonymousModel\",\n  properties: {},\n  initializers: EMPTY_ARRAY\n};\n\nfunction toPropertiesObject(declaredProps) {\n  // loop through properties and ensures that all items are types\n  return Object.keys(declaredProps).reduce(function (props, key) {\n    var _a, _b, _c; // warn if user intended a HOOK\n\n\n    if (key in Hook) throw fail$1(\"Hook '\" + key + \"' was defined as property. Hooks should be defined as part of the actions\"); // the user intended to use a view\n\n    var descriptor = Object.getOwnPropertyDescriptor(props, key);\n\n    if (\"get\" in descriptor) {\n      throw fail$1(\"Getters are not supported as properties. Please use views instead\");\n    } // undefined and null are not valid\n\n\n    var value = descriptor.value;\n\n    if (value === null || value === undefined) {\n      throw fail$1(\"The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?\"); // its a primitive, convert to its type\n    } else if (isPrimitive(value)) {\n      return Object.assign({}, props, (_a = {}, _a[key] = optional(getPrimitiveFactoryFromValue(value), value), _a)); // map defaults to empty object automatically for models\n    } else if (value instanceof MapType) {\n      return Object.assign({}, props, (_b = {}, _b[key] = optional(value, {}), _b));\n    } else if (value instanceof ArrayType) {\n      return Object.assign({}, props, (_c = {}, _c[key] = optional(value, []), _c)); // its already a type\n    } else if (isType(value)) {\n      return props; // its a function, maybe the user wanted a view?\n    } else if (devMode() && typeof value === \"function\") {\n      throw fail$1(\"Invalid type definition for property '\" + key + \"', it looks like you passed a function. Did you forget to invoke it, or did you intend to declare a view / action?\"); // no other complex values\n    } else if (devMode() && typeof value === \"object\") {\n      throw fail$1(\"Invalid type definition for property '\" + key + \"', it looks like you passed an object. Try passing another model type or a types.frozen.\"); // WTF did you pass in mate?\n    } else {\n      throw fail$1(\"Invalid type definition for property '\" + key + \"', cannot infer a type from a value like '\" + value + \"' (\" + typeof value + \")\");\n    }\n  }, declaredProps);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar ModelType =\n/** @class */\nfunction (_super) {\n  __extends(ModelType, _super);\n\n  function ModelType(opts) {\n    var _this = _super.call(this, opts.name || defaultObjectOptions.name) || this;\n\n    _this.flags = TypeFlags.Object;\n\n    _this.named = function (name) {\n      return _this.cloneAndEnhance({\n        name: name\n      });\n    };\n\n    _this.props = function (properties) {\n      return _this.cloneAndEnhance({\n        properties: properties\n      });\n    };\n\n    _this.preProcessSnapshot = function (preProcessor) {\n      var currentPreprocessor = _this.preProcessor;\n      if (!currentPreprocessor) return _this.cloneAndEnhance({\n        preProcessor: preProcessor\n      });else return _this.cloneAndEnhance({\n        preProcessor: function (snapshot) {\n          return currentPreprocessor(preProcessor(snapshot));\n        }\n      });\n    };\n\n    _this.postProcessSnapshot = function (postProcessor) {\n      var currentPostprocessor = _this.postProcessor;\n      if (!currentPostprocessor) return _this.cloneAndEnhance({\n        postProcessor: postProcessor\n      });else return _this.cloneAndEnhance({\n        postProcessor: function (snapshot) {\n          return postProcessor(currentPostprocessor(snapshot));\n        }\n      });\n    };\n\n    Object.assign(_this, defaultObjectOptions, opts); // ensures that any default value gets converted to its related type\n\n    _this.properties = toPropertiesObject(_this.properties);\n    freeze(_this.properties); // make sure nobody messes with it\n\n    _this.propertyNames = Object.keys(_this.properties);\n    _this.identifierAttribute = _this._getIdentifierAttribute();\n    return _this;\n  }\n\n  ModelType.prototype._getIdentifierAttribute = function () {\n    var identifierAttribute = undefined;\n    this.forAllProps(function (propName, propType) {\n      if (propType.flags & TypeFlags.Identifier) {\n        if (identifierAttribute) throw fail$1(\"Cannot define property '\" + propName + \"' as object identifier, property '\" + identifierAttribute + \"' is already defined as identifier property\");\n        identifierAttribute = propName;\n      }\n    });\n    return identifierAttribute;\n  };\n\n  ModelType.prototype.cloneAndEnhance = function (opts) {\n    return new ModelType({\n      name: opts.name || this.name,\n      properties: Object.assign({}, this.properties, opts.properties),\n      initializers: this.initializers.concat(opts.initializers || []),\n      preProcessor: opts.preProcessor || this.preProcessor,\n      postProcessor: opts.postProcessor || this.postProcessor\n    });\n  };\n\n  ModelType.prototype.actions = function (fn) {\n    var _this = this;\n\n    var actionInitializer = function (self) {\n      _this.instantiateActions(self, fn(self));\n\n      return self;\n    };\n\n    return this.cloneAndEnhance({\n      initializers: [actionInitializer]\n    });\n  };\n\n  ModelType.prototype.instantiateActions = function (self, actions) {\n    // check if return is correct\n    if (!isPlainObject(actions)) throw fail$1(\"actions initializer should return a plain object containing actions\"); // bind actions to the object created\n\n    Object.keys(actions).forEach(function (name) {\n      // warn if preprocessor was given\n      if (name === PRE_PROCESS_SNAPSHOT) throw fail$1(\"Cannot define action '\" + PRE_PROCESS_SNAPSHOT + \"', it should be defined using 'type.preProcessSnapshot(fn)' instead\"); // warn if postprocessor was given\n\n      if (name === POST_PROCESS_SNAPSHOT) throw fail$1(\"Cannot define action '\" + POST_PROCESS_SNAPSHOT + \"', it should be defined using 'type.postProcessSnapshot(fn)' instead\");\n      var action2 = actions[name]; // apply hook composition\n\n      var baseAction = self[name];\n\n      if (name in Hook && baseAction) {\n        var specializedAction_1 = action2;\n\n        action2 = function () {\n          baseAction.apply(null, arguments);\n          specializedAction_1.apply(null, arguments);\n        };\n      } // the goal of this is to make sure actions using \"this\" can call themselves,\n      // while still allowing the middlewares to register them\n\n\n      var middlewares = action2.$mst_middleware; // make sure middlewares are not lost\n\n      var boundAction = action2.bind(actions);\n      boundAction.$mst_middleware = middlewares;\n      var actionInvoker = createActionInvoker(self, name, boundAction);\n      actions[name] = actionInvoker;\n      (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, name, actionInvoker);\n    });\n  };\n\n  ModelType.prototype.volatile = function (fn) {\n    var _this = this;\n\n    var stateInitializer = function (self) {\n      _this.instantiateVolatileState(self, fn(self));\n\n      return self;\n    };\n\n    return this.cloneAndEnhance({\n      initializers: [stateInitializer]\n    });\n  };\n\n  ModelType.prototype.instantiateVolatileState = function (self, state) {\n    // check views return\n    if (!isPlainObject(state)) throw fail$1(\"volatile state initializer should return a plain object containing state\");\n    set(self, state);\n  };\n\n  ModelType.prototype.extend = function (fn) {\n    var _this = this;\n\n    var initializer = function (self) {\n      var _a = fn(self),\n          actions = _a.actions,\n          views = _a.views,\n          state = _a.state,\n          rest = __rest(_a, [\"actions\", \"views\", \"state\"]);\n\n      for (var key in rest) throw fail$1(\"The `extend` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '\" + key + \"'\");\n\n      if (state) _this.instantiateVolatileState(self, state);\n      if (views) _this.instantiateViews(self, views);\n      if (actions) _this.instantiateActions(self, actions);\n      return self;\n    };\n\n    return this.cloneAndEnhance({\n      initializers: [initializer]\n    });\n  };\n\n  ModelType.prototype.views = function (fn) {\n    var _this = this;\n\n    var viewInitializer = function (self) {\n      _this.instantiateViews(self, fn(self));\n\n      return self;\n    };\n\n    return this.cloneAndEnhance({\n      initializers: [viewInitializer]\n    });\n  };\n\n  ModelType.prototype.instantiateViews = function (self, views) {\n    // check views return\n    if (!isPlainObject(views)) throw fail$1(\"views initializer should return a plain object containing views\");\n    Object.keys(views).forEach(function (key) {\n      // is this a computed property?\n      var descriptor = Object.getOwnPropertyDescriptor(views, key);\n\n      if (\"get\" in descriptor) {\n        if (isComputedProp(self, key)) {\n          var computedValue = _getAdministration(self, key); // TODO: mobx currently does not allow redefining computes yet, pending #1121\n          // FIXME: this binds to the internals of mobx!\n\n\n          computedValue.derivation = descriptor.get;\n          computedValue.scope = self;\n          if (descriptor.set) computedValue.setter = action(computedValue.name + \"-setter\", descriptor.set);\n        } else {\n          computed(self, key, descriptor, true);\n        }\n      } else if (typeof descriptor.value === \"function\") {\n        (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, key, descriptor.value);\n      } else {\n        throw fail$1(\"A view member should either be a function or getter based property\");\n      }\n    });\n  };\n\n  ModelType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    var value = isStateTreeNode(initialValue) ? initialValue : this.applySnapshotPreProcessor(initialValue);\n    return createObjectNode(this, parent, subpath, environment, value); // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class\n    // that pre-reserves all these fields for fast object-member lookups\n  };\n\n  ModelType.prototype.initializeChildNodes = function (objNode, initialSnapshot) {\n    if (initialSnapshot === void 0) {\n      initialSnapshot = {};\n    }\n\n    var type = objNode.type;\n    var result = {};\n    type.forAllProps(function (name, childType) {\n      result[name] = childType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n    });\n    return result;\n  };\n\n  ModelType.prototype.createNewInstance = function (childNodes) {\n    return observable.object(childNodes, EMPTY_OBJECT, mobxShallow);\n  };\n\n  ModelType.prototype.finalizeNewInstance = function (node, instance) {\n    addHiddenFinalProp(instance, \"toString\", objectTypeToString);\n    this.forAllProps(function (name) {\n      _interceptReads(instance, name, node.unbox);\n    });\n    this.initializers.reduce(function (self, fn) {\n      return fn(self);\n    }, instance);\n    intercept(instance, this.willChange);\n    observe(instance, this.didChange);\n  };\n\n  ModelType.prototype.willChange = function (chg) {\n    // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n    var change = chg;\n    var node = getStateTreeNode(change.object);\n    var subpath = change.name;\n    node.assertWritable({\n      subpath: subpath\n    });\n    var childType = node.type.properties[subpath]; // only properties are typed, state are stored as-is references\n\n    if (childType) {\n      typecheckInternal(childType, change.newValue);\n      change.newValue = childType.reconcile(node.getChildNode(subpath), change.newValue, node, subpath);\n    }\n\n    return change;\n  };\n\n  ModelType.prototype.didChange = function (chg) {\n    // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n    var change = chg;\n    var childNode = getStateTreeNode(change.object);\n    var childType = childNode.type.properties[change.name];\n\n    if (!childType) {\n      // don't emit patches for volatile state\n      return;\n    }\n\n    var oldChildValue = change.oldValue ? change.oldValue.snapshot : undefined;\n    childNode.emitPatch({\n      op: \"replace\",\n      path: escapeJsonPath(change.name),\n      value: change.newValue.snapshot,\n      oldValue: oldChildValue\n    }, childNode);\n  };\n\n  ModelType.prototype.getChildren = function (node) {\n    var _this = this;\n\n    var res = [];\n    this.forAllProps(function (name) {\n      res.push(_this.getChildNode(node, name));\n    });\n    return res;\n  };\n\n  ModelType.prototype.getChildNode = function (node, key) {\n    if (!(key in this.properties)) throw fail$1(\"Not a value property: \" + key);\n\n    var childNode = _getAdministration(node.storedValue, key).value; // TODO: blegh!\n\n\n    if (!childNode) throw fail$1(\"Node not available for property \" + key);\n    return childNode;\n  };\n\n  ModelType.prototype.getSnapshot = function (node, applyPostProcess) {\n    var _this = this;\n\n    if (applyPostProcess === void 0) {\n      applyPostProcess = true;\n    }\n\n    var res = {};\n    this.forAllProps(function (name, type) {\n      getAtom(node.storedValue, name).reportObserved();\n      res[name] = _this.getChildNode(node, name).snapshot;\n    });\n\n    if (applyPostProcess) {\n      return this.applySnapshotPostProcessor(res);\n    }\n\n    return res;\n  };\n\n  ModelType.prototype.processInitialSnapshot = function (childNodes) {\n    var processed = {};\n    Object.keys(childNodes).forEach(function (key) {\n      processed[key] = childNodes[key].getSnapshot();\n    });\n    return this.applySnapshotPostProcessor(processed);\n  };\n\n  ModelType.prototype.applyPatchLocally = function (node, subpath, patch) {\n    if (!(patch.op === \"replace\" || patch.op === \"add\")) {\n      throw fail$1(\"object does not support operation \" + patch.op);\n    }\n\n    node.storedValue[subpath] = patch.value;\n  };\n\n  ModelType.prototype.applySnapshot = function (node, snapshot) {\n    var preProcessedSnapshot = this.applySnapshotPreProcessor(snapshot);\n    typecheckInternal(this, preProcessedSnapshot);\n    this.forAllProps(function (name) {\n      node.storedValue[name] = preProcessedSnapshot[name];\n    });\n  };\n\n  ModelType.prototype.applySnapshotPreProcessor = function (snapshot) {\n    var processor = this.preProcessor;\n    return processor ? processor.call(null, snapshot) : snapshot;\n  };\n\n  ModelType.prototype.applySnapshotPostProcessor = function (snapshot) {\n    var postProcessor = this.postProcessor;\n    if (postProcessor) return postProcessor.call(null, snapshot);\n    return snapshot;\n  };\n\n  ModelType.prototype.getChildType = function (propertyName) {\n    assertIsString(propertyName, 1);\n    return this.properties[propertyName];\n  };\n\n  ModelType.prototype.isValidSnapshot = function (value, context) {\n    var _this = this;\n\n    var snapshot = this.applySnapshotPreProcessor(value);\n\n    if (!isPlainObject(snapshot)) {\n      return typeCheckFailure(context, snapshot, \"Value is not a plain object\");\n    }\n\n    return flattenTypeErrors(this.propertyNames.map(function (key) {\n      return _this.properties[key].validate(snapshot[key], getContextForPath(context, key, _this.properties[key]));\n    }));\n  };\n\n  ModelType.prototype.forAllProps = function (fn) {\n    var _this = this;\n\n    this.propertyNames.forEach(function (key) {\n      return fn(key, _this.properties[key]);\n    });\n  };\n\n  ModelType.prototype.describe = function () {\n    var _this = this; // optimization: cache\n\n\n    return \"{ \" + this.propertyNames.map(function (key) {\n      return key + \": \" + _this.properties[key].describe();\n    }).join(\"; \") + \" }\";\n  };\n\n  ModelType.prototype.getDefaultSnapshot = function () {\n    return EMPTY_OBJECT;\n  };\n\n  ModelType.prototype.removeChild = function (node, subpath) {\n    node.storedValue[subpath] = undefined;\n  };\n\n  __decorate([action], ModelType.prototype, \"applySnapshot\", null);\n\n  return ModelType;\n}(ComplexType);\n/**\n * `types.model` - Creates a new model type by providing a name, properties, volatile state and actions.\n *\n * See the [model type](/concepts/trees#creating-models) description or the [getting started](intro/getting-started.md#getting-started-1) tutorial.\n */\n\n\nfunction model() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var name = typeof args[0] === \"string\" ? args.shift() : \"AnonymousModel\";\n  var properties = args.shift() || {};\n  return new ModelType({\n    name: name,\n    properties: properties\n  });\n}\n/**\n * `types.compose` - Composes a new model from one or more existing model types.\n * This method can be invoked in two forms:\n * Given 2 or more model types, the types are composed into a new Type.\n * Given first parameter as a string and 2 or more model types,\n * the types are composed into a new Type with the given name\n */\n\n\nfunction compose() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  } // TODO: just join the base type names if no name is provided\n\n\n  var hasTypename = typeof args[0] === \"string\";\n  var typeName = hasTypename ? args[0] : \"AnonymousModel\";\n\n  if (hasTypename) {\n    args.shift();\n  } // check all parameters\n\n\n  if (devMode()) {\n    args.forEach(function (type, i) {\n      assertArg(type, isModelType, \"mobx-state-tree model type\", hasTypename ? i + 2 : i + 1);\n    });\n  }\n\n  return args.reduce(function (prev, cur) {\n    return prev.cloneAndEnhance({\n      name: prev.name + \"_\" + cur.name,\n      properties: cur.properties,\n      initializers: cur.initializers,\n      preProcessor: function (snapshot) {\n        return cur.applySnapshotPreProcessor(prev.applySnapshotPreProcessor(snapshot));\n      },\n      postProcessor: function (snapshot) {\n        return cur.applySnapshotPostProcessor(prev.applySnapshotPostProcessor(snapshot));\n      }\n    });\n  }).named(typeName);\n}\n/**\n * Returns if a given value represents a model type.\n *\n * @param type\n * @returns\n */\n\n\nfunction isModelType(type) {\n  return isType(type) && (type.flags & TypeFlags.Object) > 0;\n} // TODO: implement CoreType using types.custom ?\n\n/**\n * @internal\n * @hidden\n */\n\n\nvar CoreType =\n/** @class */\nfunction (_super) {\n  __extends(CoreType, _super);\n\n  function CoreType(name, flags, checker, initializer) {\n    if (initializer === void 0) {\n      initializer = identity;\n    }\n\n    var _this = _super.call(this, name) || this;\n\n    _this.flags = flags;\n    _this.checker = checker;\n    _this.initializer = initializer;\n    _this.flags = flags;\n    return _this;\n  }\n\n  CoreType.prototype.describe = function () {\n    return this.name;\n  };\n\n  CoreType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    return createScalarNode(this, parent, subpath, environment, initialValue);\n  };\n\n  CoreType.prototype.createNewInstance = function (snapshot) {\n    return this.initializer(snapshot);\n  };\n\n  CoreType.prototype.isValidSnapshot = function (value, context) {\n    if (isPrimitive(value) && this.checker(value)) {\n      return typeCheckSuccess();\n    }\n\n    var typeName = this.name === \"Date\" ? \"Date or a unix milliseconds timestamp\" : this.name;\n    return typeCheckFailure(context, value, \"Value is not a \" + typeName);\n  };\n\n  return CoreType;\n}(SimpleType);\n/**\n * `types.string` - Creates a type that can only contain a string value.\n * This type is used for string values by default\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *   firstName: types.string,\n *   lastName: \"Doe\"\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\n\n\nvar string = new CoreType(\"string\", TypeFlags.String, function (v) {\n  return typeof v === \"string\";\n});\n/**\n * `types.number` - Creates a type that can only contain a numeric value.\n * This type is used for numeric values by default\n *\n * Example:\n * ```ts\n * const Vector = types.model({\n *   x: types.number,\n *   y: 1.5\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\n\nvar number = new CoreType(\"number\", TypeFlags.Number, function (v) {\n  return typeof v === \"number\";\n});\n/**\n * `types.integer` - Creates a type that can only contain an integer value.\n * This type is used for integer values by default\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.integer,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\n\nvar integer = new CoreType(\"integer\", TypeFlags.Integer, function (v) {\n  return isInteger(v);\n});\n/**\n * `types.boolean` - Creates a type that can only contain a boolean value.\n * This type is used for boolean values by default\n *\n * Example:\n * ```ts\n * const Thing = types.model({\n *   isCool: types.boolean,\n *   isAwesome: false\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\n\nvar boolean = new CoreType(\"boolean\", TypeFlags.Boolean, function (v) {\n  return typeof v === \"boolean\";\n});\n/**\n * `types.null` - The type of the value `null`\n */\n\nvar nullType = new CoreType(\"null\", TypeFlags.Null, function (v) {\n  return v === null;\n});\n/**\n * `types.undefined` - The type of the value `undefined`\n */\n\nvar undefinedType = new CoreType(\"undefined\", TypeFlags.Undefined, function (v) {\n  return v === undefined;\n});\n\nvar _DatePrimitive = new CoreType(\"Date\", TypeFlags.Date, function (v) {\n  return typeof v === \"number\" || v instanceof Date;\n}, function (v) {\n  return v instanceof Date ? v : new Date(v);\n});\n\n_DatePrimitive.getSnapshot = function (node) {\n  return node.storedValue.getTime();\n};\n/**\n * `types.Date` - Creates a type that can only contain a javascript Date value.\n *\n * Example:\n * ```ts\n * const LogLine = types.model({\n *   timestamp: types.Date,\n * })\n *\n * LogLine.create({ timestamp: new Date() })\n * ```\n */\n\n\nvar DatePrimitive = _DatePrimitive;\n/**\n * @internal\n * @hidden\n */\n\nfunction getPrimitiveFactoryFromValue(value) {\n  switch (typeof value) {\n    case \"string\":\n      return string;\n\n    case \"number\":\n      return number;\n    // In the future, isInteger(value) ? integer : number would be interesting, but would be too breaking for now\n\n    case \"boolean\":\n      return boolean;\n\n    case \"object\":\n      if (value instanceof Date) return DatePrimitive;\n  }\n\n  throw fail$1(\"Cannot determine primitive type from value \" + value);\n}\n/**\n * Returns if a given value represents a primitive type.\n *\n * @param type\n * @returns\n */\n\n\nfunction isPrimitiveType(type) {\n  return isType(type) && (type.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.Integer | TypeFlags.Boolean | TypeFlags.Date)) > 0;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar Literal =\n/** @class */\nfunction (_super) {\n  __extends(Literal, _super);\n\n  function Literal(value) {\n    var _this = _super.call(this, JSON.stringify(value)) || this;\n\n    _this.flags = TypeFlags.Literal;\n    _this.value = value;\n    return _this;\n  }\n\n  Literal.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    return createScalarNode(this, parent, subpath, environment, initialValue);\n  };\n\n  Literal.prototype.describe = function () {\n    return JSON.stringify(this.value);\n  };\n\n  Literal.prototype.isValidSnapshot = function (value, context) {\n    if (isPrimitive(value) && value === this.value) {\n      return typeCheckSuccess();\n    }\n\n    return typeCheckFailure(context, value, \"Value is not a literal \" + JSON.stringify(this.value));\n  };\n\n  return Literal;\n}(SimpleType);\n/**\n * `types.literal` - The literal type will return a type that will match only the exact given type.\n * The given value must be a primitive, in order to be serialized to a snapshot correctly.\n * You can use literal to match exact strings for example the exact male or female string.\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *     name: types.string,\n *     gender: types.union(types.literal('male'), types.literal('female'))\n * })\n * ```\n *\n * @param value The value to use in the strict equal check\n * @returns\n */\n\n\nfunction literal(value) {\n  // check that the given value is a primitive\n  assertArg(value, isPrimitive, \"primitive\", 1);\n  return new Literal(value);\n}\n/**\n * Returns if a given value represents a literal type.\n *\n * @param type\n * @returns\n */\n\n\nfunction isLiteralType(type) {\n  return isType(type) && (type.flags & TypeFlags.Literal) > 0;\n}\n\nvar Refinement =\n/** @class */\nfunction (_super) {\n  __extends(Refinement, _super);\n\n  function Refinement(name, _subtype, _predicate, _message) {\n    var _this = _super.call(this, name) || this;\n\n    _this._subtype = _subtype;\n    _this._predicate = _predicate;\n    _this._message = _message;\n    return _this;\n  }\n\n  Object.defineProperty(Refinement.prototype, \"flags\", {\n    get: function () {\n      return this._subtype.flags | TypeFlags.Refinement;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Refinement.prototype.describe = function () {\n    return this.name;\n  };\n\n  Refinement.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    // create the child type\n    return this._subtype.instantiate(parent, subpath, environment, initialValue);\n  };\n\n  Refinement.prototype.isAssignableFrom = function (type) {\n    return this._subtype.isAssignableFrom(type);\n  };\n\n  Refinement.prototype.isValidSnapshot = function (value, context) {\n    var subtypeErrors = this._subtype.validate(value, context);\n\n    if (subtypeErrors.length > 0) return subtypeErrors;\n    var snapshot = isStateTreeNode(value) ? getStateTreeNode(value).snapshot : value;\n\n    if (!this._predicate(snapshot)) {\n      return typeCheckFailure(context, value, this._message(value));\n    }\n\n    return typeCheckSuccess();\n  };\n\n  Refinement.prototype.reconcile = function (current, newValue, parent, subpath) {\n    return this._subtype.reconcile(current, newValue, parent, subpath);\n  };\n\n  Refinement.prototype.getSubTypes = function () {\n    return this._subtype;\n  };\n\n  return Refinement;\n}(BaseType);\n/**\n * `types.refinement` - Creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.\n *\n * @param name\n * @param type\n * @param predicate\n * @returns\n */\n\n\nfunction refinement() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  var name = typeof args[0] === \"string\" ? args.shift() : isType(args[0]) ? args[0].name : null;\n  var type = args[0];\n  var predicate = args[1];\n  var message = args[2] ? args[2] : function (v) {\n    return \"Value does not respect the refinement predicate\";\n  }; // ensures all parameters are correct\n\n  assertIsType(type, [1, 2]);\n  assertIsString(name, 1);\n  assertIsFunction(predicate, [2, 3]);\n  assertIsFunction(message, [3, 4]);\n  return new Refinement(name, type, predicate, message);\n}\n/**\n * Returns if a given value is a refinement type.\n *\n * @param type\n * @returns\n */\n\n\nfunction isRefinementType(type) {\n  return (type.flags & TypeFlags.Refinement) > 0;\n}\n/**\n * `types.enumeration` - Can be used to create an string based enumeration.\n * (note: this methods is just sugar for a union of string literals)\n *\n * Example:\n * ```ts\n * const TrafficLight = types.model({\n *   color: types.enumeration(\"Color\", [\"Red\", \"Orange\", \"Green\"])\n * })\n * ```\n *\n * @param name descriptive name of the enumeration (optional)\n * @param options possible values this enumeration can have\n * @returns\n */\n\n\nfunction enumeration(name, options) {\n  var realOptions = typeof name === \"string\" ? options : name; // check all options\n\n  if (devMode()) {\n    realOptions.forEach(function (option, i) {\n      assertIsString(option, i + 1);\n    });\n  }\n\n  var type = union.apply(void 0, __spread(realOptions.map(function (option) {\n    return literal(\"\" + option);\n  })));\n  if (typeof name === \"string\") type.name = name;\n  return type;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar Union =\n/** @class */\nfunction (_super) {\n  __extends(Union, _super);\n\n  function Union(name, _types, options) {\n    var _this = _super.call(this, name) || this;\n\n    _this._types = _types;\n    _this._eager = true;\n    options = __assign({\n      eager: true,\n      dispatcher: undefined\n    }, options);\n    _this._dispatcher = options.dispatcher;\n    if (!options.eager) _this._eager = false;\n    return _this;\n  }\n\n  Object.defineProperty(Union.prototype, \"flags\", {\n    get: function () {\n      var result = TypeFlags.Union;\n\n      this._types.forEach(function (type) {\n        result |= type.flags;\n      });\n\n      return result;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Union.prototype.isAssignableFrom = function (type) {\n    return this._types.some(function (subType) {\n      return subType.isAssignableFrom(type);\n    });\n  };\n\n  Union.prototype.describe = function () {\n    return \"(\" + this._types.map(function (factory) {\n      return factory.describe();\n    }).join(\" | \") + \")\";\n  };\n\n  Union.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    var type = this.determineType(initialValue, undefined);\n    if (!type) throw fail$1(\"No matching type for union \" + this.describe()); // can happen in prod builds\n\n    return type.instantiate(parent, subpath, environment, initialValue);\n  };\n\n  Union.prototype.reconcile = function (current, newValue, parent, subpath) {\n    var type = this.determineType(newValue, current.type);\n    if (!type) throw fail$1(\"No matching type for union \" + this.describe()); // can happen in prod builds\n\n    return type.reconcile(current, newValue, parent, subpath);\n  };\n\n  Union.prototype.determineType = function (value, reconcileCurrentType) {\n    // try the dispatcher, if defined\n    if (this._dispatcher) {\n      return this._dispatcher(value);\n    } // find the most accomodating type\n    // if we are using reconciliation try the current node type first (fix for #1045)\n\n\n    if (reconcileCurrentType) {\n      if (reconcileCurrentType.is(value)) {\n        return reconcileCurrentType;\n      }\n\n      return this._types.filter(function (t) {\n        return t !== reconcileCurrentType;\n      }).find(function (type) {\n        return type.is(value);\n      });\n    } else {\n      return this._types.find(function (type) {\n        return type.is(value);\n      });\n    }\n  };\n\n  Union.prototype.isValidSnapshot = function (value, context) {\n    if (this._dispatcher) {\n      return this._dispatcher(value).validate(value, context);\n    }\n\n    var allErrors = [];\n    var applicableTypes = 0;\n\n    for (var i = 0; i < this._types.length; i++) {\n      var type = this._types[i];\n      var errors = type.validate(value, context);\n\n      if (errors.length === 0) {\n        if (this._eager) return typeCheckSuccess();else applicableTypes++;\n      } else {\n        allErrors.push(errors);\n      }\n    }\n\n    if (applicableTypes === 1) return typeCheckSuccess();\n    return typeCheckFailure(context, value, \"No type is applicable for the union\").concat(flattenTypeErrors(allErrors));\n  };\n\n  Union.prototype.getSubTypes = function () {\n    return this._types;\n  };\n\n  return Union;\n}(BaseType);\n/**\n * `types.union` - Create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function of the form `(snapshot) => Type`.\n *\n * @param optionsOrType\n * @param otherTypes\n * @returns\n */\n\n\nfunction union(optionsOrType) {\n  var otherTypes = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    otherTypes[_i - 1] = arguments[_i];\n  }\n\n  var options = isType(optionsOrType) ? undefined : optionsOrType;\n  var types = isType(optionsOrType) ? __spread([optionsOrType], otherTypes) : otherTypes;\n  var name = \"(\" + types.map(function (type) {\n    return type.name;\n  }).join(\" | \") + \")\"; // check all options\n\n  if (devMode()) {\n    if (options) {\n      assertArg(options, function (o) {\n        return isPlainObject(o);\n      }, \"object { eager?: boolean, dispatcher?: Function }\", 1);\n    }\n\n    types.forEach(function (type, i) {\n      assertIsType(type, options ? i + 2 : i + 1);\n    });\n  }\n\n  return new Union(name, types, options);\n}\n/**\n * Returns if a given value represents a union type.\n *\n * @param type\n * @returns\n */\n\n\nfunction isUnionType(type) {\n  return (type.flags & TypeFlags.Union) > 0;\n}\n/**\n * @hidden\n * @internal\n */\n\n\nvar OptionalValue =\n/** @class */\nfunction (_super) {\n  __extends(OptionalValue, _super);\n\n  function OptionalValue(_subtype, _defaultValue, optionalValues) {\n    var _this = _super.call(this, _subtype.name) || this;\n\n    _this._subtype = _subtype;\n    _this._defaultValue = _defaultValue;\n    _this.optionalValues = optionalValues;\n    return _this;\n  }\n\n  Object.defineProperty(OptionalValue.prototype, \"flags\", {\n    get: function () {\n      return this._subtype.flags | TypeFlags.Optional;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  OptionalValue.prototype.describe = function () {\n    return this._subtype.describe() + \"?\";\n  };\n\n  OptionalValue.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    if (this.optionalValues.indexOf(initialValue) >= 0) {\n      var defaultInstanceOrSnapshot = this.getDefaultInstanceOrSnapshot();\n      return this._subtype.instantiate(parent, subpath, environment, defaultInstanceOrSnapshot);\n    }\n\n    return this._subtype.instantiate(parent, subpath, environment, initialValue);\n  };\n\n  OptionalValue.prototype.reconcile = function (current, newValue, parent, subpath) {\n    return this._subtype.reconcile(current, this.optionalValues.indexOf(newValue) < 0 && this._subtype.is(newValue) ? newValue : this.getDefaultInstanceOrSnapshot(), parent, subpath);\n  };\n\n  OptionalValue.prototype.getDefaultInstanceOrSnapshot = function () {\n    var defaultInstanceOrSnapshot = typeof this._defaultValue === \"function\" ? this._defaultValue() : this._defaultValue; // while static values are already snapshots and checked on types.optional\n    // generator functions must always be rechecked just in case\n\n    if (typeof this._defaultValue === \"function\") {\n      typecheckInternal(this, defaultInstanceOrSnapshot);\n    }\n\n    return defaultInstanceOrSnapshot;\n  };\n\n  OptionalValue.prototype.isValidSnapshot = function (value, context) {\n    // defaulted values can be skipped\n    if (this.optionalValues.indexOf(value) >= 0) {\n      return typeCheckSuccess();\n    } // bounce validation to the sub-type\n\n\n    return this._subtype.validate(value, context);\n  };\n\n  OptionalValue.prototype.isAssignableFrom = function (type) {\n    return this._subtype.isAssignableFrom(type);\n  };\n\n  OptionalValue.prototype.getSubTypes = function () {\n    return this._subtype;\n  };\n\n  return OptionalValue;\n}(BaseType);\n\nfunction checkOptionalPreconditions(type, defaultValueOrFunction) {\n  // make sure we never pass direct instances\n  if (typeof defaultValueOrFunction !== \"function\" && isStateTreeNode(defaultValueOrFunction)) {\n    throw fail$1(\"default value cannot be an instance, pass a snapshot or a function that creates an instance/snapshot instead\");\n  }\n\n  assertIsType(type, 1);\n\n  if (devMode()) {\n    // we only check default values if they are passed directly\n    // if they are generator functions they will be checked once they are generated\n    // we don't check generator function results here to avoid generating a node just for type-checking purposes\n    // which might generate side-effects\n    if (typeof defaultValueOrFunction !== \"function\") {\n      typecheckInternal(type, defaultValueOrFunction);\n    }\n  }\n}\n/**\n * `types.optional` - Can be used to create a property with a default value.\n *\n * Depending on the third argument (`optionalValues`) there are two ways of operation:\n * - If the argument is not provided, then if a value is not provided in the snapshot (`undefined` or missing),\n *   it will default to the provided `defaultValue`\n * - If the argument is provided, then if the value in the snapshot matches one of the optional values inside the array then it will\n *   default to the provided `defaultValue`. Additionally, if one of the optional values inside the array is `undefined` then a missing\n *   property is also valid.\n *\n *   Note that it is also possible to include values of the same type as the intended subtype as optional values,\n *   in this case the optional value will be transformed into the `defaultValue` (e.g. `types.optional(types.string, \"unnamed\", [undefined, \"\"])`\n *   will transform the snapshot values `undefined` (and therefore missing) and empty strings into the string `\"unnamed\"` when it gets\n *   instantiated).\n *\n * If `defaultValue` is a function, the function will be invoked for every new instance.\n * Applying a snapshot in which the optional value is one of the optional values (or `undefined`/_not_ present if none are provided) causes the\n * value to be reset.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string,\n *   subtitle1: types.optional(types.string, \"\", [null]),\n *   subtitle2: types.optional(types.string, \"\", [null, undefined]),\n *   done: types.optional(types.boolean, false),\n *   created: types.optional(types.Date, () => new Date()),\n * })\n *\n * // if done is missing / undefined it will become false\n * // if created is missing / undefined it will get a freshly generated timestamp\n * // if subtitle1 is null it will default to \"\", but it cannot be missing or undefined\n * // if subtitle2 is null or undefined it will default to \"\"; since it can be undefined it can also be missing\n * const todo = Todo.create({ title: \"Get coffee\", subtitle1: null })\n * ```\n *\n * @param type\n * @param defaultValueOrFunction\n * @param optionalValues an optional array with zero or more primitive values (string, number, boolean, null or undefined)\n *                       that will be converted into the default. `[ undefined ]` is assumed when none is provided\n * @returns\n */\n\n\nfunction optional(type, defaultValueOrFunction, optionalValues) {\n  checkOptionalPreconditions(type, defaultValueOrFunction);\n  return new OptionalValue(type, defaultValueOrFunction, optionalValues ? optionalValues : undefinedAsOptionalValues);\n}\n\nvar undefinedAsOptionalValues = [undefined];\n/**\n * Returns if a value represents an optional type.\n *\n * @template IT\n * @param type\n * @returns\n */\n\nfunction isOptionalType(type) {\n  return isType(type) && (type.flags & TypeFlags.Optional) > 0;\n}\n\nvar optionalUndefinedType = optional(undefinedType, undefined);\nvar optionalNullType = optional(nullType, null);\n/**\n * `types.maybe` - Maybe will make a type nullable, and also optional.\n * The value `undefined` will be used to represent nullability.\n *\n * @param type\n * @returns\n */\n\nfunction maybe(type) {\n  assertIsType(type, 1);\n  return union(type, optionalUndefinedType);\n}\n/**\n * `types.maybeNull` - Maybe will make a type nullable, and also optional.\n * The value `null` will be used to represent no value.\n *\n * @param type\n * @returns\n */\n\n\nfunction maybeNull(type) {\n  assertIsType(type, 1);\n  return union(type, optionalNullType);\n}\n\nvar Late =\n/** @class */\nfunction (_super) {\n  __extends(Late, _super);\n\n  function Late(name, _definition) {\n    var _this = _super.call(this, name) || this;\n\n    _this._definition = _definition;\n    return _this;\n  }\n\n  Object.defineProperty(Late.prototype, \"flags\", {\n    get: function () {\n      return (this._subType ? this._subType.flags : 0) | TypeFlags.Late;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Late.prototype.getSubType = function (mustSucceed) {\n    if (!this._subType) {\n      var t = undefined;\n\n      try {\n        t = this._definition();\n      } catch (e) {\n        if (e instanceof ReferenceError) // can happen in strict ES5 code when a definition is self refering\n          t = undefined;else throw e;\n      }\n\n      if (mustSucceed && t === undefined) throw fail$1(\"Late type seems to be used too early, the definition (still) returns undefined\");\n\n      if (t) {\n        if (devMode() && !isType(t)) throw fail$1(\"Failed to determine subtype, make sure types.late returns a type definition.\");\n        this._subType = t;\n      }\n    }\n\n    return this._subType;\n  };\n\n  Late.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    return this.getSubType(true).instantiate(parent, subpath, environment, initialValue);\n  };\n\n  Late.prototype.reconcile = function (current, newValue, parent, subpath) {\n    return this.getSubType(true).reconcile(current, newValue, parent, subpath);\n  };\n\n  Late.prototype.describe = function () {\n    var t = this.getSubType(false);\n    return t ? t.name : \"<uknown late type>\";\n  };\n\n  Late.prototype.isValidSnapshot = function (value, context) {\n    var t = this.getSubType(false);\n\n    if (!t) {\n      // See #916; the variable the definition closure is pointing to wasn't defined yet, so can't be evaluted yet here\n      return typeCheckSuccess();\n    }\n\n    return t.validate(value, context);\n  };\n\n  Late.prototype.isAssignableFrom = function (type) {\n    var t = this.getSubType(false);\n    return t ? t.isAssignableFrom(type) : false;\n  };\n\n  Late.prototype.getSubTypes = function () {\n    var subtype = this.getSubType(false);\n    return subtype ? subtype : cannotDetermineSubtype;\n  };\n\n  return Late;\n}(BaseType);\n/**\n * `types.late` - Defines a type that gets implemented later. This is useful when you have to deal with circular dependencies.\n * Please notice that when defining circular dependencies TypeScript isn't smart enough to inference them.\n *\n * Example:\n * ```ts\n *   // TypeScript isn't smart enough to infer self referencing types.\n *  const Node = types.model({\n *       children: types.array(types.late((): IAnyModelType => Node)) // then typecast each array element to Instance<typeof Node>\n *  })\n * ```\n *\n * @param name The name to use for the type that will be returned.\n * @param type A function that returns the type that will be defined.\n * @returns\n */\n\n\nfunction late(nameOrType, maybeType) {\n  var name = typeof nameOrType === \"string\" ? nameOrType : \"late(\" + nameOrType.toString() + \")\";\n  var type = typeof nameOrType === \"string\" ? maybeType : nameOrType; // checks that the type is actually a late type\n\n  if (devMode()) {\n    if (!(typeof type === \"function\" && type.length === 0)) throw fail$1(\"Invalid late type, expected a function with zero arguments that returns a type, got: \" + type);\n  }\n\n  return new Late(name, type);\n}\n/**\n * Returns if a given value represents a late type.\n *\n * @param type\n * @returns\n */\n\n\nfunction isLateType(type) {\n  return isType(type) && (type.flags & TypeFlags.Late) > 0;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar Frozen =\n/** @class */\nfunction (_super) {\n  __extends(Frozen, _super);\n\n  function Frozen(subType) {\n    var _this = _super.call(this, subType ? \"frozen(\" + subType.name + \")\" : \"frozen\") || this;\n\n    _this.subType = subType;\n    _this.flags = TypeFlags.Frozen;\n    return _this;\n  }\n\n  Frozen.prototype.describe = function () {\n    return \"<any immutable value>\";\n  };\n\n  Frozen.prototype.instantiate = function (parent, subpath, environment, value) {\n    // create the node\n    return createScalarNode(this, parent, subpath, environment, deepFreeze(value));\n  };\n\n  Frozen.prototype.isValidSnapshot = function (value, context) {\n    if (!isSerializable(value)) {\n      return typeCheckFailure(context, value, \"Value is not serializable and cannot be frozen\");\n    }\n\n    if (this.subType) return this.subType.validate(value, context);\n    return typeCheckSuccess();\n  };\n\n  return Frozen;\n}(SimpleType);\n\nvar untypedFrozenInstance = new Frozen();\n/**\n * `types.frozen` - Frozen can be used to store any value that is serializable in itself (that is valid JSON).\n * Frozen values need to be immutable or treated as if immutable. They need be serializable as well.\n * Values stored in frozen will snapshotted as-is by MST, and internal changes will not be tracked.\n *\n * This is useful to store complex, but immutable values like vectors etc. It can form a powerful bridge to parts of your application that should be immutable, or that assume data to be immutable.\n *\n * Note: if you want to store free-form state that is mutable, or not serializeable, consider using volatile state instead.\n *\n * Frozen properties can be defined in three different ways\n * 1. `types.frozen(SubType)` - provide a valid MST type and frozen will check if the provided data conforms the snapshot for that type\n * 2. `types.frozen({ someDefaultValue: true})` - provide a primitive value, object or array, and MST will infer the type from that object, and also make it the default value for the field\n * 3. `types.frozen<TypeScriptType>()` - provide a typescript type, to help in strongly typing the field (design time only)\n *\n * Example:\n * ```ts\n * const GameCharacter = types.model({\n *   name: string,\n *   location: types.frozen({ x: 0, y: 0})\n * })\n *\n * const hero = GameCharacter.create({\n *   name: \"Mario\",\n *   location: { x: 7, y: 4 }\n * })\n *\n * hero.location = { x: 10, y: 2 } // OK\n * hero.location.x = 7 // Not ok!\n * ```\n *\n * ```ts\n * type Point = { x: number, y: number }\n *    const Mouse = types.model({\n *         loc: types.frozen<Point>()\n *    })\n * ```\n *\n * @param defaultValueOrType\n * @returns\n */\n\nfunction frozen(arg) {\n  if (arguments.length === 0) return untypedFrozenInstance;else if (isType(arg)) return new Frozen(arg);else return optional(untypedFrozenInstance, arg);\n}\n/**\n * Returns if a given value represents a frozen type.\n *\n * @param type\n * @returns\n */\n\n\nfunction isFrozenType(type) {\n  return isType(type) && (type.flags & TypeFlags.Frozen) > 0;\n}\n\nfunction getInvalidationCause(hook) {\n  switch (hook) {\n    case Hook.beforeDestroy:\n      return \"destroy\";\n\n    case Hook.beforeDetach:\n      return \"detach\";\n\n    default:\n      return undefined;\n  }\n}\n\nvar StoredReference =\n/** @class */\nfunction () {\n  function StoredReference(value, targetType) {\n    this.targetType = targetType;\n\n    if (isValidIdentifier(value)) {\n      this.identifier = value;\n    } else if (isStateTreeNode(value)) {\n      var targetNode = getStateTreeNode(value);\n      if (!targetNode.identifierAttribute) throw fail$1(\"Can only store references with a defined identifier attribute.\");\n      var id = targetNode.unnormalizedIdentifier;\n\n      if (id === null || id === undefined) {\n        throw fail$1(\"Can only store references to tree nodes with a defined identifier.\");\n      }\n\n      this.identifier = id;\n    } else {\n      throw fail$1(\"Can only store references to tree nodes or identifiers, got: '\" + value + \"'\");\n    }\n  }\n\n  StoredReference.prototype.updateResolvedReference = function (node) {\n    var normalizedId = normalizeIdentifier(this.identifier);\n    var root = node.root;\n    var lastCacheModification = root.identifierCache.getLastCacheModificationPerId(normalizedId);\n\n    if (!this.resolvedReference || this.resolvedReference.lastCacheModification !== lastCacheModification) {\n      var targetType = this.targetType; // reference was initialized with the identifier of the target\n\n      var target = root.identifierCache.resolve(targetType, normalizedId);\n\n      if (!target) {\n        throw new InvalidReferenceError(\"[mobx-state-tree] Failed to resolve reference '\" + this.identifier + \"' to type '\" + this.targetType.name + \"' (from node: \" + node.path + \")\");\n      }\n\n      this.resolvedReference = {\n        node: target,\n        lastCacheModification: lastCacheModification\n      };\n    }\n  };\n\n  Object.defineProperty(StoredReference.prototype, \"resolvedValue\", {\n    get: function () {\n      this.updateResolvedReference(this.node);\n      return this.resolvedReference.node.value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return StoredReference;\n}();\n/**\n * @internal\n * @hidden\n */\n\n\nvar InvalidReferenceError =\n/** @class */\nfunction (_super) {\n  __extends(InvalidReferenceError, _super);\n\n  function InvalidReferenceError(m) {\n    var _this = _super.call(this, m) || this;\n\n    Object.setPrototypeOf(_this, InvalidReferenceError.prototype);\n    return _this;\n  }\n\n  return InvalidReferenceError;\n}(Error);\n/**\n * @internal\n * @hidden\n */\n\n\nvar BaseReferenceType =\n/** @class */\nfunction (_super) {\n  __extends(BaseReferenceType, _super);\n\n  function BaseReferenceType(targetType, onInvalidated) {\n    var _this = _super.call(this, \"reference(\" + targetType.name + \")\") || this;\n\n    _this.targetType = targetType;\n    _this.onInvalidated = onInvalidated;\n    _this.flags = TypeFlags.Reference;\n    return _this;\n  }\n\n  BaseReferenceType.prototype.describe = function () {\n    return this.name;\n  };\n\n  BaseReferenceType.prototype.isAssignableFrom = function (type) {\n    return this.targetType.isAssignableFrom(type);\n  };\n\n  BaseReferenceType.prototype.isValidSnapshot = function (value, context) {\n    return isValidIdentifier(value) ? typeCheckSuccess() : typeCheckFailure(context, value, \"Value is not a valid identifier, which is a string or a number\");\n  };\n\n  BaseReferenceType.prototype.fireInvalidated = function (cause, storedRefNode, referenceId, refTargetNode) {\n    // to actually invalidate a reference we need an alive parent,\n    // since it is a scalar value (immutable-ish) and we need to change it\n    // from the parent\n    var storedRefParentNode = storedRefNode.parent;\n\n    if (!storedRefParentNode || !storedRefParentNode.isAlive) {\n      return;\n    }\n\n    var storedRefParentValue = storedRefParentNode.storedValue;\n\n    if (!storedRefParentValue) {\n      return;\n    }\n\n    this.onInvalidated({\n      cause: cause,\n      parent: storedRefParentValue,\n      invalidTarget: refTargetNode ? refTargetNode.storedValue : undefined,\n      invalidId: referenceId,\n      replaceRef: function (newRef) {\n        applyPatch(storedRefNode.root.storedValue, {\n          op: \"replace\",\n          value: newRef,\n          path: storedRefNode.path\n        });\n      },\n      removeRef: function () {\n        if (isModelType(storedRefParentNode.type)) {\n          this.replaceRef(undefined);\n        } else {\n          applyPatch(storedRefNode.root.storedValue, {\n            op: \"remove\",\n            path: storedRefNode.path\n          });\n        }\n      }\n    });\n  };\n\n  BaseReferenceType.prototype.addTargetNodeWatcher = function (storedRefNode, referenceId) {\n    var _this = this; // this will make sure the target node becomes created\n\n\n    var refTargetValue = this.getValue(storedRefNode);\n\n    if (!refTargetValue) {\n      return undefined;\n    }\n\n    var refTargetNode = getStateTreeNode(refTargetValue);\n\n    var hookHandler = function (_, refTargetNodeHook) {\n      var cause = getInvalidationCause(refTargetNodeHook);\n\n      if (!cause) {\n        return;\n      }\n\n      _this.fireInvalidated(cause, storedRefNode, referenceId, refTargetNode);\n    };\n\n    var refTargetDetachHookDisposer = refTargetNode.registerHook(Hook.beforeDetach, hookHandler);\n    var refTargetDestroyHookDisposer = refTargetNode.registerHook(Hook.beforeDestroy, hookHandler);\n    return function () {\n      refTargetDetachHookDisposer();\n      refTargetDestroyHookDisposer();\n    };\n  };\n\n  BaseReferenceType.prototype.watchTargetNodeForInvalidations = function (storedRefNode, identifier, customGetSet) {\n    var _this = this;\n\n    if (!this.onInvalidated) {\n      return;\n    }\n\n    var onRefTargetDestroyedHookDisposer; // get rid of the watcher hook when the stored ref node is destroyed\n    // detached is ignored since scalar nodes (where the reference resides) cannot be detached\n\n    storedRefNode.registerHook(Hook.beforeDestroy, function () {\n      if (onRefTargetDestroyedHookDisposer) {\n        onRefTargetDestroyedHookDisposer();\n      }\n    });\n\n    var startWatching = function (sync) {\n      // re-create hook in case the stored ref gets reattached\n      if (onRefTargetDestroyedHookDisposer) {\n        onRefTargetDestroyedHookDisposer();\n      } // make sure the target node is actually there and initialized\n\n\n      var storedRefParentNode = storedRefNode.parent;\n      var storedRefParentValue = storedRefParentNode && storedRefParentNode.storedValue;\n\n      if (storedRefParentNode && storedRefParentNode.isAlive && storedRefParentValue) {\n        var refTargetNodeExists = void 0;\n\n        if (customGetSet) {\n          refTargetNodeExists = !!customGetSet.get(identifier, storedRefParentValue);\n        } else {\n          refTargetNodeExists = storedRefNode.root.identifierCache.has(_this.targetType, normalizeIdentifier(identifier));\n        }\n\n        if (!refTargetNodeExists) {\n          // we cannot change the reference in sync mode\n          // since we are in the middle of a reconciliation/instantiation and the change would be overwritten\n          // for those cases just let the wrong reference be assigned and fail upon usage\n          // (like current references do)\n          // this means that effectively this code will only run when it is created from a snapshot\n          if (!sync) {\n            _this.fireInvalidated(\"invalidSnapshotReference\", storedRefNode, identifier, null);\n          }\n        } else {\n          onRefTargetDestroyedHookDisposer = _this.addTargetNodeWatcher(storedRefNode, identifier);\n        }\n      }\n    };\n\n    if (storedRefNode.state === NodeLifeCycle.FINALIZED) {\n      // already attached, so the whole tree is ready\n      startWatching(true);\n    } else {\n      if (!storedRefNode.isRoot) {\n        // start watching once the whole tree is ready\n        storedRefNode.root.registerHook(Hook.afterCreationFinalization, function () {\n          // make sure to attach it so it can start listening\n          if (storedRefNode.parent) {\n            storedRefNode.parent.createObservableInstanceIfNeeded();\n          }\n        });\n      } // start watching once the node is attached somewhere / parent changes\n\n\n      storedRefNode.registerHook(Hook.afterAttach, function () {\n        startWatching(false);\n      });\n    }\n  };\n\n  return BaseReferenceType;\n}(SimpleType);\n/**\n * @internal\n * @hidden\n */\n\n\nvar IdentifierReferenceType =\n/** @class */\nfunction (_super) {\n  __extends(IdentifierReferenceType, _super);\n\n  function IdentifierReferenceType(targetType, onInvalidated) {\n    return _super.call(this, targetType, onInvalidated) || this;\n  }\n\n  IdentifierReferenceType.prototype.getValue = function (storedRefNode) {\n    if (!storedRefNode.isAlive) return undefined;\n    var storedRef = storedRefNode.storedValue;\n    return storedRef.resolvedValue;\n  };\n\n  IdentifierReferenceType.prototype.getSnapshot = function (storedRefNode) {\n    var ref = storedRefNode.storedValue;\n    return ref.identifier;\n  };\n\n  IdentifierReferenceType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    var identifier = isStateTreeNode(initialValue) ? getIdentifier(initialValue) : initialValue;\n    var storedRef = new StoredReference(initialValue, this.targetType);\n    var storedRefNode = createScalarNode(this, parent, subpath, environment, storedRef);\n    storedRef.node = storedRefNode;\n    this.watchTargetNodeForInvalidations(storedRefNode, identifier, undefined);\n    return storedRefNode;\n  };\n\n  IdentifierReferenceType.prototype.reconcile = function (current, newValue, parent, subpath) {\n    if (!current.isDetaching && current.type === this) {\n      var compareByValue = isStateTreeNode(newValue);\n      var ref = current.storedValue;\n\n      if (!compareByValue && ref.identifier === newValue || compareByValue && ref.resolvedValue === newValue) {\n        current.setParent(parent, subpath);\n        return current;\n      }\n    }\n\n    var newNode = this.instantiate(parent, subpath, undefined, newValue);\n    current.die(); // noop if detaching\n\n    return newNode;\n  };\n\n  return IdentifierReferenceType;\n}(BaseReferenceType);\n/**\n * @internal\n * @hidden\n */\n\n\nvar CustomReferenceType =\n/** @class */\nfunction (_super) {\n  __extends(CustomReferenceType, _super);\n\n  function CustomReferenceType(targetType, options, onInvalidated) {\n    var _this = _super.call(this, targetType, onInvalidated) || this;\n\n    _this.options = options;\n    return _this;\n  }\n\n  CustomReferenceType.prototype.getValue = function (storedRefNode) {\n    if (!storedRefNode.isAlive) return undefined;\n    var referencedNode = this.options.get(storedRefNode.storedValue, storedRefNode.parent ? storedRefNode.parent.storedValue : null);\n    return referencedNode;\n  };\n\n  CustomReferenceType.prototype.getSnapshot = function (storedRefNode) {\n    return storedRefNode.storedValue;\n  };\n\n  CustomReferenceType.prototype.instantiate = function (parent, subpath, environment, newValue) {\n    var identifier = isStateTreeNode(newValue) ? this.options.set(newValue, parent ? parent.storedValue : null) : newValue;\n    var storedRefNode = createScalarNode(this, parent, subpath, environment, identifier);\n    this.watchTargetNodeForInvalidations(storedRefNode, identifier, this.options);\n    return storedRefNode;\n  };\n\n  CustomReferenceType.prototype.reconcile = function (current, newValue, parent, subpath) {\n    var newIdentifier = isStateTreeNode(newValue) ? this.options.set(newValue, current ? current.storedValue : null) : newValue;\n\n    if (!current.isDetaching && current.type === this && current.storedValue === newIdentifier) {\n      current.setParent(parent, subpath);\n      return current;\n    }\n\n    var newNode = this.instantiate(parent, subpath, undefined, newIdentifier);\n    current.die(); // noop if detaching\n\n    return newNode;\n  };\n\n  return CustomReferenceType;\n}(BaseReferenceType);\n/**\n * `types.reference` - Creates a reference to another type, which should have defined an identifier.\n * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.\n */\n\n\nfunction reference(subType, options) {\n  assertIsType(subType, 1);\n\n  if (devMode()) {\n    if (arguments.length === 2 && typeof arguments[1] === \"string\") {\n      // istanbul ignore next\n      throw fail$1(\"References with base path are no longer supported. Please remove the base path.\");\n    }\n  }\n\n  var getSetOptions = options ? options : undefined;\n  var onInvalidated = options ? options.onInvalidated : undefined;\n\n  if (getSetOptions && (getSetOptions.get || getSetOptions.set)) {\n    if (devMode()) {\n      if (!getSetOptions.get || !getSetOptions.set) {\n        throw fail$1(\"reference options must either contain both a 'get' and a 'set' method or none of them\");\n      }\n    }\n\n    return new CustomReferenceType(subType, {\n      get: getSetOptions.get,\n      set: getSetOptions.set\n    }, onInvalidated);\n  } else {\n    return new IdentifierReferenceType(subType, onInvalidated);\n  }\n}\n/**\n * Returns if a given value represents a reference type.\n *\n * @param type\n * @returns\n */\n\n\nfunction isReferenceType(type) {\n  return (type.flags & TypeFlags.Reference) > 0;\n}\n/**\n * `types.safeReference` - A safe reference is like a standard reference, except that it accepts the undefined value by default\n * and automatically sets itself to undefined (when the parent is a model) / removes itself from arrays and maps\n * when the reference it is pointing to gets detached/destroyed.\n *\n * The optional options parameter object accepts a parameter named `acceptsUndefined`, which is set to true by default, so it is suitable\n * for model properties.\n * When used inside collections (arrays/maps), it is recommended to set this option to false so it can't take undefined as value,\n * which is usually the desired in those cases.\n *\n * Strictly speaking it is a `types.maybe(types.reference(X))` (when `acceptsUndefined` is set to true, the default) and\n * `types.reference(X)` (when `acceptsUndefined` is set to false), both of them with a customized `onInvalidated` option.\n *\n * @param subType\n * @param options\n * @returns\n */\n\n\nfunction safeReference(subType, options) {\n  var refType = reference(subType, __assign(__assign({}, options), {\n    onInvalidated: function (ev) {\n      ev.removeRef();\n    }\n  }));\n\n  if (options && options.acceptsUndefined === false) {\n    return refType;\n  } else {\n    return maybe(refType);\n  }\n}\n\nvar BaseIdentifierType =\n/** @class */\nfunction (_super) {\n  __extends(BaseIdentifierType, _super);\n\n  function BaseIdentifierType(name, validType) {\n    var _this = _super.call(this, name) || this;\n\n    _this.validType = validType;\n    _this.flags = TypeFlags.Identifier;\n    return _this;\n  }\n\n  BaseIdentifierType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    if (!parent || !(parent.type instanceof ModelType)) throw fail$1(\"Identifier types can only be instantiated as direct child of a model type\");\n    return createScalarNode(this, parent, subpath, environment, initialValue);\n  };\n\n  BaseIdentifierType.prototype.reconcile = function (current, newValue, parent, subpath) {\n    // we don't consider detaching here since identifier are scalar nodes, and scalar nodes cannot be detached\n    if (current.storedValue !== newValue) throw fail$1(\"Tried to change identifier from '\" + current.storedValue + \"' to '\" + newValue + \"'. Changing identifiers is not allowed.\");\n    current.setParent(parent, subpath);\n    return current;\n  };\n\n  BaseIdentifierType.prototype.isValidSnapshot = function (value, context) {\n    if (typeof value !== this.validType) {\n      return typeCheckFailure(context, value, \"Value is not a valid \" + this.describe() + \", expected a \" + this.validType);\n    }\n\n    return typeCheckSuccess();\n  };\n\n  return BaseIdentifierType;\n}(SimpleType);\n/**\n * @internal\n * @hidden\n */\n\n\nvar IdentifierType =\n/** @class */\nfunction (_super) {\n  __extends(IdentifierType, _super);\n\n  function IdentifierType() {\n    var _this = _super.call(this, \"identifier\", \"string\") || this;\n\n    _this.flags = TypeFlags.Identifier;\n    return _this;\n  }\n\n  IdentifierType.prototype.describe = function () {\n    return \"identifier\";\n  };\n\n  return IdentifierType;\n}(BaseIdentifierType);\n/**\n * @internal\n * @hidden\n */\n\n\nvar IdentifierNumberType =\n/** @class */\nfunction (_super) {\n  __extends(IdentifierNumberType, _super);\n\n  function IdentifierNumberType() {\n    return _super.call(this, \"identifierNumber\", \"number\") || this;\n  }\n\n  IdentifierNumberType.prototype.getSnapshot = function (node) {\n    return node.storedValue;\n  };\n\n  IdentifierNumberType.prototype.describe = function () {\n    return \"identifierNumber\";\n  };\n\n  return IdentifierNumberType;\n}(BaseIdentifierType);\n/**\n * `types.identifier` - Identifiers are used to make references, lifecycle events and reconciling works.\n * Inside a state tree, for each type can exist only one instance for each given identifier.\n * For example there couldn't be 2 instances of user with id 1. If you need more, consider using references.\n * Identifier can be used only as type property of a model.\n * This type accepts as parameter the value type of the identifier field that can be either string or number.\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifier,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\n\n\nvar identifier = new IdentifierType();\n/**\n * `types.identifierNumber` - Similar to `types.identifier`. This one will serialize from / to a number when applying snapshots\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifierNumber,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\n\nvar identifierNumber = new IdentifierNumberType();\n/**\n * Returns if a given value represents an identifier type.\n *\n * @param type\n * @returns\n */\n\nfunction isIdentifierType(type) {\n  return isType(type) && (type.flags & TypeFlags.Identifier) > 0;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction normalizeIdentifier(id) {\n  return \"\" + id;\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction isValidIdentifier(id) {\n  return typeof id === \"string\" || typeof id === \"number\";\n}\n/**\n * @internal\n * @hidden\n */\n\n\nfunction assertIsValidIdentifier(id, argNumber) {\n  assertArg(id, isValidIdentifier, \"string or number (identifier)\", argNumber);\n}\n/**\n * `types.custom` - Creates a custom type. Custom types can be used for arbitrary immutable values, that have a serializable representation. For example, to create your own Date representation, Decimal type etc.\n *\n * The signature of the options is:\n * ```ts\n * export interface CustomTypeOptions<S, T> {\n *     // Friendly name\n *     name: string\n *     // given a serialized value and environment, how to turn it into the target type\n *     fromSnapshot(snapshot: S, env: any): T\n *     // return the serialization of the current value\n *     toSnapshot(value: T): S\n *     // if true, this is a converted value, if false, it's a snapshot\n *     isTargetType(value: T | S): value is T\n *     // a non empty string is assumed to be a validation error\n *     getValidationMessage?(snapshot: S): string\n * }\n * ```\n *\n * Example:\n * ```ts\n * const DecimalPrimitive = types.custom<string, Decimal>({\n *     name: \"Decimal\",\n *     fromSnapshot(value: string) {\n *         return new Decimal(value)\n *     },\n *     toSnapshot(value: Decimal) {\n *         return value.toString()\n *     },\n *     isTargetType(value: string | Decimal): boolean {\n *         return value instanceof Decimal\n *     },\n *     getValidationMessage(value: string): string {\n *         if (/^-?\\d+\\.\\d+$/.test(value)) return \"\" // OK\n *         return `'${value}' doesn't look like a valid decimal number`\n *     }\n * })\n *\n * const Wallet = types.model({\n *     balance: DecimalPrimitive\n * })\n * ```\n *\n * @param options\n * @returns\n */\n\n\nfunction custom(options) {\n  return new CustomType(options);\n}\n/**\n * @internal\n * @hidden\n */\n\n\nvar CustomType =\n/** @class */\nfunction (_super) {\n  __extends(CustomType, _super);\n\n  function CustomType(options) {\n    var _this = _super.call(this, options.name) || this;\n\n    _this.options = options;\n    _this.flags = TypeFlags.Custom;\n    return _this;\n  }\n\n  CustomType.prototype.describe = function () {\n    return this.name;\n  };\n\n  CustomType.prototype.isValidSnapshot = function (value, context) {\n    if (this.options.isTargetType(value)) return typeCheckSuccess();\n    var typeError = this.options.getValidationMessage(value);\n\n    if (typeError) {\n      return typeCheckFailure(context, value, \"Invalid value for type '\" + this.name + \"': \" + typeError);\n    }\n\n    return typeCheckSuccess();\n  };\n\n  CustomType.prototype.getSnapshot = function (node) {\n    return this.options.toSnapshot(node.storedValue);\n  };\n\n  CustomType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n    var valueToStore = this.options.isTargetType(initialValue) ? initialValue : this.options.fromSnapshot(initialValue, parent && parent.root.environment);\n    return createScalarNode(this, parent, subpath, environment, valueToStore);\n  };\n\n  CustomType.prototype.reconcile = function (current, value, parent, subpath) {\n    var isSnapshot = !this.options.isTargetType(value); // in theory customs use scalar nodes which cannot be detached, but still...\n\n    if (!current.isDetaching) {\n      var unchanged = current.type === this && (isSnapshot ? value === current.snapshot : value === current.storedValue);\n\n      if (unchanged) {\n        current.setParent(parent, subpath);\n        return current;\n      }\n    }\n\n    var valueToStore = isSnapshot ? this.options.fromSnapshot(value, parent.root.environment) : value;\n    var newNode = this.instantiate(parent, subpath, undefined, valueToStore);\n    current.die(); // noop if detaching\n\n    return newNode;\n  };\n\n  return CustomType;\n}(SimpleType); // we import the types to re-export them inside types.\n\n\nvar types = {\n  enumeration: enumeration,\n  model: model,\n  compose: compose,\n  custom: custom,\n  reference: reference,\n  safeReference: safeReference,\n  union: union,\n  optional: optional,\n  literal: literal,\n  maybe: maybe,\n  maybeNull: maybeNull,\n  refinement: refinement,\n  string: string,\n  boolean: boolean,\n  number: number,\n  integer: integer,\n  Date: DatePrimitive,\n  map: map,\n  array: array,\n  frozen: frozen,\n  identifier: identifier,\n  identifierNumber: identifierNumber,\n  late: late,\n  undefined: undefinedType,\n  null: nullType,\n  snapshotProcessor: snapshotProcessor\n};\nexport { addDisposer, addMiddleware, applyAction, applyPatch, applySnapshot, cast, castFlowReturn, castToReferenceSnapshot, castToSnapshot, clone, createActionTrackingMiddleware, createActionTrackingMiddleware2, decorate, destroy, detach, escapeJsonPath, flow, getChildType, getEnv, getIdentifier, getLivelinessChecking, getMembers, getNodeId, getParent, getParentOfType, getPath, getPathParts, getPropertyMembers, getRelativePath, getRoot, getRunningActionContext, getSnapshot, getType, hasParent, hasParentOfType, isActionContextChildOf, isActionContextThisOrChildOf, isAlive, isArrayType, isFrozenType, isIdentifierType, isLateType, isLiteralType, isMapType, isModelType, isOptionalType, isPrimitiveType, isProtected, isReferenceType, isRefinementType, isRoot, isStateTreeNode, isType, isUnionType, isValidReference, joinJsonPath, onAction, onPatch, onSnapshot, process$1 as process, protect, recordActions, recordPatches, resolveIdentifier, resolvePath, setLivelinessChecking, setLivelynessChecking, splitJsonPath, tryReference, tryResolve, typecheck, types, unescapeJsonPath, unprotect, walk };","map":{"version":3,"sources":["/mnt/c/users/james/desktop/dev_tools/environment/src/job-hunter-app/node_modules/mobx-state-tree/dist/mobx-state-tree.module.js"],"names":["isComputedProp","isObservableProp","createAtom","action","_allowStateChangesInsideComputed","reaction","computed","runInAction","observable","values","entries","isObservableArray","$mobx","getAtom","ObservableMap","_interceptReads","intercept","observe","_getAdministration","set","livelinessChecking","setLivelinessChecking","mode","getLivelinessChecking","setLivelynessChecking","Hook","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__rest","e","indexOf","getOwnPropertySymbols","propertyIsEnumerable","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__values","o","m","Symbol","iterator","next","value","done","__read","ar","push","error","__spread","concat","getType","object","assertIsStateTreeNode","getStateTreeNode","type","getChildType","propertyName","onPatch","callback","assertIsFunction","onSnapshot","applyPatch","patch","assertArg","applyPatches","asArray","recordPatches","subject","filter","data","patches","reversedInversePatches","publicData","disposer","recorder","recording","slice","inversePatches","reverse","stop","undefined","resume","inversePatch","getRunningActionContext","unshift","replay","undo","protect","node","isRoot","fail$1","isProtectionEnabled","unprotect","isProtected","applySnapshot","snapshot","getSnapshot","applyPostProcess","freeze","hasParent","depth","assertIsNumber","parent","getParent","storedValue","hasParentOfType","assertIsType","is","getParentOfType","getRoot","root","getPath","path","getPathParts","splitJsonPath","resolvePath","assertIsString","resolveNodeByPath","resolveIdentifier","identifier","assertIsValidIdentifier","identifierCache","resolve","normalizeIdentifier","getIdentifier","tryReference","getter","checkIfAlive","isStateTreeNode","isAlive","InvalidReferenceError","isValidReference","tryResolve","getRelativePath","base","getRelativePathBetweenNodes","clone","source","keepEnvironment","environment","detach","destroy","die","removeChild","subpath","observableIsAlive","addDisposer","getEnv","env","EMPTY_OBJECT","walk","processor","getChildren","forEach","child","getPropertyMembers","typeOrNode","isModelType","name","properties","getMembers","reflected","actions","volatile","views","props","getOwnPropertyNames","descriptor","get","_isMSTAction","cast","snapshotOrInstance","castToSnapshot","castToReferenceSnapshot","instance","getNodeId","nodeId","BaseNode","_state","NodeLifeCycle","INITIALIZING","baseSetParent","_subpath","enumerable","configurable","_subpathUponDeath","_pathUponDeath","getValue","val","wasAlive","aliveAtom","reportChanged","fireInternalHook","_hookSubscribers","emit","registerHook","hook","hookHandler","EventHandlers","register","_parent","_escapedSubpath","pathAtom","getEscapedPath","reportObserved","escapeJsonPath","state","DEAD","DETACHING","baseFinalizeCreation","whenFinalized","devMode","fail","CREATED","FINALIZED","fireHook","afterAttach","baseFinalizeDeath","clearAll","baseAboutToDie","beforeDestroy","ScalarNode","_super","simpleType","initialSnapshot","_this","createNewInstance","finalizeCreation","setParent","newParent","parentChanged","subpathChanged","toString","pathUponDeath","aboutToDie","finalizeDeath","nextNodeId","snapshotReactionOptions","onError","ObjectNode","complexType","initialValue","_autoUnbox","_isRunningAction","_hasSnapshotReaction","_observableInstanceState","_cachedInitialSnapshotCreated","unbox","bind","_initialSnapshot","identifierAttribute","IdentifierCache","_childNodes","initializeChildNodes","unnormalizedIdentifier","id","childNode","addNodeToCache","createObservableInstanceIfNeeded","_applyPatches","_applySnapshot","createObservableInstance","e_1","_a","parentChain","parentChain_1","parentChain_1_1","e_1_1","return","preboot","finalizeNewInstance","invalidateComputed","_addSnapshotReaction","afterCreate","clearParent","beforeDetach","previousState","newEnv","newIdCache","splitCache","mergeCache","fn","_snapshotUponDeath","_getActualSnapshot","_getCachedInitialSnapshot","childNodes","_cachedInitialSnapshot","processInitialSnapshot","isRunningAction","assertAlive","context","_getAssertAliveError","warnError","escapedPath","actionContext","getCurrentActionContext","parentActionEvent","actionFullPath","actionPath","getChildNode","convertChildNodesToArray","assertWritable","subpathUponDeath","e_2","_b","_c","e_2_1","afterCreationFinalization","self","createActionInvoker","parts","resolveNodeByPathParts","applyPatchLocally","addHiddenFinalProp","toJSON","_internalEventsEmit","_internalEventsClear","notifyDied","_internalEventsClearAll","onChange","_internalEventsRegister","emitSnapshot","handler","emitPatch","basePatch","_internalEventsHasSubscribers","localizedPatch","extend","substr","splitPatch","reversePatch","hasDisposer","_internalEventsHas","removeDisposer","_internalEventsUnregister","removeMiddleware","middleware","middlewares","index","splice","addMiddleWare","includeHooks","snapshotDisposer","event","_internalEvents","hasSubscribers","eventHandler","atTheBeginning","has","unregister","args","_i","clear","TypeFlags","cannotDetermineSubtype","BaseType","isType","typecheckInternal","instantiate","isAssignableFrom","validate","getStateTreeNodeSafe","valueType","typeCheckSuccess","typeCheckFailure","isValidSnapshot","thing","ComplexType","getDefaultSnapshot","tryToReconcileNode","current","newValue","isDetaching","isMutable","reconcile","nodeReconciled","newNode","getSubTypes","SimpleType","res","argNumber","runningActions","Map","createActionTrackingMiddleware","hooks","actionTrackingMiddleware","abort","onStart","onResume","async","onSuspend","delete","onSuccess","onFail","rootId","RunningAction","flowsPending","running","finish","onFinish","incFlowsPending","decFlowsPending","createActionTrackingMiddleware2","middlewareHooks","WeakMap","parentRunningAction","newCall","parentCall","passesFilter","runningAction","hasFlowsPending","serializeArgument","actionName","arg","Date","$MST_DATE","getTime","isPrimitive","serializeTheUnserializable","isPlainObject","isArray","JSON","stringify","deserializeArgument","adm","baseType","$MST_UNSERIALIZABLE","applyAction","a","baseApplyAction","resolvedTarget","map","v","recordActions","listener","recordThis","onAction","attachAfter","addMiddleware","rawCall","sourceNode_1","info","nextActionId","currentActionContext","getNextActionId","runWithActionContext","baseIsRunningAction","previousContext","runMiddleWares","getParentActionContext","parentContext","parentActionContext","argsToArray","tree","parentId","allParentIds","parentEvent","$mst_middleware","CollectedMiddlewares","arrayIndex","inArrayIndex","getNextMiddleware","array","item","baseCall","originalFn","isEmpty","result","runNextMiddleware","nextInvoked","call2","abortInvoked","node2","_isActionContextThisOrChildOf","sameOrParent","includeSame","isActionContextChildOf","isActionContextThisOrChildOf","parentOrThis","safeStringify","prettyPrintValue","shortenPrintValue","valueInString","substring","toErrorString","fullPath","join","pathPrefix","currentTypename","isSnapshotCompatible","message","isPrimitiveType","describe","getContextForPath","EMPTY_ARRAY","flattenTypeErrors","errors","reduce","isTypeCheckingEnabled","typecheck","validationErrorsToString","identifierCacheId","cacheId","cache","lastCacheModificationPerId","updateLastCacheModificationPerId","lcm","getLastCacheModificationPerId","modificationId","lastCacheUpdate","mobxShallow","nodes","remove","basePath","modified","some","candidate","matches","createObjectNode","existingNode","createScalarNode","isNode","$treenode","doubleDot","_","baseParts","targetParts","common","joinJsonPath","failIfResolveFails","pathParts","part","subType","keys","DEPRECATION_MESSAGE","process$1","asyncAction","deprecated","flow","deep","proxy","Error","identity","isInteger","Number","isFinite","Math","floor","proto","getPrototypeOf","RegExp","includeDate","deepFreeze","propKey","isFrozen","isSerializable","propName","writable","addHiddenWritableProp","EventHandler","handlers","f","eventHandlers","atom","trackAndCompute","stringStartsWith","str","beginning","ids","msg","console","warn","process","ENABLE_TYPE_CHECK","NODE_ENV","typeName","min","max","canBeEmpty","setImmediateWithFallback","queueMicrotask","setImmediate","setTimeout","generator","createFlowSpawner","castFlowReturn","spawner","flowSpawner","runId","contextBase","wrap","Promise","reject","gen","init","asyncActionInit","onFulfilled","ret","onRejected","err","throw","then","stripPatch","invertPatch","op","oldValue","isNumber","x","replace","unescapeJsonPath","getPathStr","split","valid","shift","SnapshotProcessor","_subtype","_processors","flags","preProcessSnapshot","sn","preProcessor","postProcessSnapshot","postProcessor","_fixNode","proxyNodeTypeMethods","oldGetSnapshot","processedInitialValue","processedSn","nodeType","snapshotProcessorType","methods","methods_1","methods_1_1","method","snapshotProcessor","processors","needsIdentifierError","tryCollectModelTypes","modelTypes","subtypes","subtypesArray","subtypesArray_1","subtypesArray_1_1","subtype","ModelType","MapIdentifierMode","MSTMap","initialData","ref","enhancer","put","mapNode","mapType","identifierMode","YES","idAttr","mapIdentifierAttribute","isValidIdentifier","MapType","_subType","hookInitializers","UNKNOWN","_determineIdentifierMode","identifierAttribute_1","NO","objNode","initializer","actionInvoker","willChange","didChange","change","processIdentifier","expected","processed","oldSnapshot","currentKeys","from","isMapType","ArrayType","dehancer","updatedNodes","reconcileArrayChildren","index_1","removedCount","added","addedNodes","removed","addedCount","childType","oldNodes","newValues","newPaths","nothingChanged","hasNewNode","oldNode","newPath","valueAsNode","areSame","oldMatch","j","getNewNode","isArrayType","PRE_PROCESS_SNAPSHOT","POST_PROCESS_SNAPSHOT","objectTypeToString","defaultObjectOptions","initializers","toPropertiesObject","declaredProps","optional","getPrimitiveFactoryFromValue","opts","named","cloneAndEnhance","currentPreprocessor","currentPostprocessor","propertyNames","_getIdentifierAttribute","forAllProps","propType","Identifier","actionInitializer","instantiateActions","action2","baseAction","specializedAction_1","boundAction","stateInitializer","instantiateVolatileState","rest","instantiateViews","viewInitializer","computedValue","derivation","scope","setter","applySnapshotPreProcessor","chg","oldChildValue","applySnapshotPostProcessor","preProcessedSnapshot","model","compose","hasTypename","prev","cur","CoreType","checker","string","String","number","integer","Integer","boolean","Boolean","nullType","Null","undefinedType","Undefined","_DatePrimitive","DatePrimitive","Literal","literal","isLiteralType","Refinement","_predicate","_message","subtypeErrors","refinement","predicate","isRefinementType","enumeration","options","realOptions","option","union","Union","_types","_eager","eager","dispatcher","_dispatcher","factory","determineType","reconcileCurrentType","find","allErrors","applicableTypes","optionsOrType","otherTypes","types","isUnionType","OptionalValue","_defaultValue","optionalValues","Optional","defaultInstanceOrSnapshot","getDefaultInstanceOrSnapshot","checkOptionalPreconditions","defaultValueOrFunction","undefinedAsOptionalValues","isOptionalType","optionalUndefinedType","optionalNullType","maybe","maybeNull","Late","_definition","getSubType","mustSucceed","ReferenceError","late","nameOrType","maybeType","isLateType","Frozen","untypedFrozenInstance","frozen","isFrozenType","getInvalidationCause","StoredReference","targetType","targetNode","updateResolvedReference","normalizedId","lastCacheModification","resolvedReference","BaseReferenceType","onInvalidated","Reference","fireInvalidated","cause","storedRefNode","referenceId","refTargetNode","storedRefParentNode","storedRefParentValue","invalidTarget","invalidId","replaceRef","newRef","removeRef","addTargetNodeWatcher","refTargetValue","refTargetNodeHook","refTargetDetachHookDisposer","refTargetDestroyHookDisposer","watchTargetNodeForInvalidations","customGetSet","onRefTargetDestroyedHookDisposer","startWatching","sync","refTargetNodeExists","IdentifierReferenceType","storedRef","resolvedValue","compareByValue","CustomReferenceType","referencedNode","newIdentifier","reference","getSetOptions","isReferenceType","safeReference","refType","ev","acceptsUndefined","BaseIdentifierType","validType","IdentifierType","IdentifierNumberType","identifierNumber","isIdentifierType","custom","CustomType","Custom","isTargetType","typeError","getValidationMessage","toSnapshot","valueToStore","fromSnapshot","isSnapshot","unchanged","null"],"mappings":"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","sourcesContent":["import { isComputedProp, isObservableProp, createAtom, action, _allowStateChangesInsideComputed, reaction, computed, runInAction, observable, values, entries, isObservableArray, $mobx, getAtom, ObservableMap, _interceptReads, intercept, observe, _getAdministration, set } from 'mobx';\n\nvar livelinessChecking = \"warn\";\n/**\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction setLivelinessChecking(mode) {\n    livelinessChecking = mode;\n}\n/**\n * Returns the current liveliness checking mode.\n *\n * @returns `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction getLivelinessChecking() {\n    return livelinessChecking;\n}\n/**\n * @deprecated use setLivelinessChecking instead\n * @hidden\n *\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction setLivelynessChecking(mode) {\n    setLivelinessChecking(mode);\n}\n\n/**\n * @hidden\n */\nvar Hook;\n(function (Hook) {\n    Hook[\"afterCreate\"] = \"afterCreate\";\n    Hook[\"afterAttach\"] = \"afterAttach\";\n    Hook[\"afterCreationFinalization\"] = \"afterCreationFinalization\";\n    Hook[\"beforeDetach\"] = \"beforeDetach\";\n    Hook[\"beforeDestroy\"] = \"beforeDestroy\";\n})(Hook || (Hook = {}));\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\n/**\n * Returns the _actual_ type of the given tree node. (Or throws)\n *\n * @param object\n * @returns\n */\nfunction getType(object) {\n    assertIsStateTreeNode(object, 1);\n    return getStateTreeNode(object).type;\n}\n/**\n * Returns the _declared_ type of the given sub property of an object, array or map.\n * In the case of arrays and maps the property name is optional and will be ignored.\n *\n * Example:\n * ```ts\n * const Box = types.model({ x: 0, y: 0 })\n * const box = Box.create()\n *\n * console.log(getChildType(box, \"x\").name) // 'number'\n * ```\n *\n * @param object\n * @param propertyName\n * @returns\n */\nfunction getChildType(object, propertyName) {\n    assertIsStateTreeNode(object, 1);\n    return getStateTreeNode(object).getChildType(propertyName);\n}\n/**\n * Registers a function that will be invoked for each mutation that is applied to the provided model instance, or to any of its children.\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details. onPatch events are emitted immediately and will not await the end of a transaction.\n * Patches can be used to deep observe a model tree.\n *\n * @param target the model instance from which to receive patches\n * @param callback the callback that is invoked for each patch. The reversePatch is a patch that would actually undo the emitted patch\n * @returns function to remove the listener\n */\nfunction onPatch(target, callback) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(callback, 2);\n    return getStateTreeNode(target).onPatch(callback);\n}\n/**\n * Registers a function that is invoked whenever a new snapshot for the given model instance is available.\n * The listener will only be fire at the end of the current MobX (trans)action.\n * See [snapshots](https://github.com/mobxjs/mobx-state-tree#snapshots) for more details.\n *\n * @param target\n * @param callback\n * @returns\n */\nfunction onSnapshot(target, callback) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(callback, 2);\n    return getStateTreeNode(target).onSnapshot(callback);\n}\n/**\n * Applies a JSON-patch to the given model instance or bails out if the patch couldn't be applied\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details.\n *\n * Can apply a single past, or an array of patches.\n *\n * @param target\n * @param patch\n * @returns\n */\nfunction applyPatch(target, patch) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertArg(patch, function (p) { return typeof p === \"object\"; }, \"object or array\", 2);\n    getStateTreeNode(target).applyPatches(asArray(patch));\n}\n/**\n * Small abstraction around `onPatch` and `applyPatch`, attaches a patch listener to a tree and records all the patches.\n * Returns an recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IPatchRecorder {\n *      // the recorded patches\n *      patches: IJsonPatch[]\n *      // the inverse of the recorded patches\n *      inversePatches: IJsonPatch[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording patches\n *      stop(): void\n *      // resume recording patches\n *      resume(): void\n *      // apply all the recorded patches on the given target (the original subject if omitted)\n *      replay(target?: IAnyStateTreeNode): void\n *      // reverse apply the recorded patches on the given target  (the original subject if omitted)\n *      // stops the recorder if not already stopped\n *      undo(): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain patches.\n *\n * @param subject\n * @param filter\n * @returns\n */\nfunction recordPatches(subject, filter) {\n    // check all arguments\n    assertIsStateTreeNode(subject, 1);\n    var data = {\n        patches: [],\n        reversedInversePatches: []\n    };\n    // we will generate the immutable copy of patches on demand for public consumption\n    var publicData = {};\n    var disposer;\n    var recorder = {\n        get recording() {\n            return !!disposer;\n        },\n        get patches() {\n            if (!publicData.patches) {\n                publicData.patches = data.patches.slice();\n            }\n            return publicData.patches;\n        },\n        get reversedInversePatches() {\n            if (!publicData.reversedInversePatches) {\n                publicData.reversedInversePatches = data.reversedInversePatches.slice();\n            }\n            return publicData.reversedInversePatches;\n        },\n        get inversePatches() {\n            if (!publicData.inversePatches) {\n                publicData.inversePatches = data.reversedInversePatches.slice().reverse();\n            }\n            return publicData.inversePatches;\n        },\n        stop: function () {\n            if (disposer) {\n                disposer();\n                disposer = undefined;\n            }\n        },\n        resume: function () {\n            if (disposer)\n                return;\n            disposer = onPatch(subject, function (patch, inversePatch) {\n                // skip patches that are asked to be filtered if there's a filter in place\n                if (filter && !filter(patch, inversePatch, getRunningActionContext())) {\n                    return;\n                }\n                data.patches.push(patch);\n                data.reversedInversePatches.unshift(inversePatch);\n                // mark immutable public patches as dirty\n                publicData.patches = undefined;\n                publicData.inversePatches = undefined;\n                publicData.reversedInversePatches = undefined;\n            });\n        },\n        replay: function (target) {\n            applyPatch(target || subject, data.patches);\n        },\n        undo: function (target) {\n            applyPatch(target || subject, data.reversedInversePatches);\n        }\n    };\n    recorder.resume();\n    return recorder;\n}\n/**\n * The inverse of `unprotect`.\n *\n * @param target\n */\nfunction protect(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    var node = getStateTreeNode(target);\n    if (!node.isRoot)\n        throw fail$1(\"`protect` can only be invoked on root nodes\");\n    node.isProtectionEnabled = true;\n}\n/**\n * By default it is not allowed to directly modify a model. Models can only be modified through actions.\n * However, in some cases you don't care about the advantages (like replayability, traceability, etc) this yields.\n * For example because you are building a PoC or don't have any middleware attached to your tree.\n *\n * In that case you can disable this protection by calling `unprotect` on the root of your tree.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *     done: false\n * }).actions(self => ({\n *     toggle() {\n *         self.done = !self.done\n *     }\n * }))\n *\n * const todo = Todo.create()\n * todo.done = true // throws!\n * todo.toggle() // OK\n * unprotect(todo)\n * todo.done = false // OK\n * ```\n */\nfunction unprotect(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    var node = getStateTreeNode(target);\n    if (!node.isRoot)\n        throw fail$1(\"`unprotect` can only be invoked on root nodes\");\n    node.isProtectionEnabled = false;\n}\n/**\n * Returns true if the object is in protected mode, @see protect\n */\nfunction isProtected(target) {\n    return getStateTreeNode(target).isProtected;\n}\n/**\n * Applies a snapshot to a given model instances. Patch and snapshot listeners will be invoked as usual.\n *\n * @param target\n * @param snapshot\n * @returns\n */\nfunction applySnapshot(target, snapshot) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).applySnapshot(snapshot);\n}\n/**\n * Calculates a snapshot from the given model instance. The snapshot will always reflect the latest state but use\n * structural sharing where possible. Doesn't require MobX transactions to be completed.\n *\n * @param target\n * @param applyPostProcess If true (the default) then postProcessSnapshot gets applied.\n * @returns\n */\nfunction getSnapshot(target, applyPostProcess) {\n    if (applyPostProcess === void 0) { applyPostProcess = true; }\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    var node = getStateTreeNode(target);\n    if (applyPostProcess)\n        return node.snapshot;\n    return freeze(node.type.getSnapshot(node, false));\n}\n/**\n * Given a model instance, returns `true` if the object has a parent, that is, is part of another object, map or array.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\nfunction hasParent(target, depth) {\n    if (depth === void 0) { depth = 1; }\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsNumber(depth, 2, 0);\n    var parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (--depth === 0)\n            return true;\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the immediate parent of this object, or throws.\n *\n * Note that the immediate parent can be either an object, map or array, and\n * doesn't necessarily refer to the parent model.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\nfunction getParent(target, depth) {\n    if (depth === void 0) { depth = 1; }\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsNumber(depth, 2, 0);\n    var d = depth;\n    var parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (--d === 0)\n            return parent.storedValue;\n        parent = parent.parent;\n    }\n    throw fail$1(\"Failed to find the parent of \" + getStateTreeNode(target) + \" at depth \" + depth);\n}\n/**\n * Given a model instance, returns `true` if the object has a parent of given type, that is, is part of another object, map or array\n *\n * @param target\n * @param type\n * @returns\n */\nfunction hasParentOfType(target, type) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsType(type, 2);\n    var parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (type.is(parent.storedValue))\n            return true;\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the target's parent of a given type, or throws.\n *\n * @param target\n * @param type\n * @returns\n */\nfunction getParentOfType(target, type) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsType(type, 2);\n    var parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (type.is(parent.storedValue))\n            return parent.storedValue;\n        parent = parent.parent;\n    }\n    throw fail$1(\"Failed to find the parent of \" + getStateTreeNode(target) + \" of a given type\");\n}\n/**\n * Given an object in a model tree, returns the root object of that tree.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @returns\n */\nfunction getRoot(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).root.storedValue;\n}\n/**\n * Returns the path of the given object in the model tree\n *\n * @param target\n * @returns\n */\nfunction getPath(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).path;\n}\n/**\n * Returns the path of the given object as unescaped string array.\n *\n * @param target\n * @returns\n */\nfunction getPathParts(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return splitJsonPath(getStateTreeNode(target).path);\n}\n/**\n * Returns true if the given object is the root of a model tree.\n *\n * @param target\n * @returns\n */\nfunction isRoot(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).isRoot;\n}\n/**\n * Resolves a path relatively to a given object.\n * Returns undefined if no value can be found.\n *\n * @param target\n * @param path escaped json path\n * @returns\n */\nfunction resolvePath(target, path) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsString(path, 2);\n    var node = resolveNodeByPath(getStateTreeNode(target), path);\n    return node ? node.value : undefined;\n}\n/**\n * Resolves a model instance given a root target, the type and the identifier you are searching for.\n * Returns undefined if no value can be found.\n *\n * @param type\n * @param target\n * @param identifier\n * @returns\n */\nfunction resolveIdentifier(type, target, identifier) {\n    // check all arguments\n    assertIsType(type, 1);\n    assertIsStateTreeNode(target, 2);\n    assertIsValidIdentifier(identifier, 3);\n    var node = getStateTreeNode(target).root.identifierCache.resolve(type, normalizeIdentifier(identifier));\n    return node ? node.value : undefined;\n}\n/**\n * Returns the identifier of the target node.\n * This is the *string normalized* identifier, which might not match the type of the identifier attribute\n *\n * @param target\n * @returns\n */\nfunction getIdentifier(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).identifier;\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns such reference if it the check passes,\n * else it returns undefined.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\nfunction tryReference(getter, checkIfAlive) {\n    if (checkIfAlive === void 0) { checkIfAlive = true; }\n    try {\n        var node = getter();\n        if (node === undefined || node === null) {\n            return undefined;\n        }\n        else if (isStateTreeNode(node)) {\n            if (!checkIfAlive) {\n                return node;\n            }\n            else {\n                return isAlive(node) ? node : undefined;\n            }\n        }\n        else {\n            throw fail$1(\"The reference to be checked is not one of node, null or undefined\");\n        }\n    }\n    catch (e) {\n        if (e instanceof InvalidReferenceError) {\n            return undefined;\n        }\n        throw e;\n    }\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns if the check passes or not.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\nfunction isValidReference(getter, checkIfAlive) {\n    if (checkIfAlive === void 0) { checkIfAlive = true; }\n    try {\n        var node = getter();\n        if (node === undefined || node === null) {\n            return false;\n        }\n        else if (isStateTreeNode(node)) {\n            return checkIfAlive ? isAlive(node) : true;\n        }\n        else {\n            throw fail$1(\"The reference to be checked is not one of node, null or undefined\");\n        }\n    }\n    catch (e) {\n        if (e instanceof InvalidReferenceError) {\n            return false;\n        }\n        throw e;\n    }\n}\n/**\n * Try to resolve a given path relative to a given node.\n *\n * @param target\n * @param path\n * @returns\n */\nfunction tryResolve(target, path) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsString(path, 2);\n    var node = resolveNodeByPath(getStateTreeNode(target), path, false);\n    if (node === undefined)\n        return undefined;\n    try {\n        return node.value;\n    }\n    catch (e) {\n        // For what ever reason not resolvable (e.g. totally not existing path, or value that cannot be fetched)\n        // see test / issue: 'try resolve doesn't work #686'\n        return undefined;\n    }\n}\n/**\n * Given two state tree nodes that are part of the same tree,\n * returns the shortest jsonpath needed to navigate from the one to the other\n *\n * @param base\n * @param target\n * @returns\n */\nfunction getRelativePath(base, target) {\n    // check all arguments\n    assertIsStateTreeNode(base, 1);\n    assertIsStateTreeNode(target, 2);\n    return getRelativePathBetweenNodes(getStateTreeNode(base), getStateTreeNode(target));\n}\n/**\n * Returns a deep copy of the given state tree node as new tree.\n * Short hand for `snapshot(x) = getType(x).create(getSnapshot(x))`\n *\n * _Tip: clone will create a literal copy, including the same identifiers. To modify identifiers etc during cloning, don't use clone but take a snapshot of the tree, modify it, and create new instance_\n *\n * @param source\n * @param keepEnvironment indicates whether the clone should inherit the same environment (`true`, the default), or not have an environment (`false`). If an object is passed in as second argument, that will act as the environment for the cloned tree.\n * @returns\n */\nfunction clone(source, keepEnvironment) {\n    if (keepEnvironment === void 0) { keepEnvironment = true; }\n    // check all arguments\n    assertIsStateTreeNode(source, 1);\n    var node = getStateTreeNode(source);\n    return node.type.create(node.snapshot, keepEnvironment === true\n        ? node.root.environment\n        : keepEnvironment === false\n            ? undefined\n            : keepEnvironment); // it's an object or something else\n}\n/**\n * Removes a model element from the state tree, and let it live on as a new state tree\n */\nfunction detach(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    getStateTreeNode(target).detach();\n    return target;\n}\n/**\n * Removes a model element from the state tree, and mark it as end-of-life; the element should not be used anymore\n */\nfunction destroy(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    var node = getStateTreeNode(target);\n    if (node.isRoot)\n        node.die();\n    else\n        node.parent.removeChild(node.subpath);\n}\n/**\n * Returns true if the given state tree node is not killed yet.\n * This means that the node is still a part of a tree, and that `destroy`\n * has not been called. If a node is not alive anymore, the only thing one can do with it\n * is requesting it's last path and snapshot\n *\n * @param target\n * @returns\n */\nfunction isAlive(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).observableIsAlive;\n}\n/**\n * Use this utility to register a function that should be called whenever the\n * targeted state tree node is destroyed. This is a useful alternative to managing\n * cleanup methods yourself using the `beforeDestroy` hook.\n *\n * This methods returns the same disposer that was passed as argument.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string\n * }).actions(self => ({\n *   afterCreate() {\n *     const autoSaveDisposer = reaction(\n *       () => getSnapshot(self),\n *       snapshot => sendSnapshotToServerSomehow(snapshot)\n *     )\n *     // stop sending updates to server if this\n *     // instance is destroyed\n *     addDisposer(self, autoSaveDisposer)\n *   }\n * }))\n * ```\n *\n * @param target\n * @param disposer\n * @returns The same disposer that was passed as argument\n */\nfunction addDisposer(target, disposer) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(disposer, 2);\n    var node = getStateTreeNode(target);\n    node.addDisposer(disposer);\n    return disposer;\n}\n/**\n * Returns the environment of the current state tree. For more info on environments,\n * see [Dependency injection](https://github.com/mobxjs/mobx-state-tree#dependency-injection)\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired\n *\n * Returns an empty environment if the tree wasn't initialized with an environment\n *\n * @param target\n * @returns\n */\nfunction getEnv(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    var node = getStateTreeNode(target);\n    var env = node.root.environment;\n    if (!env)\n        return EMPTY_OBJECT;\n    return env;\n}\n/**\n * Performs a depth first walk through a tree.\n */\nfunction walk(target, processor) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(processor, 2);\n    var node = getStateTreeNode(target);\n    // tslint:disable-next-line:no_unused-variable\n    node.getChildren().forEach(function (child) {\n        if (isStateTreeNode(child.storedValue))\n            walk(child.storedValue, processor);\n    });\n    processor(node.storedValue);\n}\n/**\n * Returns a reflection of the model type properties and name for either a model type or model node.\n *\n * @param typeOrNode\n * @returns\n */\nfunction getPropertyMembers(typeOrNode) {\n    var type;\n    if (isStateTreeNode(typeOrNode)) {\n        type = getType(typeOrNode);\n    }\n    else {\n        type = typeOrNode;\n    }\n    assertArg(type, function (t) { return isModelType(t); }, \"model type or model instance\", 1);\n    return {\n        name: type.name,\n        properties: __assign({}, type.properties)\n    };\n}\n/**\n * Returns a reflection of the model node, including name, properties, views, volatile and actions.\n *\n * @param target\n * @returns\n */\nfunction getMembers(target) {\n    var type = getStateTreeNode(target).type;\n    var reflected = __assign(__assign({}, getPropertyMembers(type)), { actions: [], volatile: [], views: [] });\n    var props = Object.getOwnPropertyNames(target);\n    props.forEach(function (key) {\n        if (key in reflected.properties)\n            return;\n        var descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor.get) {\n            if (isComputedProp(target, key))\n                reflected.views.push(key);\n            else\n                reflected.volatile.push(key);\n            return;\n        }\n        if (descriptor.value._isMSTAction === true)\n            reflected.actions.push(key);\n        else if (isObservableProp(target, key))\n            reflected.volatile.push(key);\n        else\n            reflected.views.push(key);\n    });\n    return reflected;\n}\n/**\n * Casts a node snapshot or instance type to an instance type so it can be assigned to a type instance.\n * Note that this is just a cast for the type system, this is, it won't actually convert a snapshot to an instance,\n * but just fool typescript into thinking so.\n * Either way, casting when outside an assignation operation won't compile.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * }).actions(self => ({\n *   someAction() {\n *     // this will allow the compiler to assign a snapshot to the property\n *     self.innerModel = cast({ a: 5 })\n *   }\n * }))\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object casted as an instance\n */\nfunction cast(snapshotOrInstance) {\n    return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to an snapshot type so it can be assigned to a type snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * })\n *\n * const a = ModelA.create({ n: 5 });\n * // this will allow the compiler to use a model as if it were a snapshot\n * const b = ModelB.create({ innerModel: castToSnapshot(a)})\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object casted as an input (creation) snapshot\n */\nfunction castToSnapshot(snapshotOrInstance) {\n    return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to a reference snapshot type so it can be assigned to a refernence snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a refererence snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   id: types.identifier,\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   refA: types.reference(ModelA)\n * })\n *\n * const a = ModelA.create({ id: 'someId', n: 5 });\n * // this will allow the compiler to use a model as if it were a reference snapshot\n * const b = ModelB.create({ refA: castToReference(a)})\n * ```\n *\n * @param instance Instance\n * @returns The same object casted as an reference snapshot (string or number)\n */\nfunction castToReferenceSnapshot(instance) {\n    return instance;\n}\n/**\n * Returns the unique node id (not to be confused with the instance identifier) for a\n * given instance.\n * This id is a number that is unique for each instance.\n *\n * @export\n * @param target\n * @returns\n */\nfunction getNodeId(target) {\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).nodeId;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar BaseNode = /** @class */ (function () {\n    function BaseNode(type, parent, subpath, environment) {\n        this.type = type;\n        this.environment = environment;\n        this._state = NodeLifeCycle.INITIALIZING;\n        this.environment = environment;\n        this.baseSetParent(parent, subpath);\n    }\n    Object.defineProperty(BaseNode.prototype, \"subpath\", {\n        get: function () {\n            return this._subpath;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"subpathUponDeath\", {\n        get: function () {\n            return this._subpathUponDeath;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"pathUponDeath\", {\n        get: function () {\n            return this._pathUponDeath;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"value\", {\n        get: function () {\n            return this.type.getValue(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"state\", {\n        get: function () {\n            return this._state;\n        },\n        set: function (val) {\n            var wasAlive = this.isAlive;\n            this._state = val;\n            var isAlive = this.isAlive;\n            if (this.aliveAtom && wasAlive !== isAlive) {\n                this.aliveAtom.reportChanged();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BaseNode.prototype.fireInternalHook = function (name) {\n        if (this._hookSubscribers) {\n            this._hookSubscribers.emit(name, this, name);\n        }\n    };\n    BaseNode.prototype.registerHook = function (hook, hookHandler) {\n        if (!this._hookSubscribers) {\n            this._hookSubscribers = new EventHandlers();\n        }\n        return this._hookSubscribers.register(hook, hookHandler);\n    };\n    Object.defineProperty(BaseNode.prototype, \"parent\", {\n        get: function () {\n            return this._parent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BaseNode.prototype.baseSetParent = function (parent, subpath) {\n        this._parent = parent;\n        this._subpath = subpath;\n        this._escapedSubpath = undefined; // regenerate when needed\n        if (this.pathAtom) {\n            this.pathAtom.reportChanged();\n        }\n    };\n    Object.defineProperty(BaseNode.prototype, \"path\", {\n        /*\n         * Returns (escaped) path representation as string\n         */\n        get: function () {\n            return this.getEscapedPath(true);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BaseNode.prototype.getEscapedPath = function (reportObserved) {\n        if (reportObserved) {\n            if (!this.pathAtom) {\n                this.pathAtom = createAtom(\"path\");\n            }\n            this.pathAtom.reportObserved();\n        }\n        if (!this.parent)\n            return \"\";\n        // regenerate escaped subpath if needed\n        if (this._escapedSubpath === undefined) {\n            this._escapedSubpath = !this._subpath ? \"\" : escapeJsonPath(this._subpath);\n        }\n        return this.parent.getEscapedPath(reportObserved) + \"/\" + this._escapedSubpath;\n    };\n    Object.defineProperty(BaseNode.prototype, \"isRoot\", {\n        get: function () {\n            return this.parent === null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"isAlive\", {\n        get: function () {\n            return this.state !== NodeLifeCycle.DEAD;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"isDetaching\", {\n        get: function () {\n            return this.state === NodeLifeCycle.DETACHING;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"observableIsAlive\", {\n        get: function () {\n            if (!this.aliveAtom) {\n                this.aliveAtom = createAtom(\"alive\");\n            }\n            this.aliveAtom.reportObserved();\n            return this.isAlive;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BaseNode.prototype.baseFinalizeCreation = function (whenFinalized) {\n        if (devMode()) {\n            if (!this.isAlive) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: cannot finalize the creation of a node that is already dead\");\n            }\n        }\n        // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already\n        if (this.state === NodeLifeCycle.CREATED) {\n            if (this.parent) {\n                if (this.parent.state !== NodeLifeCycle.FINALIZED) {\n                    // parent not ready yet, postpone\n                    return;\n                }\n                this.fireHook(Hook.afterAttach);\n            }\n            this.state = NodeLifeCycle.FINALIZED;\n            if (whenFinalized) {\n                whenFinalized();\n            }\n        }\n    };\n    BaseNode.prototype.baseFinalizeDeath = function () {\n        if (this._hookSubscribers) {\n            this._hookSubscribers.clearAll();\n        }\n        this._subpathUponDeath = this._subpath;\n        this._pathUponDeath = this.getEscapedPath(false);\n        this.baseSetParent(null, \"\");\n        this.state = NodeLifeCycle.DEAD;\n    };\n    BaseNode.prototype.baseAboutToDie = function () {\n        this.fireHook(Hook.beforeDestroy);\n    };\n    return BaseNode;\n}());\n\n/**\n * @internal\n * @hidden\n */\nvar ScalarNode = /** @class */ (function (_super) {\n    __extends(ScalarNode, _super);\n    function ScalarNode(simpleType, parent, subpath, environment, initialSnapshot) {\n        var _this = _super.call(this, simpleType, parent, subpath, environment) || this;\n        try {\n            _this.storedValue = simpleType.createNewInstance(initialSnapshot);\n        }\n        catch (e) {\n            // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n            _this.state = NodeLifeCycle.DEAD;\n            throw e;\n        }\n        _this.state = NodeLifeCycle.CREATED;\n        // for scalar nodes there's no point in firing this event since it would fire on the constructor, before\n        // anybody can actually register for/listen to it\n        // this.fireHook(Hook.AfterCreate)\n        _this.finalizeCreation();\n        return _this;\n    }\n    Object.defineProperty(ScalarNode.prototype, \"root\", {\n        get: function () {\n            // future optimization: store root ref in the node and maintain it\n            if (!this.parent)\n                throw fail$1(\"This scalar node is not part of a tree\");\n            return this.parent.root;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScalarNode.prototype.setParent = function (newParent, subpath) {\n        var parentChanged = this.parent !== newParent;\n        var subpathChanged = this.subpath !== subpath;\n        if (!parentChanged && !subpathChanged) {\n            return;\n        }\n        if (devMode()) {\n            if (!subpath) {\n                // istanbul ignore next\n                throw fail$1(\"assertion failed: subpath expected\");\n            }\n            if (!newParent) {\n                // istanbul ignore next\n                throw fail$1(\"assertion failed: parent expected\");\n            }\n            if (parentChanged) {\n                // istanbul ignore next\n                throw fail$1(\"assertion failed: scalar nodes cannot change their parent\");\n            }\n        }\n        this.environment = undefined; // use parent's\n        this.baseSetParent(this.parent, subpath);\n    };\n    Object.defineProperty(ScalarNode.prototype, \"snapshot\", {\n        get: function () {\n            return freeze(this.getSnapshot());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScalarNode.prototype.getSnapshot = function () {\n        return this.type.getSnapshot(this);\n    };\n    ScalarNode.prototype.toString = function () {\n        var path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n        return this.type.name + \"@\" + path + (this.isAlive ? \"\" : \" [dead]\");\n    };\n    ScalarNode.prototype.die = function () {\n        if (!this.isAlive || this.state === NodeLifeCycle.DETACHING)\n            return;\n        this.aboutToDie();\n        this.finalizeDeath();\n    };\n    ScalarNode.prototype.finalizeCreation = function () {\n        this.baseFinalizeCreation();\n    };\n    ScalarNode.prototype.aboutToDie = function () {\n        this.baseAboutToDie();\n    };\n    ScalarNode.prototype.finalizeDeath = function () {\n        this.baseFinalizeDeath();\n    };\n    ScalarNode.prototype.fireHook = function (name) {\n        this.fireInternalHook(name);\n    };\n    __decorate([\n        action\n    ], ScalarNode.prototype, \"die\", null);\n    return ScalarNode;\n}(BaseNode));\n\nvar nextNodeId = 1;\nvar snapshotReactionOptions = {\n    onError: function (e) {\n        throw e;\n    }\n};\n/**\n * @internal\n * @hidden\n */\nvar ObjectNode = /** @class */ (function (_super) {\n    __extends(ObjectNode, _super);\n    function ObjectNode(complexType, parent, subpath, environment, initialValue) {\n        var _this = _super.call(this, complexType, parent, subpath, environment) || this;\n        _this.nodeId = ++nextNodeId;\n        _this.isProtectionEnabled = true;\n        _this._autoUnbox = true; // unboxing is disabled when reading child nodes\n        _this._isRunningAction = false; // only relevant for root\n        _this._hasSnapshotReaction = false;\n        _this._observableInstanceState = 0 /* UNINITIALIZED */;\n        _this._cachedInitialSnapshotCreated = false;\n        _this.unbox = _this.unbox.bind(_this);\n        _this._initialSnapshot = freeze(initialValue);\n        _this.identifierAttribute = complexType.identifierAttribute;\n        if (!parent) {\n            _this.identifierCache = new IdentifierCache();\n        }\n        _this._childNodes = complexType.initializeChildNodes(_this, _this._initialSnapshot);\n        // identifier can not be changed during lifecycle of a node\n        // so we safely can read it from initial snapshot\n        _this.identifier = null;\n        _this.unnormalizedIdentifier = null;\n        if (_this.identifierAttribute && _this._initialSnapshot) {\n            var id = _this._initialSnapshot[_this.identifierAttribute];\n            if (id === undefined) {\n                // try with the actual node if not (for optional identifiers)\n                var childNode = _this._childNodes[_this.identifierAttribute];\n                if (childNode) {\n                    id = childNode.value;\n                }\n            }\n            if (typeof id !== \"string\" && typeof id !== \"number\") {\n                throw fail$1(\"Instance identifier '\" + _this.identifierAttribute + \"' for type '\" + _this.type.name + \"' must be a string or a number\");\n            }\n            // normalize internal identifier to string\n            _this.identifier = normalizeIdentifier(id);\n            _this.unnormalizedIdentifier = id;\n        }\n        if (!parent) {\n            _this.identifierCache.addNodeToCache(_this);\n        }\n        else {\n            parent.root.identifierCache.addNodeToCache(_this);\n        }\n        return _this;\n    }\n    ObjectNode.prototype.applyPatches = function (patches) {\n        this.createObservableInstanceIfNeeded();\n        this._applyPatches(patches);\n    };\n    ObjectNode.prototype.applySnapshot = function (snapshot) {\n        this.createObservableInstanceIfNeeded();\n        this._applySnapshot(snapshot);\n    };\n    ObjectNode.prototype.createObservableInstanceIfNeeded = function () {\n        if (this._observableInstanceState === 0 /* UNINITIALIZED */) {\n            this.createObservableInstance();\n        }\n    };\n    ObjectNode.prototype.createObservableInstance = function () {\n        var e_1, _a;\n        if (devMode()) {\n            if (this.state !== NodeLifeCycle.INITIALIZING) {\n                // istanbul ignore next\n                throw fail$1(\"assertion failed: the creation of the observable instance must be done on the initializing phase\");\n            }\n        }\n        this._observableInstanceState = 1 /* CREATING */;\n        // make sure the parent chain is created as well\n        // array with parent chain from parent to child\n        var parentChain = [];\n        var parent = this.parent;\n        // for performance reasons we never go back further than the most direct\n        // uninitialized parent\n        // this is done to avoid traversing the whole tree to the root when using\n        // the same reference again\n        while (parent &&\n            parent._observableInstanceState === 0 /* UNINITIALIZED */) {\n            parentChain.unshift(parent);\n            parent = parent.parent;\n        }\n        try {\n            // initialize the uninitialized parent chain from parent to child\n            for (var parentChain_1 = __values(parentChain), parentChain_1_1 = parentChain_1.next(); !parentChain_1_1.done; parentChain_1_1 = parentChain_1.next()) {\n                var p = parentChain_1_1.value;\n                p.createObservableInstanceIfNeeded();\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (parentChain_1_1 && !parentChain_1_1.done && (_a = parentChain_1.return)) _a.call(parentChain_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        var type = this.type;\n        try {\n            this.storedValue = type.createNewInstance(this._childNodes);\n            this.preboot();\n            this._isRunningAction = true;\n            type.finalizeNewInstance(this, this.storedValue);\n        }\n        catch (e) {\n            // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n            this.state = NodeLifeCycle.DEAD;\n            throw e;\n        }\n        finally {\n            this._isRunningAction = false;\n        }\n        this._observableInstanceState = 2 /* CREATED */;\n        // NOTE: we need to touch snapshot, because non-observable\n        // \"_observableInstanceState\" field was touched\n        invalidateComputed(this, \"snapshot\");\n        if (this.isRoot)\n            this._addSnapshotReaction();\n        this._childNodes = EMPTY_OBJECT;\n        this.state = NodeLifeCycle.CREATED;\n        this.fireHook(Hook.afterCreate);\n        this.finalizeCreation();\n    };\n    Object.defineProperty(ObjectNode.prototype, \"root\", {\n        get: function () {\n            var parent = this.parent;\n            return parent ? parent.root : this;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObjectNode.prototype.clearParent = function () {\n        if (!this.parent)\n            return;\n        // detach if attached\n        this.fireHook(Hook.beforeDetach);\n        var previousState = this.state;\n        this.state = NodeLifeCycle.DETACHING;\n        var root = this.root;\n        var newEnv = root.environment;\n        var newIdCache = root.identifierCache.splitCache(this);\n        try {\n            this.parent.removeChild(this.subpath);\n            this.baseSetParent(null, \"\");\n            this.environment = newEnv;\n            this.identifierCache = newIdCache;\n        }\n        finally {\n            this.state = previousState;\n        }\n    };\n    ObjectNode.prototype.setParent = function (newParent, subpath) {\n        var parentChanged = newParent !== this.parent;\n        var subpathChanged = subpath !== this.subpath;\n        if (!parentChanged && !subpathChanged) {\n            return;\n        }\n        if (devMode()) {\n            if (!subpath) {\n                // istanbul ignore next\n                throw fail$1(\"assertion failed: subpath expected\");\n            }\n            if (!newParent) {\n                // istanbul ignore next\n                throw fail$1(\"assertion failed: new parent expected\");\n            }\n            if (this.parent && parentChanged) {\n                throw fail$1(\"A node cannot exists twice in the state tree. Failed to add \" + this + \" to path '\" + newParent.path + \"/\" + subpath + \"'.\");\n            }\n            if (!this.parent && newParent.root === this) {\n                throw fail$1(\"A state tree is not allowed to contain itself. Cannot assign \" + this + \" to path '\" + newParent.path + \"/\" + subpath + \"'\");\n            }\n            if (!this.parent &&\n                !!this.environment &&\n                this.environment !== newParent.root.environment) {\n                throw fail$1(\"A state tree cannot be made part of another state tree as long as their environments are different.\");\n            }\n        }\n        if (parentChanged) {\n            // attach to new parent\n            this.environment = undefined; // will use root's\n            newParent.root.identifierCache.mergeCache(this);\n            this.baseSetParent(newParent, subpath);\n            this.fireHook(Hook.afterAttach);\n        }\n        else if (subpathChanged) {\n            // moving to a new subpath on the same parent\n            this.baseSetParent(this.parent, subpath);\n        }\n    };\n    ObjectNode.prototype.fireHook = function (name) {\n        var _this = this;\n        this.fireInternalHook(name);\n        var fn = this.storedValue &&\n            typeof this.storedValue === \"object\" &&\n            this.storedValue[name];\n        if (typeof fn === \"function\") {\n            // we check for it to allow old mobx peer dependencies that don't have the method to work (even when still bugged)\n            if (_allowStateChangesInsideComputed) {\n                _allowStateChangesInsideComputed(function () {\n                    fn.apply(_this.storedValue);\n                });\n            }\n            else {\n                fn.apply(this.storedValue);\n            }\n        }\n    };\n    Object.defineProperty(ObjectNode.prototype, \"snapshot\", {\n        // advantage of using computed for a snapshot is that nicely respects transactions etc.\n        get: function () {\n            return freeze(this.getSnapshot());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // NOTE: we use this method to get snapshot without creating @computed overhead\n    ObjectNode.prototype.getSnapshot = function () {\n        if (!this.isAlive)\n            return this._snapshotUponDeath;\n        return this._observableInstanceState === 2 /* CREATED */\n            ? this._getActualSnapshot()\n            : this._getCachedInitialSnapshot();\n    };\n    ObjectNode.prototype._getActualSnapshot = function () {\n        return this.type.getSnapshot(this);\n    };\n    ObjectNode.prototype._getCachedInitialSnapshot = function () {\n        if (!this._cachedInitialSnapshotCreated) {\n            var type = this.type;\n            var childNodes = this._childNodes;\n            var snapshot = this._initialSnapshot;\n            this._cachedInitialSnapshot = type.processInitialSnapshot(childNodes, snapshot);\n            this._cachedInitialSnapshotCreated = true;\n        }\n        return this._cachedInitialSnapshot;\n    };\n    ObjectNode.prototype.isRunningAction = function () {\n        if (this._isRunningAction)\n            return true;\n        if (this.isRoot)\n            return false;\n        return this.parent.isRunningAction();\n    };\n    ObjectNode.prototype.assertAlive = function (context) {\n        var livelinessChecking = getLivelinessChecking();\n        if (!this.isAlive && livelinessChecking !== \"ignore\") {\n            var error = this._getAssertAliveError(context);\n            switch (livelinessChecking) {\n                case \"error\":\n                    throw fail$1(error);\n                case \"warn\":\n                    warnError(error);\n            }\n        }\n    };\n    ObjectNode.prototype._getAssertAliveError = function (context) {\n        var escapedPath = this.getEscapedPath(false) || this.pathUponDeath || \"\";\n        var subpath = (context.subpath && escapeJsonPath(context.subpath)) || \"\";\n        var actionContext = context.actionContext || getCurrentActionContext();\n        // try to use a real action context if possible since it includes the action name\n        if (actionContext && actionContext.type !== \"action\" && actionContext.parentActionEvent) {\n            actionContext = actionContext.parentActionEvent;\n        }\n        var actionFullPath = \"\";\n        if (actionContext && actionContext.name != null) {\n            // try to use the context, and if it not available use the node one\n            var actionPath = (actionContext && actionContext.context && getPath(actionContext.context)) ||\n                escapedPath;\n            actionFullPath = actionPath + \".\" + actionContext.name + \"()\";\n        }\n        return \"You are trying to read or write to an object that is no longer part of a state tree. (Object type: '\" + this.type.name + \"', Path upon death: '\" + escapedPath + \"', Subpath: '\" + subpath + \"', Action: '\" + actionFullPath + \"'). Either detach nodes first, or don't use objects after removing / replacing them in the tree.\";\n    };\n    ObjectNode.prototype.getChildNode = function (subpath) {\n        this.assertAlive({\n            subpath: subpath\n        });\n        this._autoUnbox = false;\n        try {\n            return this._observableInstanceState === 2 /* CREATED */\n                ? this.type.getChildNode(this, subpath)\n                : this._childNodes[subpath];\n        }\n        finally {\n            this._autoUnbox = true;\n        }\n    };\n    ObjectNode.prototype.getChildren = function () {\n        this.assertAlive(EMPTY_OBJECT);\n        this._autoUnbox = false;\n        try {\n            return this._observableInstanceState === 2 /* CREATED */\n                ? this.type.getChildren(this)\n                : convertChildNodesToArray(this._childNodes);\n        }\n        finally {\n            this._autoUnbox = true;\n        }\n    };\n    ObjectNode.prototype.getChildType = function (propertyName) {\n        return this.type.getChildType(propertyName);\n    };\n    Object.defineProperty(ObjectNode.prototype, \"isProtected\", {\n        get: function () {\n            return this.root.isProtectionEnabled;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObjectNode.prototype.assertWritable = function (context) {\n        this.assertAlive(context);\n        if (!this.isRunningAction() && this.isProtected) {\n            throw fail$1(\"Cannot modify '\" + this + \"', the object is protected and can only be modified by using an action.\");\n        }\n    };\n    ObjectNode.prototype.removeChild = function (subpath) {\n        this.type.removeChild(this, subpath);\n    };\n    // bound on the constructor\n    ObjectNode.prototype.unbox = function (childNode) {\n        if (!childNode)\n            return childNode;\n        this.assertAlive({\n            subpath: childNode.subpath || childNode.subpathUponDeath\n        });\n        return this._autoUnbox ? childNode.value : childNode;\n    };\n    ObjectNode.prototype.toString = function () {\n        var path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n        var identifier = this.identifier ? \"(id: \" + this.identifier + \")\" : \"\";\n        return this.type.name + \"@\" + path + identifier + (this.isAlive ? \"\" : \" [dead]\");\n    };\n    ObjectNode.prototype.finalizeCreation = function () {\n        var _this = this;\n        this.baseFinalizeCreation(function () {\n            var e_2, _a;\n            try {\n                for (var _b = __values(_this.getChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var child = _c.value;\n                    child.finalizeCreation();\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            _this.fireInternalHook(Hook.afterCreationFinalization);\n        });\n    };\n    ObjectNode.prototype.detach = function () {\n        if (!this.isAlive)\n            throw fail$1(\"Error while detaching, node is not alive.\");\n        this.clearParent();\n    };\n    ObjectNode.prototype.preboot = function () {\n        var self = this;\n        this._applyPatches = createActionInvoker(this.storedValue, \"@APPLY_PATCHES\", function (patches) {\n            patches.forEach(function (patch) {\n                var parts = splitJsonPath(patch.path);\n                var node = resolveNodeByPathParts(self, parts.slice(0, -1));\n                node.applyPatchLocally(parts[parts.length - 1], patch);\n            });\n        });\n        this._applySnapshot = createActionInvoker(this.storedValue, \"@APPLY_SNAPSHOT\", function (snapshot) {\n            // if the snapshot is the same as the current one, avoid performing a reconcile\n            if (snapshot === self.snapshot)\n                return;\n            // else, apply it by calling the type logic\n            return self.type.applySnapshot(self, snapshot);\n        });\n        addHiddenFinalProp(this.storedValue, \"$treenode\", this);\n        addHiddenFinalProp(this.storedValue, \"toJSON\", toJSON);\n    };\n    ObjectNode.prototype.die = function () {\n        if (!this.isAlive || this.state === NodeLifeCycle.DETACHING)\n            return;\n        this.aboutToDie();\n        this.finalizeDeath();\n    };\n    ObjectNode.prototype.aboutToDie = function () {\n        if (this._observableInstanceState === 0 /* UNINITIALIZED */) {\n            return;\n        }\n        this.getChildren().forEach(function (node) {\n            node.aboutToDie();\n        });\n        // beforeDestroy should run before the disposers since else we could end up in a situation where\n        // a disposer added with addDisposer at this stage (beforeDestroy) is actually never released\n        this.baseAboutToDie();\n        this._internalEventsEmit(\"dispose\" /* Dispose */);\n        this._internalEventsClear(\"dispose\" /* Dispose */);\n    };\n    ObjectNode.prototype.finalizeDeath = function () {\n        // invariant: not called directly but from \"die\"\n        this.getChildren().forEach(function (node) {\n            node.finalizeDeath();\n        });\n        this.root.identifierCache.notifyDied(this);\n        // \"kill\" the computed prop and just store the last snapshot\n        var snapshot = this.snapshot;\n        this._snapshotUponDeath = snapshot;\n        this._internalEventsClearAll();\n        this.baseFinalizeDeath();\n    };\n    ObjectNode.prototype.onSnapshot = function (onChange) {\n        this._addSnapshotReaction();\n        return this._internalEventsRegister(\"snapshot\" /* Snapshot */, onChange);\n    };\n    ObjectNode.prototype.emitSnapshot = function (snapshot) {\n        this._internalEventsEmit(\"snapshot\" /* Snapshot */, snapshot);\n    };\n    ObjectNode.prototype.onPatch = function (handler) {\n        return this._internalEventsRegister(\"patch\" /* Patch */, handler);\n    };\n    ObjectNode.prototype.emitPatch = function (basePatch, source) {\n        if (this._internalEventsHasSubscribers(\"patch\" /* Patch */)) {\n            var localizedPatch = extend({}, basePatch, {\n                path: source.path.substr(this.path.length) + \"/\" + basePatch.path // calculate the relative path of the patch\n            });\n            var _a = __read(splitPatch(localizedPatch), 2), patch = _a[0], reversePatch = _a[1];\n            this._internalEventsEmit(\"patch\" /* Patch */, patch, reversePatch);\n        }\n        if (this.parent)\n            this.parent.emitPatch(basePatch, source);\n    };\n    ObjectNode.prototype.hasDisposer = function (disposer) {\n        return this._internalEventsHas(\"dispose\" /* Dispose */, disposer);\n    };\n    ObjectNode.prototype.addDisposer = function (disposer) {\n        if (!this.hasDisposer(disposer)) {\n            this._internalEventsRegister(\"dispose\" /* Dispose */, disposer, true);\n            return;\n        }\n        throw fail$1(\"cannot add a disposer when it is already registered for execution\");\n    };\n    ObjectNode.prototype.removeDisposer = function (disposer) {\n        if (!this._internalEventsHas(\"dispose\" /* Dispose */, disposer)) {\n            throw fail$1(\"cannot remove a disposer which was never registered for execution\");\n        }\n        this._internalEventsUnregister(\"dispose\" /* Dispose */, disposer);\n    };\n    ObjectNode.prototype.removeMiddleware = function (middleware) {\n        if (this.middlewares) {\n            var index = this.middlewares.indexOf(middleware);\n            if (index >= 0) {\n                this.middlewares.splice(index, 1);\n            }\n        }\n    };\n    ObjectNode.prototype.addMiddleWare = function (handler, includeHooks) {\n        var _this = this;\n        if (includeHooks === void 0) { includeHooks = true; }\n        var middleware = { handler: handler, includeHooks: includeHooks };\n        if (!this.middlewares)\n            this.middlewares = [middleware];\n        else\n            this.middlewares.push(middleware);\n        return function () {\n            _this.removeMiddleware(middleware);\n        };\n    };\n    ObjectNode.prototype.applyPatchLocally = function (subpath, patch) {\n        this.assertWritable({\n            subpath: subpath\n        });\n        this.createObservableInstanceIfNeeded();\n        this.type.applyPatchLocally(this, subpath, patch);\n    };\n    ObjectNode.prototype._addSnapshotReaction = function () {\n        var _this = this;\n        if (!this._hasSnapshotReaction) {\n            var snapshotDisposer = reaction(function () { return _this.snapshot; }, function (snapshot) { return _this.emitSnapshot(snapshot); }, snapshotReactionOptions);\n            this.addDisposer(snapshotDisposer);\n            this._hasSnapshotReaction = true;\n        }\n    };\n    // we proxy the methods to avoid creating an EventHandlers instance when it is not needed\n    ObjectNode.prototype._internalEventsHasSubscribers = function (event) {\n        return !!this._internalEvents && this._internalEvents.hasSubscribers(event);\n    };\n    ObjectNode.prototype._internalEventsRegister = function (event, eventHandler, atTheBeginning) {\n        if (atTheBeginning === void 0) { atTheBeginning = false; }\n        if (!this._internalEvents) {\n            this._internalEvents = new EventHandlers();\n        }\n        return this._internalEvents.register(event, eventHandler, atTheBeginning);\n    };\n    ObjectNode.prototype._internalEventsHas = function (event, eventHandler) {\n        return !!this._internalEvents && this._internalEvents.has(event, eventHandler);\n    };\n    ObjectNode.prototype._internalEventsUnregister = function (event, eventHandler) {\n        if (this._internalEvents) {\n            this._internalEvents.unregister(event, eventHandler);\n        }\n    };\n    ObjectNode.prototype._internalEventsEmit = function (event) {\n        var _a;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        if (this._internalEvents) {\n            (_a = this._internalEvents).emit.apply(_a, __spread([event], args));\n        }\n    };\n    ObjectNode.prototype._internalEventsClear = function (event) {\n        if (this._internalEvents) {\n            this._internalEvents.clear(event);\n        }\n    };\n    ObjectNode.prototype._internalEventsClearAll = function () {\n        if (this._internalEvents) {\n            this._internalEvents.clearAll();\n        }\n    };\n    __decorate([\n        action\n    ], ObjectNode.prototype, \"createObservableInstance\", null);\n    __decorate([\n        computed\n    ], ObjectNode.prototype, \"snapshot\", null);\n    __decorate([\n        action\n    ], ObjectNode.prototype, \"detach\", null);\n    __decorate([\n        action\n    ], ObjectNode.prototype, \"die\", null);\n    return ObjectNode;\n}(BaseNode));\n\n/**\n * @internal\n * @hidden\n */\nvar TypeFlags;\n(function (TypeFlags) {\n    TypeFlags[TypeFlags[\"String\"] = 1] = \"String\";\n    TypeFlags[TypeFlags[\"Number\"] = 2] = \"Number\";\n    TypeFlags[TypeFlags[\"Boolean\"] = 4] = \"Boolean\";\n    TypeFlags[TypeFlags[\"Date\"] = 8] = \"Date\";\n    TypeFlags[TypeFlags[\"Literal\"] = 16] = \"Literal\";\n    TypeFlags[TypeFlags[\"Array\"] = 32] = \"Array\";\n    TypeFlags[TypeFlags[\"Map\"] = 64] = \"Map\";\n    TypeFlags[TypeFlags[\"Object\"] = 128] = \"Object\";\n    TypeFlags[TypeFlags[\"Frozen\"] = 256] = \"Frozen\";\n    TypeFlags[TypeFlags[\"Optional\"] = 512] = \"Optional\";\n    TypeFlags[TypeFlags[\"Reference\"] = 1024] = \"Reference\";\n    TypeFlags[TypeFlags[\"Identifier\"] = 2048] = \"Identifier\";\n    TypeFlags[TypeFlags[\"Late\"] = 4096] = \"Late\";\n    TypeFlags[TypeFlags[\"Refinement\"] = 8192] = \"Refinement\";\n    TypeFlags[TypeFlags[\"Union\"] = 16384] = \"Union\";\n    TypeFlags[TypeFlags[\"Null\"] = 32768] = \"Null\";\n    TypeFlags[TypeFlags[\"Undefined\"] = 65536] = \"Undefined\";\n    TypeFlags[TypeFlags[\"Integer\"] = 131072] = \"Integer\";\n    TypeFlags[TypeFlags[\"Custom\"] = 262144] = \"Custom\";\n    TypeFlags[TypeFlags[\"SnapshotProcessor\"] = 524288] = \"SnapshotProcessor\";\n})(TypeFlags || (TypeFlags = {}));\n/**\n * @internal\n * @hidden\n */\nvar cannotDetermineSubtype = \"cannotDetermine\";\n/**\n * A base type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\nvar BaseType = /** @class */ (function () {\n    function BaseType(name) {\n        this.isType = true;\n        this.name = name;\n    }\n    BaseType.prototype.create = function (snapshot, environment) {\n        typecheckInternal(this, snapshot);\n        return this.instantiate(null, \"\", environment, snapshot).value;\n    };\n    BaseType.prototype.getSnapshot = function (node, applyPostProcess) {\n        // istanbul ignore next\n        throw fail$1(\"unimplemented method\");\n    };\n    BaseType.prototype.isAssignableFrom = function (type) {\n        return type === this;\n    };\n    BaseType.prototype.validate = function (value, context) {\n        var node = getStateTreeNodeSafe(value);\n        if (node) {\n            var valueType = getType(value);\n            return this.isAssignableFrom(valueType)\n                ? typeCheckSuccess()\n                : typeCheckFailure(context, value);\n            // it is tempting to compare snapshots, but in that case we should always clone on assignments...\n        }\n        return this.isValidSnapshot(value, context);\n    };\n    BaseType.prototype.is = function (thing) {\n        return this.validate(thing, [{ path: \"\", type: this }]).length === 0;\n    };\n    Object.defineProperty(BaseType.prototype, \"Type\", {\n        get: function () {\n            // istanbul ignore next\n            throw fail$1(\"Factory.Type should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.Type`\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseType.prototype, \"TypeWithoutSTN\", {\n        get: function () {\n            // istanbul ignore next\n            throw fail$1(\"Factory.TypeWithoutSTN should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.TypeWithoutSTN`\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseType.prototype, \"SnapshotType\", {\n        get: function () {\n            // istanbul ignore next\n            throw fail$1(\"Factory.SnapshotType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.SnapshotType`\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseType.prototype, \"CreationType\", {\n        get: function () {\n            // istanbul ignore next\n            throw fail$1(\"Factory.CreationType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.CreationType`\");\n        },\n        enumerable: true,\n        configurable: true\n    });\n    __decorate([\n        action\n    ], BaseType.prototype, \"create\", null);\n    return BaseType;\n}());\n/**\n * A complex type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\nvar ComplexType = /** @class */ (function (_super) {\n    __extends(ComplexType, _super);\n    function ComplexType(name) {\n        return _super.call(this, name) || this;\n    }\n    ComplexType.prototype.create = function (snapshot, environment) {\n        if (snapshot === void 0) { snapshot = this.getDefaultSnapshot(); }\n        return _super.prototype.create.call(this, snapshot, environment);\n    };\n    ComplexType.prototype.getValue = function (node) {\n        node.createObservableInstanceIfNeeded();\n        return node.storedValue;\n    };\n    ComplexType.prototype.tryToReconcileNode = function (current, newValue) {\n        if (current.isDetaching)\n            return false;\n        if (current.snapshot === newValue) {\n            // newValue is the current snapshot of the node, noop\n            return true;\n        }\n        if (isStateTreeNode(newValue) && getStateTreeNode(newValue) === current) {\n            // the current node is the same as the new one\n            return true;\n        }\n        if (current.type === this &&\n            isMutable(newValue) &&\n            !isStateTreeNode(newValue) &&\n            (!current.identifierAttribute ||\n                current.identifier ===\n                    normalizeIdentifier(newValue[current.identifierAttribute]))) {\n            // the newValue has no node, so can be treated like a snapshot\n            // we can reconcile\n            current.applySnapshot(newValue);\n            return true;\n        }\n        return false;\n    };\n    ComplexType.prototype.reconcile = function (current, newValue, parent, subpath) {\n        var nodeReconciled = this.tryToReconcileNode(current, newValue);\n        if (nodeReconciled) {\n            current.setParent(parent, subpath);\n            return current;\n        }\n        // current node cannot be recycled in any way\n        current.die(); // noop if detaching\n        // attempt to reuse the new one\n        if (isStateTreeNode(newValue) && this.isAssignableFrom(getType(newValue))) {\n            // newValue is a Node as well, move it here..\n            var newNode = getStateTreeNode(newValue);\n            newNode.setParent(parent, subpath);\n            return newNode;\n        }\n        // nothing to do, we have to create a new node\n        return this.instantiate(parent, subpath, undefined, newValue);\n    };\n    ComplexType.prototype.getSubTypes = function () {\n        return null;\n    };\n    __decorate([\n        action\n    ], ComplexType.prototype, \"create\", null);\n    return ComplexType;\n}(BaseType));\n/**\n * @internal\n * @hidden\n */\nvar SimpleType = /** @class */ (function (_super) {\n    __extends(SimpleType, _super);\n    function SimpleType() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    SimpleType.prototype.createNewInstance = function (snapshot) {\n        return snapshot;\n    };\n    SimpleType.prototype.getValue = function (node) {\n        // if we ever find a case where scalar nodes can be accessed without iterating through its parent\n        // uncomment this to make sure the parent chain is created when this is accessed\n        // if (node.parent) {\n        //     node.parent.createObservableInstanceIfNeeded()\n        // }\n        return node.storedValue;\n    };\n    SimpleType.prototype.getSnapshot = function (node) {\n        return node.storedValue;\n    };\n    SimpleType.prototype.reconcile = function (current, newValue, parent, subpath) {\n        // reconcile only if type and value are still the same, and only if the node is not detaching\n        if (!current.isDetaching && current.type === this && current.storedValue === newValue) {\n            return current;\n        }\n        var res = this.instantiate(parent, subpath, undefined, newValue);\n        current.die(); // noop if detaching\n        return res;\n    };\n    SimpleType.prototype.getSubTypes = function () {\n        return null;\n    };\n    return SimpleType;\n}(BaseType));\n/**\n * Returns if a given value represents a type.\n *\n * @param value Value to check.\n * @returns `true` if the value is a type.\n */\nfunction isType(value) {\n    return typeof value === \"object\" && value && value.isType === true;\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsType(type, argNumber) {\n    assertArg(type, isType, \"mobx-state-tree type\", argNumber);\n}\n\nvar runningActions = new Map();\n/**\n * Note: Consider migrating to `createActionTrackingMiddleware2`, it is easier to use.\n *\n * Convenience utility to create action based middleware that supports async processes more easily.\n * All hooks are called for both synchronous and asynchronous actions. Except that either `onSuccess` or `onFail` is called\n *\n * The create middleware tracks the process of an action (assuming it passes the `filter`).\n * `onResume` can return any value, which will be passed as second argument to any other hook. This makes it possible to keep state during a process.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\nfunction createActionTrackingMiddleware(hooks) {\n    return function actionTrackingMiddleware(call, next, abort) {\n        switch (call.type) {\n            case \"action\": {\n                if (!hooks.filter || hooks.filter(call) === true) {\n                    var context = hooks.onStart(call);\n                    hooks.onResume(call, context);\n                    runningActions.set(call.id, {\n                        call: call,\n                        context: context,\n                        async: false\n                    });\n                    try {\n                        var res = next(call);\n                        hooks.onSuspend(call, context);\n                        if (runningActions.get(call.id).async === false) {\n                            runningActions.delete(call.id);\n                            hooks.onSuccess(call, context, res);\n                        }\n                        return res;\n                    }\n                    catch (e) {\n                        runningActions.delete(call.id);\n                        hooks.onFail(call, context, e);\n                        throw e;\n                    }\n                }\n                else {\n                    return next(call);\n                }\n            }\n            case \"flow_spawn\": {\n                var root = runningActions.get(call.rootId);\n                root.async = true;\n                return next(call);\n            }\n            case \"flow_resume\":\n            case \"flow_resume_error\": {\n                var root = runningActions.get(call.rootId);\n                hooks.onResume(call, root.context);\n                try {\n                    return next(call);\n                }\n                finally {\n                    hooks.onSuspend(call, root.context);\n                }\n            }\n            case \"flow_throw\": {\n                var root = runningActions.get(call.rootId);\n                runningActions.delete(call.rootId);\n                hooks.onFail(call, root.context, call.args[0]);\n                return next(call);\n            }\n            case \"flow_return\": {\n                var root = runningActions.get(call.rootId);\n                runningActions.delete(call.rootId);\n                hooks.onSuccess(call, root.context, call.args[0]);\n                return next(call);\n            }\n        }\n    };\n}\n\nvar RunningAction = /** @class */ (function () {\n    function RunningAction(hooks, call) {\n        this.hooks = hooks;\n        this.call = call;\n        this.flowsPending = 0;\n        this.running = true;\n        if (hooks) {\n            hooks.onStart(call);\n        }\n    }\n    RunningAction.prototype.finish = function (error) {\n        if (this.running) {\n            this.running = false;\n            if (this.hooks) {\n                this.hooks.onFinish(this.call, error);\n            }\n        }\n    };\n    RunningAction.prototype.incFlowsPending = function () {\n        this.flowsPending++;\n    };\n    RunningAction.prototype.decFlowsPending = function () {\n        this.flowsPending--;\n    };\n    Object.defineProperty(RunningAction.prototype, \"hasFlowsPending\", {\n        get: function () {\n            return this.flowsPending > 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return RunningAction;\n}());\n/**\n * Convenience utility to create action based middleware that supports async processes more easily.\n * The flow is like this:\n * - for each action: if filter passes -> `onStart` -> (inner actions recursively) -> `onFinish`\n *\n * Example: if we had an action `a` that called inside an action `b1`, then `b2` the flow would be:\n * - `filter(a)`\n * - `onStart(a)`\n *   - `filter(b1)`\n *   - `onStart(b1)`\n *   - `onFinish(b1)`\n *   - `filter(b2)`\n *   - `onStart(b2)`\n *   - `onFinish(b2)`\n * - `onFinish(a)`\n *\n * The flow is the same no matter if the actions are sync or async.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\nfunction createActionTrackingMiddleware2(middlewareHooks) {\n    var runningActions = new WeakMap();\n    return function actionTrackingMiddleware(call, next) {\n        // find parentRunningAction\n        var parentRunningAction = call.parentActionEvent\n            ? runningActions.get(call.parentActionEvent)\n            : undefined;\n        if (call.type === \"action\") {\n            var newCall = __assign(__assign({}, call), { \n                // make a shallow copy of the parent action env\n                env: parentRunningAction && parentRunningAction.call.env, parentCall: parentRunningAction && parentRunningAction.call });\n            var passesFilter = !middlewareHooks.filter || middlewareHooks.filter(newCall);\n            var hooks = passesFilter ? middlewareHooks : undefined;\n            var runningAction = new RunningAction(hooks, newCall);\n            runningActions.set(call, runningAction);\n            var res = void 0;\n            try {\n                res = next(call);\n            }\n            catch (e) {\n                runningAction.finish(e);\n                throw e;\n            }\n            if (!runningAction.hasFlowsPending) {\n                // sync action finished\n                runningAction.finish();\n            }\n            return res;\n        }\n        else {\n            if (!parentRunningAction) {\n                return next(call);\n            }\n            switch (call.type) {\n                case \"flow_spawn\": {\n                    parentRunningAction.incFlowsPending();\n                    return next(call);\n                }\n                case \"flow_resume\":\n                case \"flow_resume_error\": {\n                    return next(call);\n                }\n                case \"flow_throw\": {\n                    var error = call.args[0];\n                    try {\n                        return next(call);\n                    }\n                    finally {\n                        parentRunningAction.decFlowsPending();\n                        if (!parentRunningAction.hasFlowsPending) {\n                            parentRunningAction.finish(error);\n                        }\n                    }\n                }\n                case \"flow_return\": {\n                    try {\n                        return next(call);\n                    }\n                    finally {\n                        parentRunningAction.decFlowsPending();\n                        if (!parentRunningAction.hasFlowsPending) {\n                            parentRunningAction.finish();\n                        }\n                    }\n                }\n            }\n        }\n    };\n}\n\nfunction serializeArgument(node, actionName, index, arg) {\n    if (arg instanceof Date)\n        return { $MST_DATE: arg.getTime() };\n    if (isPrimitive(arg))\n        return arg;\n    // We should not serialize MST nodes, even if we can, because we don't know if the receiving party can handle a raw snapshot instead of an\n    // MST type instance. So if one wants to serialize a MST node that was pass in, either explitly pass: 1: an id, 2: a (relative) path, 3: a snapshot\n    if (isStateTreeNode(arg))\n        return serializeTheUnserializable(\"[MSTNode: \" + getType(arg).name + \"]\");\n    if (typeof arg === \"function\")\n        return serializeTheUnserializable(\"[function]\");\n    if (typeof arg === \"object\" && !isPlainObject(arg) && !isArray(arg))\n        return serializeTheUnserializable(\"[object \" + ((arg && arg.constructor && arg.constructor.name) ||\n            \"Complex Object\") + \"]\");\n    try {\n        // Check if serializable, cycle free etc...\n        // MWE: there must be a better way....\n        JSON.stringify(arg); // or throws\n        return arg;\n    }\n    catch (e) {\n        return serializeTheUnserializable(\"\" + e);\n    }\n}\nfunction deserializeArgument(adm, value) {\n    if (value && typeof value === \"object\" && \"$MST_DATE\" in value)\n        return new Date(value[\"$MST_DATE\"]);\n    return value;\n}\nfunction serializeTheUnserializable(baseType) {\n    return {\n        $MST_UNSERIALIZABLE: true,\n        type: baseType\n    };\n}\n/**\n * Applies an action or a series of actions in a single MobX transaction.\n * Does not return any value\n * Takes an action description as produced by the `onAction` middleware.\n *\n * @param target\n * @param actions\n */\nfunction applyAction(target, actions) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertArg(actions, function (a) { return typeof a === \"object\"; }, \"object or array\", 2);\n    runInAction(function () {\n        asArray(actions).forEach(function (action) { return baseApplyAction(target, action); });\n    });\n}\nfunction baseApplyAction(target, action) {\n    var resolvedTarget = tryResolve(target, action.path || \"\");\n    if (!resolvedTarget)\n        throw fail$1(\"Invalid action path: \" + (action.path || \"\"));\n    var node = getStateTreeNode(resolvedTarget);\n    // Reserved functions\n    if (action.name === \"@APPLY_PATCHES\") {\n        return applyPatch.call(null, resolvedTarget, action.args[0]);\n    }\n    if (action.name === \"@APPLY_SNAPSHOT\") {\n        return applySnapshot.call(null, resolvedTarget, action.args[0]);\n    }\n    if (!(typeof resolvedTarget[action.name] === \"function\"))\n        throw fail$1(\"Action '\" + action.name + \"' does not exist in '\" + node.path + \"'\");\n    return resolvedTarget[action.name].apply(resolvedTarget, action.args ? action.args.map(function (v) { return deserializeArgument(node, v); }) : []);\n}\n/**\n * Small abstraction around `onAction` and `applyAction`, attaches an action listener to a tree and records all the actions emitted.\n * Returns an recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IActionRecorder {\n *      // the recorded actions\n *      actions: ISerializedActionCall[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording actions\n *      stop(): void\n *      // resume recording actions\n *      resume(): void\n *      // apply all the recorded actions on the given object\n *      replay(target: IAnyStateTreeNode): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain actions.\n *\n * @param subject\n * @returns\n */\nfunction recordActions(subject, filter) {\n    // check all arguments\n    assertIsStateTreeNode(subject, 1);\n    var actions = [];\n    var listener = function (call) {\n        var recordThis = filter ? filter(call, getRunningActionContext()) : true;\n        if (recordThis) {\n            actions.push(call);\n        }\n    };\n    var disposer;\n    var recorder = {\n        actions: actions,\n        get recording() {\n            return !!disposer;\n        },\n        stop: function () {\n            if (disposer) {\n                disposer();\n                disposer = undefined;\n            }\n        },\n        resume: function () {\n            if (disposer)\n                return;\n            disposer = onAction(subject, listener);\n        },\n        replay: function (target) {\n            applyAction(target, actions);\n        }\n    };\n    recorder.resume();\n    return recorder;\n}\n/**\n * Registers a function that will be invoked for each action that is called on the provided model instance, or to any of its children.\n * See [actions](https://github.com/mobxjs/mobx-state-tree#actions) for more details. onAction events are emitted only for the outermost called action in the stack.\n * Action can also be intercepted by middleware using addMiddleware to change the function call before it will be run.\n *\n * Not all action arguments might be serializable. For unserializable arguments, a struct like `{ $MST_UNSERIALIZABLE: true, type: \"someType\" }` will be generated.\n * MST Nodes are considered non-serializable as well (they could be serialized as there snapshot, but it is uncertain whether an replaying party will be able to handle such a non-instantiated snapshot).\n * Rather, when using `onAction` middleware, one should consider in passing arguments which are 1: an id, 2: a (relative) path, or 3: a snapshot. Instead of a real MST node.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * }).actions(self => ({\n *   add(todo) {\n *     self.todos.push(todo);\n *   }\n * }))\n *\n * const s = TodoStore.create({ todos: [] })\n *\n * let disposer = onAction(s, (call) => {\n *   console.log(call);\n * })\n *\n * s.add({ task: \"Grab a coffee\" })\n * // Logs: { name: \"add\", path: \"\", args: [{ task: \"Grab a coffee\" }] }\n * ```\n *\n * @param target\n * @param listener\n * @param attachAfter (default false) fires the listener *after* the action has executed instead of before.\n * @returns\n */\nfunction onAction(target, listener, attachAfter) {\n    if (attachAfter === void 0) { attachAfter = false; }\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    if (devMode()) {\n        if (!isRoot(target))\n            warnError(\"Warning: Attaching onAction listeners to non root nodes is dangerous: No events will be emitted for actions initiated higher up in the tree.\");\n        if (!isProtected(target))\n            warnError(\"Warning: Attaching onAction listeners to non protected nodes is dangerous: No events will be emitted for direct modifications without action.\");\n    }\n    return addMiddleware(target, function handler(rawCall, next) {\n        if (rawCall.type === \"action\" && rawCall.id === rawCall.rootId) {\n            var sourceNode_1 = getStateTreeNode(rawCall.context);\n            var info = {\n                name: rawCall.name,\n                path: getRelativePathBetweenNodes(getStateTreeNode(target), sourceNode_1),\n                args: rawCall.args.map(function (arg, index) {\n                    return serializeArgument(sourceNode_1, rawCall.name, index, arg);\n                })\n            };\n            if (attachAfter) {\n                var res = next(rawCall);\n                listener(info);\n                return res;\n            }\n            else {\n                listener(info);\n                return next(rawCall);\n            }\n        }\n        else {\n            return next(rawCall);\n        }\n    });\n}\n\nvar nextActionId = 1;\nvar currentActionContext;\n/**\n * @internal\n * @hidden\n */\nfunction getCurrentActionContext() {\n    return currentActionContext;\n}\n/**\n * @internal\n * @hidden\n */\nfunction getNextActionId() {\n    return nextActionId++;\n}\n// TODO: optimize away entire action context if there is no middleware in tree?\n/**\n * @internal\n * @hidden\n */\nfunction runWithActionContext(context, fn) {\n    var node = getStateTreeNode(context.context);\n    if (context.type === \"action\") {\n        node.assertAlive({\n            actionContext: context\n        });\n    }\n    var baseIsRunningAction = node._isRunningAction;\n    node._isRunningAction = true;\n    var previousContext = currentActionContext;\n    currentActionContext = context;\n    try {\n        return runMiddleWares(node, context, fn);\n    }\n    finally {\n        currentActionContext = previousContext;\n        node._isRunningAction = baseIsRunningAction;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction getParentActionContext(parentContext) {\n    if (!parentContext)\n        return undefined;\n    if (parentContext.type === \"action\")\n        return parentContext;\n    return parentContext.parentActionEvent;\n}\n/**\n * @internal\n * @hidden\n */\nfunction createActionInvoker(target, name, fn) {\n    var res = function () {\n        var id = getNextActionId();\n        var parentContext = currentActionContext;\n        var parentActionContext = getParentActionContext(parentContext);\n        return runWithActionContext({\n            type: \"action\",\n            name: name,\n            id: id,\n            args: argsToArray(arguments),\n            context: target,\n            tree: getRoot(target),\n            rootId: parentContext ? parentContext.rootId : id,\n            parentId: parentContext ? parentContext.id : 0,\n            allParentIds: parentContext\n                ? __spread(parentContext.allParentIds, [parentContext.id]) : [],\n            parentEvent: parentContext,\n            parentActionEvent: parentActionContext\n        }, fn);\n    };\n    res._isMSTAction = true;\n    return res;\n}\n/**\n * Middleware can be used to intercept any action is invoked on the subtree where it is attached.\n * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.\n *\n * For more details, see the [middleware docs](concepts/middleware.md)\n *\n * @param target Node to apply the middleware to.\n * @param middleware Middleware to apply.\n * @returns A callable function to dispose the middleware.\n */\nfunction addMiddleware(target, handler, includeHooks) {\n    if (includeHooks === void 0) { includeHooks = true; }\n    var node = getStateTreeNode(target);\n    if (devMode()) {\n        if (!node.isProtectionEnabled) {\n            warnError(\"It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`\");\n        }\n    }\n    return node.addMiddleWare(handler, includeHooks);\n}\n/**\n * Binds middleware to a specific action.\n *\n * Example:\n * ```ts\n * type.actions(self => {\n *   function takeA____() {\n *       self.toilet.donate()\n *       self.wipe()\n *       self.wipe()\n *       self.toilet.flush()\n *   }\n *   return {\n *     takeA____: decorate(atomic, takeA____)\n *   }\n * })\n * ```\n *\n * @param handler\n * @param fn\n * @param includeHooks\n * @returns The original function\n */\nfunction decorate(handler, fn, includeHooks) {\n    if (includeHooks === void 0) { includeHooks = true; }\n    var middleware = { handler: handler, includeHooks: includeHooks };\n    fn.$mst_middleware = fn.$mst_middleware || [];\n    fn.$mst_middleware.push(middleware);\n    return fn;\n}\nvar CollectedMiddlewares = /** @class */ (function () {\n    function CollectedMiddlewares(node, fn) {\n        this.arrayIndex = 0;\n        this.inArrayIndex = 0;\n        this.middlewares = [];\n        // we just push middleware arrays into an array of arrays to avoid making copies\n        if (fn.$mst_middleware) {\n            this.middlewares.push(fn.$mst_middleware);\n        }\n        var n = node;\n        // Find all middlewares. Optimization: cache this?\n        while (n) {\n            if (n.middlewares)\n                this.middlewares.push(n.middlewares);\n            n = n.parent;\n        }\n    }\n    Object.defineProperty(CollectedMiddlewares.prototype, \"isEmpty\", {\n        get: function () {\n            return this.middlewares.length <= 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CollectedMiddlewares.prototype.getNextMiddleware = function () {\n        var array = this.middlewares[this.arrayIndex];\n        if (!array)\n            return undefined;\n        var item = array[this.inArrayIndex++];\n        if (!item) {\n            this.arrayIndex++;\n            this.inArrayIndex = 0;\n            return this.getNextMiddleware();\n        }\n        return item;\n    };\n    return CollectedMiddlewares;\n}());\nfunction runMiddleWares(node, baseCall, originalFn) {\n    var middlewares = new CollectedMiddlewares(node, originalFn);\n    // Short circuit\n    if (middlewares.isEmpty)\n        return action(originalFn).apply(null, baseCall.args);\n    var result = null;\n    function runNextMiddleware(call) {\n        var middleware = middlewares.getNextMiddleware();\n        var handler = middleware && middleware.handler;\n        if (!handler) {\n            return action(originalFn).apply(null, call.args);\n        }\n        // skip hooks if asked to\n        if (!middleware.includeHooks && Hook[call.name]) {\n            return runNextMiddleware(call);\n        }\n        var nextInvoked = false;\n        function next(call2, callback) {\n            nextInvoked = true;\n            // the result can contain\n            // - the non manipulated return value from an action\n            // - the non manipulated abort value\n            // - one of the above but manipulated through the callback function\n            result = runNextMiddleware(call2);\n            if (callback) {\n                result = callback(result);\n            }\n        }\n        var abortInvoked = false;\n        function abort(value) {\n            abortInvoked = true;\n            // overwrite the result\n            // can be manipulated through middlewares earlier in the queue using the callback fn\n            result = value;\n        }\n        handler(call, next, abort);\n        if (devMode()) {\n            if (!nextInvoked && !abortInvoked) {\n                var node2 = getStateTreeNode(call.tree);\n                throw fail$1(\"Neither the next() nor the abort() callback within the middleware \" + handler.name + \" for the action: \\\"\" + call.name + \"\\\" on the node: \" + node2.type.name + \" was invoked.\");\n            }\n            else if (nextInvoked && abortInvoked) {\n                var node2 = getStateTreeNode(call.tree);\n                throw fail$1(\"The next() and abort() callback within the middleware \" + handler.name + \" for the action: \\\"\" + call.name + \"\\\" on the node: \" + node2.type.name + \" were invoked.\");\n            }\n        }\n        return result;\n    }\n    return runNextMiddleware(baseCall);\n}\n\n/**\n * Returns the currently executing MST action context, or undefined if none.\n */\nfunction getRunningActionContext() {\n    var current = getCurrentActionContext();\n    while (current && current.type !== \"action\") {\n        current = current.parentActionEvent;\n    }\n    return current;\n}\nfunction _isActionContextThisOrChildOf(actionContext, sameOrParent, includeSame) {\n    var parentId = typeof sameOrParent === \"number\" ? sameOrParent : sameOrParent.id;\n    var current = includeSame\n        ? actionContext\n        : actionContext.parentActionEvent;\n    while (current) {\n        if (current.id === parentId) {\n            return true;\n        }\n        current = current.parentActionEvent;\n    }\n    return false;\n}\n/**\n * Returns if the given action context is a parent of this action context.\n */\nfunction isActionContextChildOf(actionContext, parent) {\n    return _isActionContextThisOrChildOf(actionContext, parent, false);\n}\n/**\n * Returns if the given action context is this or a parent of this action context.\n */\nfunction isActionContextThisOrChildOf(actionContext, parentOrThis) {\n    return _isActionContextThisOrChildOf(actionContext, parentOrThis, true);\n}\n\nfunction safeStringify(value) {\n    try {\n        return JSON.stringify(value);\n    }\n    catch (e) {\n        // istanbul ignore next\n        return \"<Unserializable: \" + e + \">\";\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction prettyPrintValue(value) {\n    return typeof value === \"function\"\n        ? \"<function\" + (value.name ? \" \" + value.name : \"\") + \">\"\n        : isStateTreeNode(value)\n            ? \"<\" + value + \">\"\n            : \"`\" + safeStringify(value) + \"`\";\n}\nfunction shortenPrintValue(valueInString) {\n    return valueInString.length < 280\n        ? valueInString\n        : valueInString.substring(0, 272) + \"......\" + valueInString.substring(valueInString.length - 8);\n}\nfunction toErrorString(error) {\n    var value = error.value;\n    var type = error.context[error.context.length - 1].type;\n    var fullPath = error.context\n        .map(function (_a) {\n        var path = _a.path;\n        return path;\n    })\n        .filter(function (path) { return path.length > 0; })\n        .join(\"/\");\n    var pathPrefix = fullPath.length > 0 ? \"at path \\\"/\" + fullPath + \"\\\" \" : \"\";\n    var currentTypename = isStateTreeNode(value)\n        ? \"value of type \" + getStateTreeNode(value).type.name + \":\"\n        : isPrimitive(value)\n            ? \"value\"\n            : \"snapshot\";\n    var isSnapshotCompatible = type && isStateTreeNode(value) && type.is(getStateTreeNode(value).snapshot);\n    return (\"\" + pathPrefix + currentTypename + \" \" + prettyPrintValue(value) + \" is not assignable \" + (type ? \"to type: `\" + type.name + \"`\" : \"\") +\n        (error.message ? \" (\" + error.message + \")\" : \"\") +\n        (type\n            ? isPrimitiveType(type) || isPrimitive(value)\n                ? \".\"\n                : \", expected an instance of `\" + type.name + \"` or a snapshot like `\" + type.describe() + \"` instead.\" +\n                    (isSnapshotCompatible\n                        ? \" (Note that a snapshot of the provided value is compatible with the targeted type)\"\n                        : \"\")\n            : \".\"));\n}\n/**\n * @internal\n * @hidden\n */\nfunction getContextForPath(context, path, type) {\n    return context.concat([{ path: path, type: type }]);\n}\n/**\n * @internal\n * @hidden\n */\nfunction typeCheckSuccess() {\n    return EMPTY_ARRAY;\n}\n/**\n * @internal\n * @hidden\n */\nfunction typeCheckFailure(context, value, message) {\n    return [{ context: context, value: value, message: message }];\n}\n/**\n * @internal\n * @hidden\n */\nfunction flattenTypeErrors(errors) {\n    return errors.reduce(function (a, i) { return a.concat(i); }, []);\n}\n// TODO; doublecheck: typecheck should only needed to be invoked from: type.create and array / map / value.property will change\n/**\n * @internal\n * @hidden\n */\nfunction typecheckInternal(type, value) {\n    // runs typeChecking if it is in dev-mode or through a process.env.ENABLE_TYPE_CHECK flag\n    if (isTypeCheckingEnabled()) {\n        typecheck(type, value);\n    }\n}\n/**\n * Run's the typechecker for the given type on the given value, which can be a snapshot or an instance.\n * Throws if the given value is not according the provided type specification.\n * Use this if you need typechecks even in a production build (by default all automatic runtime type checks will be skipped in production builds)\n *\n * @param type Type to check against.\n * @param value Value to be checked, either a snapshot or an instance.\n */\nfunction typecheck(type, value) {\n    var errors = type.validate(value, [{ path: \"\", type: type }]);\n    if (errors.length > 0) {\n        throw fail$1(validationErrorsToString(type, value, errors));\n    }\n}\nfunction validationErrorsToString(type, value, errors) {\n    if (errors.length === 0) {\n        return undefined;\n    }\n    return (\"Error while converting \" + shortenPrintValue(prettyPrintValue(value)) + \" to `\" + type.name + \"`:\\n\\n    \" + errors.map(toErrorString).join(\"\\n    \"));\n}\n\nvar identifierCacheId = 0;\n/**\n * @internal\n * @hidden\n */\nvar IdentifierCache = /** @class */ (function () {\n    function IdentifierCache() {\n        this.cacheId = identifierCacheId++;\n        // n.b. in cache all identifiers are normalized to strings\n        this.cache = observable.map();\n        // last time the cache (array) for a given time changed\n        // n.b. it is not really the time, but just an integer that gets increased after each modification to the array\n        this.lastCacheModificationPerId = observable.map();\n    }\n    IdentifierCache.prototype.updateLastCacheModificationPerId = function (identifier) {\n        var lcm = this.lastCacheModificationPerId.get(identifier);\n        // we start at 1 since 0 means no update since cache creation\n        this.lastCacheModificationPerId.set(identifier, lcm === undefined ? 1 : lcm + 1);\n    };\n    IdentifierCache.prototype.getLastCacheModificationPerId = function (identifier) {\n        var modificationId = this.lastCacheModificationPerId.get(identifier) || 0;\n        return this.cacheId + \"-\" + modificationId;\n    };\n    IdentifierCache.prototype.addNodeToCache = function (node, lastCacheUpdate) {\n        if (lastCacheUpdate === void 0) { lastCacheUpdate = true; }\n        if (node.identifierAttribute) {\n            var identifier = node.identifier;\n            if (!this.cache.has(identifier)) {\n                this.cache.set(identifier, observable.array([], mobxShallow));\n            }\n            var set = this.cache.get(identifier);\n            if (set.indexOf(node) !== -1)\n                throw fail$1(\"Already registered\");\n            set.push(node);\n            if (lastCacheUpdate) {\n                this.updateLastCacheModificationPerId(identifier);\n            }\n        }\n    };\n    IdentifierCache.prototype.mergeCache = function (node) {\n        var _this = this;\n        values(node.identifierCache.cache).forEach(function (nodes) {\n            return nodes.forEach(function (child) {\n                _this.addNodeToCache(child);\n            });\n        });\n    };\n    IdentifierCache.prototype.notifyDied = function (node) {\n        if (node.identifierAttribute) {\n            var id = node.identifier;\n            var set = this.cache.get(id);\n            if (set) {\n                set.remove(node);\n                // remove empty sets from cache\n                if (!set.length) {\n                    this.cache.delete(id);\n                }\n                this.updateLastCacheModificationPerId(node.identifier);\n            }\n        }\n    };\n    IdentifierCache.prototype.splitCache = function (node) {\n        var _this = this;\n        var res = new IdentifierCache();\n        var basePath = node.path;\n        entries(this.cache).forEach(function (_a) {\n            var _b = __read(_a, 2), id = _b[0], nodes = _b[1];\n            var modified = false;\n            for (var i = nodes.length - 1; i >= 0; i--) {\n                if (nodes[i].path.indexOf(basePath) === 0) {\n                    res.addNodeToCache(nodes[i], false); // no need to update lastUpdated since it is a whole new cache\n                    nodes.splice(i, 1);\n                    modified = true;\n                }\n            }\n            if (modified) {\n                _this.updateLastCacheModificationPerId(id);\n            }\n        });\n        return res;\n    };\n    IdentifierCache.prototype.has = function (type, identifier) {\n        var set = this.cache.get(identifier);\n        if (!set)\n            return false;\n        return set.some(function (candidate) { return type.isAssignableFrom(candidate.type); });\n    };\n    IdentifierCache.prototype.resolve = function (type, identifier) {\n        var set = this.cache.get(identifier);\n        if (!set)\n            return null;\n        var matches = set.filter(function (candidate) { return type.isAssignableFrom(candidate.type); });\n        switch (matches.length) {\n            case 0:\n                return null;\n            case 1:\n                return matches[0];\n            default:\n                throw fail$1(\"Cannot resolve a reference to type '\" + type.name + \"' with id: '\" + identifier + \"' unambigously, there are multiple candidates: \" + matches\n                    .map(function (n) { return n.path; })\n                    .join(\", \"));\n        }\n    };\n    return IdentifierCache;\n}());\n\n/**\n * @internal\n * @hidden\n */\nfunction createObjectNode(type, parent, subpath, environment, initialValue) {\n    var existingNode = getStateTreeNodeSafe(initialValue);\n    if (existingNode) {\n        if (existingNode.parent) {\n            // istanbul ignore next\n            throw fail$1(\"Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '\" + (parent ? parent.path : \"\") + \"/\" + subpath + \"', but it lives already at '\" + existingNode.path + \"'\");\n        }\n        if (parent) {\n            existingNode.setParent(parent, subpath);\n        }\n        // else it already has no parent since it is a pre-requisite\n        return existingNode;\n    }\n    // not a node, a snapshot\n    return new ObjectNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\nfunction createScalarNode(type, parent, subpath, environment, initialValue) {\n    return new ScalarNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\nfunction isNode(value) {\n    return value instanceof ScalarNode || value instanceof ObjectNode;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar NodeLifeCycle;\n(function (NodeLifeCycle) {\n    NodeLifeCycle[NodeLifeCycle[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n    NodeLifeCycle[NodeLifeCycle[\"CREATED\"] = 1] = \"CREATED\";\n    NodeLifeCycle[NodeLifeCycle[\"FINALIZED\"] = 2] = \"FINALIZED\";\n    NodeLifeCycle[NodeLifeCycle[\"DETACHING\"] = 3] = \"DETACHING\";\n    NodeLifeCycle[NodeLifeCycle[\"DEAD\"] = 4] = \"DEAD\"; // no coming back from this one\n})(NodeLifeCycle || (NodeLifeCycle = {}));\n/**\n * Returns true if the given value is a node in a state tree.\n * More precisely, that is, if the value is an instance of a\n * `types.model`, `types.array` or `types.map`.\n *\n * @param value\n * @returns true if the value is a state tree node.\n */\nfunction isStateTreeNode(value) {\n    return !!(value && value.$treenode);\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsStateTreeNode(value, argNumber) {\n    assertArg(value, isStateTreeNode, \"mobx-state-tree node\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\nfunction getStateTreeNode(value) {\n    if (!isStateTreeNode(value)) {\n        // istanbul ignore next\n        throw fail$1(\"Value \" + value + \" is no MST Node\");\n    }\n    return value.$treenode;\n}\n/**\n * @internal\n * @hidden\n */\nfunction getStateTreeNodeSafe(value) {\n    return (value && value.$treenode) || null;\n}\n/**\n * @internal\n * @hidden\n */\nfunction toJSON() {\n    return getStateTreeNode(this).snapshot;\n}\nvar doubleDot = function (_) { return \"..\"; };\n/**\n * @internal\n * @hidden\n */\nfunction getRelativePathBetweenNodes(base, target) {\n    // PRE condition target is (a child of) base!\n    if (base.root !== target.root) {\n        throw fail$1(\"Cannot calculate relative path: objects '\" + base + \"' and '\" + target + \"' are not part of the same object tree\");\n    }\n    var baseParts = splitJsonPath(base.path);\n    var targetParts = splitJsonPath(target.path);\n    var common = 0;\n    for (; common < baseParts.length; common++) {\n        if (baseParts[common] !== targetParts[common])\n            break;\n    }\n    // TODO: assert that no targetParts paths are \"..\", \".\" or \"\"!\n    return (baseParts\n        .slice(common)\n        .map(doubleDot)\n        .join(\"/\") + joinJsonPath(targetParts.slice(common)));\n}\n/**\n * @internal\n * @hidden\n */\nfunction resolveNodeByPath(base, path, failIfResolveFails) {\n    if (failIfResolveFails === void 0) { failIfResolveFails = true; }\n    return resolveNodeByPathParts(base, splitJsonPath(path), failIfResolveFails);\n}\n/**\n * @internal\n * @hidden\n */\nfunction resolveNodeByPathParts(base, pathParts, failIfResolveFails) {\n    if (failIfResolveFails === void 0) { failIfResolveFails = true; }\n    var current = base;\n    for (var i = 0; i < pathParts.length; i++) {\n        var part = pathParts[i];\n        if (part === \"..\") {\n            current = current.parent;\n            if (current)\n                continue; // not everything has a parent\n        }\n        else if (part === \".\") {\n            continue;\n        }\n        else if (current) {\n            if (current instanceof ScalarNode) {\n                // check if the value of a scalar resolves to a state tree node (e.g. references)\n                // then we can continue resolving...\n                try {\n                    var value = current.value;\n                    if (isStateTreeNode(value)) {\n                        current = getStateTreeNode(value);\n                        // fall through\n                    }\n                }\n                catch (e) {\n                    if (!failIfResolveFails) {\n                        return undefined;\n                    }\n                    throw e;\n                }\n            }\n            if (current instanceof ObjectNode) {\n                var subType = current.getChildType(part);\n                if (subType) {\n                    current = current.getChildNode(part);\n                    if (current)\n                        continue;\n                }\n            }\n        }\n        if (failIfResolveFails)\n            throw fail$1(\"Could not resolve '\" + part + \"' in path '\" + (joinJsonPath(pathParts.slice(0, i)) ||\n                \"/\") + \"' while resolving '\" + joinJsonPath(pathParts) + \"'\");\n        else\n            return undefined;\n    }\n    return current;\n}\n/**\n * @internal\n * @hidden\n */\nfunction convertChildNodesToArray(childNodes) {\n    if (!childNodes)\n        return EMPTY_ARRAY;\n    var keys = Object.keys(childNodes);\n    if (!keys.length)\n        return EMPTY_ARRAY;\n    var result = new Array(keys.length);\n    keys.forEach(function (key, index) {\n        result[index] = childNodes[key];\n    });\n    return result;\n}\n\n// based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts\n/*\n    All contents of this file are deprecated.\n\n    The term `process` has been replaced with `flow` to avoid conflicts with the\n    global `process` object.\n\n    Refer to `flow.ts` for any further changes to this implementation.\n*/\nvar DEPRECATION_MESSAGE = \"See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information. \" +\n    \"Note that the middleware event types starting with `process` now start with `flow`.\";\n/**\n * @hidden\n *\n * @deprecated has been renamed to `flow()`.\n * See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information.\n * Note that the middleware event types starting with `process` now start with `flow`.\n *\n * @returns {Promise}\n */\nfunction process$1(asyncAction) {\n    deprecated(\"process\", \"`process()` has been renamed to `flow()`. \" + DEPRECATION_MESSAGE);\n    return flow(asyncAction);\n}\n\n/**\n * @internal\n * @hidden\n */\nvar EMPTY_ARRAY = Object.freeze([]);\n/**\n * @internal\n * @hidden\n */\nvar EMPTY_OBJECT = Object.freeze({});\n/**\n * @internal\n * @hidden\n */\nvar mobxShallow = typeof $mobx === \"string\" ? { deep: false } : { deep: false, proxy: false };\nObject.freeze(mobxShallow);\n/**\n * @internal\n * @hidden\n */\nfunction fail$1(message) {\n    if (message === void 0) { message = \"Illegal state\"; }\n    return new Error(\"[mobx-state-tree] \" + message);\n}\n/**\n * @internal\n * @hidden\n */\nfunction identity(_) {\n    return _;\n}\n/**\n * pollyfill (for IE) suggested in MDN:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n * @internal\n * @hidden\n */\nvar isInteger = Number.isInteger ||\n    function (value) {\n        return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n/**\n * @internal\n * @hidden\n */\nfunction isArray(val) {\n    return Array.isArray(val) || isObservableArray(val);\n}\n/**\n * @internal\n * @hidden\n */\nfunction asArray(val) {\n    if (!val)\n        return EMPTY_ARRAY;\n    if (isArray(val))\n        return val;\n    return [val];\n}\n/**\n * @internal\n * @hidden\n */\nfunction extend(a) {\n    var b = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        b[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < b.length; i++) {\n        var current = b[i];\n        for (var key in current)\n            a[key] = current[key];\n    }\n    return a;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isPlainObject(value) {\n    if (value === null || typeof value !== \"object\")\n        return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isMutable(value) {\n    return (value !== null &&\n        typeof value === \"object\" &&\n        !(value instanceof Date) &&\n        !(value instanceof RegExp));\n}\n/**\n * @internal\n * @hidden\n */\nfunction isPrimitive(value, includeDate) {\n    if (includeDate === void 0) { includeDate = true; }\n    if (value === null || value === undefined)\n        return true;\n    if (typeof value === \"string\" ||\n        typeof value === \"number\" ||\n        typeof value === \"boolean\" ||\n        (includeDate && value instanceof Date))\n        return true;\n    return false;\n}\n/**\n * @internal\n * @hidden\n * Freeze a value and return it (if not in production)\n */\nfunction freeze(value) {\n    if (!devMode())\n        return value;\n    return isPrimitive(value) || isObservableArray(value) ? value : Object.freeze(value);\n}\n/**\n * @internal\n * @hidden\n * Recursively freeze a value (if not in production)\n */\nfunction deepFreeze(value) {\n    if (!devMode())\n        return value;\n    freeze(value);\n    if (isPlainObject(value)) {\n        Object.keys(value).forEach(function (propKey) {\n            if (!isPrimitive(value[propKey]) &&\n                !Object.isFrozen(value[propKey])) {\n                deepFreeze(value[propKey]);\n            }\n        });\n    }\n    return value;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isSerializable(value) {\n    return typeof value !== \"function\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\n/**\n * @internal\n * @hidden\n */\nfunction addHiddenWritableProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\n/**\n * @internal\n * @hidden\n */\nvar EventHandler = /** @class */ (function () {\n    function EventHandler() {\n        this.handlers = [];\n    }\n    Object.defineProperty(EventHandler.prototype, \"hasSubscribers\", {\n        get: function () {\n            return this.handlers.length > 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    EventHandler.prototype.register = function (fn, atTheBeginning) {\n        var _this = this;\n        if (atTheBeginning === void 0) { atTheBeginning = false; }\n        if (atTheBeginning) {\n            this.handlers.unshift(fn);\n        }\n        else {\n            this.handlers.push(fn);\n        }\n        return function () {\n            _this.unregister(fn);\n        };\n    };\n    EventHandler.prototype.has = function (fn) {\n        return this.handlers.indexOf(fn) >= 0;\n    };\n    EventHandler.prototype.unregister = function (fn) {\n        var index = this.handlers.indexOf(fn);\n        if (index >= 0) {\n            this.handlers.splice(index, 1);\n        }\n    };\n    EventHandler.prototype.clear = function () {\n        this.handlers.length = 0;\n    };\n    EventHandler.prototype.emit = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // make a copy just in case it changes\n        var handlers = this.handlers.slice();\n        handlers.forEach(function (f) { return f.apply(void 0, __spread(args)); });\n    };\n    return EventHandler;\n}());\n/**\n * @internal\n * @hidden\n */\nvar EventHandlers = /** @class */ (function () {\n    function EventHandlers() {\n    }\n    EventHandlers.prototype.hasSubscribers = function (event) {\n        var handler = this.eventHandlers && this.eventHandlers[event];\n        return !!handler && handler.hasSubscribers;\n    };\n    EventHandlers.prototype.register = function (event, fn, atTheBeginning) {\n        if (atTheBeginning === void 0) { atTheBeginning = false; }\n        if (!this.eventHandlers) {\n            this.eventHandlers = {};\n        }\n        var handler = this.eventHandlers[event];\n        if (!handler) {\n            handler = this.eventHandlers[event] = new EventHandler();\n        }\n        return handler.register(fn, atTheBeginning);\n    };\n    EventHandlers.prototype.has = function (event, fn) {\n        var handler = this.eventHandlers && this.eventHandlers[event];\n        return !!handler && handler.has(fn);\n    };\n    EventHandlers.prototype.unregister = function (event, fn) {\n        var handler = this.eventHandlers && this.eventHandlers[event];\n        if (handler) {\n            handler.unregister(fn);\n        }\n    };\n    EventHandlers.prototype.clear = function (event) {\n        if (this.eventHandlers) {\n            delete this.eventHandlers[event];\n        }\n    };\n    EventHandlers.prototype.clearAll = function () {\n        this.eventHandlers = undefined;\n    };\n    EventHandlers.prototype.emit = function (event) {\n        var _a;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var handler = this.eventHandlers && this.eventHandlers[event];\n        if (handler) {\n            (_a = handler).emit.apply(_a, __spread(args));\n        }\n    };\n    return EventHandlers;\n}());\n/**\n * @internal\n * @hidden\n */\nfunction argsToArray(args) {\n    var res = new Array(args.length);\n    for (var i = 0; i < args.length; i++)\n        res[i] = args[i];\n    return res;\n}\n/**\n * @internal\n * @hidden\n */\nfunction invalidateComputed(target, propName) {\n    var atom = getAtom(target, propName);\n    atom.trackAndCompute();\n}\n/**\n * @internal\n * @hidden\n */\nfunction stringStartsWith(str, beginning) {\n    return str.indexOf(beginning) === 0;\n}\n/**\n * @internal\n * @hidden\n */\nvar deprecated = function (id, message) {\n    // skip if running production\n    if (!devMode())\n        return;\n    // warn if hasn't been warned before\n    if (deprecated.ids && !deprecated.ids.hasOwnProperty(id)) {\n        warnError(\"Deprecation warning: \" + message);\n    }\n    // mark as warned to avoid duplicate warn message\n    if (deprecated.ids)\n        deprecated.ids[id] = true;\n};\ndeprecated.ids = {};\n/**\n * @internal\n * @hidden\n */\nfunction warnError(msg) {\n    console.warn(new Error(\"[mobx-state-tree] \" + msg));\n}\n/**\n * @internal\n * @hidden\n */\nfunction isTypeCheckingEnabled() {\n    return (devMode() ||\n        (typeof process !== \"undefined\" && process.env && process.env.ENABLE_TYPE_CHECK === \"true\"));\n}\n/**\n * @internal\n * @hidden\n */\nfunction devMode() {\n    return process.env.NODE_ENV !== \"production\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertArg(value, fn, typeName, argNumber) {\n    if (devMode()) {\n        if (!fn(value)) {\n            // istanbul ignore next\n            throw fail$1(\"expected \" + typeName + \" as argument \" + asArray(argNumber).join(\" or \") + \", got \" + value + \" instead\");\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsFunction(value, argNumber) {\n    assertArg(value, function (fn) { return typeof fn === \"function\"; }, \"function\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsNumber(value, argNumber, min, max) {\n    assertArg(value, function (n) { return typeof n === \"number\"; }, \"number\", argNumber);\n    if (min !== undefined) {\n        assertArg(value, function (n) { return n >= min; }, \"number greater than \" + min, argNumber);\n    }\n    if (max !== undefined) {\n        assertArg(value, function (n) { return n <= max; }, \"number lesser than \" + max, argNumber);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsString(value, argNumber, canBeEmpty) {\n    if (canBeEmpty === void 0) { canBeEmpty = true; }\n    assertArg(value, function (s) { return typeof s === \"string\"; }, \"string\", argNumber);\n    if (!canBeEmpty) {\n        assertArg(value, function (s) { return s !== \"\"; }, \"not empty string\", argNumber);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction setImmediateWithFallback(fn) {\n    if (typeof queueMicrotask === \"function\") {\n        queueMicrotask(fn);\n    }\n    else if (typeof setImmediate === \"function\") {\n        setImmediate(fn);\n    }\n    else {\n        setTimeout(fn, 1);\n    }\n}\n\n/**\n * See [asynchronous actions](concepts/async-actions.md).\n *\n * @returns The flow as a promise.\n */\nfunction flow(generator) {\n    return createFlowSpawner(generator.name, generator);\n}\n/**\n * @deprecated Not needed since TS3.6.\n * Used for TypeScript to make flows that return a promise return the actual promise result.\n *\n * @param val\n * @returns\n */\nfunction castFlowReturn(val) {\n    return val;\n}\n/**\n * @internal\n * @hidden\n */\nfunction createFlowSpawner(name, generator) {\n    var spawner = function flowSpawner() {\n        // Implementation based on https://github.com/tj/co/blob/master/index.js\n        var runId = getNextActionId();\n        var parentContext = getCurrentActionContext();\n        if (!parentContext) {\n            throw fail$1(\"a mst flow must always have a parent context\");\n        }\n        var parentActionContext = getParentActionContext(parentContext);\n        if (!parentActionContext) {\n            throw fail$1(\"a mst flow must always have a parent action context\");\n        }\n        var contextBase = {\n            name: name,\n            id: runId,\n            tree: parentContext.tree,\n            context: parentContext.context,\n            parentId: parentContext.id,\n            allParentIds: __spread(parentContext.allParentIds, [parentContext.id]),\n            rootId: parentContext.rootId,\n            parentEvent: parentContext,\n            parentActionEvent: parentActionContext\n        };\n        var args = arguments;\n        function wrap(fn, type, arg) {\n            fn.$mst_middleware = spawner.$mst_middleware; // pick up any middleware attached to the flow\n            runWithActionContext(__assign(__assign({}, contextBase), { type: type, args: [arg] }), fn);\n        }\n        return new Promise(function (resolve, reject) {\n            var gen;\n            var init = function asyncActionInit() {\n                gen = generator.apply(null, arguments);\n                onFulfilled(undefined); // kick off the flow\n            };\n            init.$mst_middleware = spawner.$mst_middleware;\n            runWithActionContext(__assign(__assign({}, contextBase), { type: \"flow_spawn\", args: argsToArray(args) }), init);\n            function onFulfilled(res) {\n                var ret;\n                try {\n                    // prettier-ignore\n                    wrap(function (r) { ret = gen.next(r); }, \"flow_resume\", res);\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediateWithFallback(function () {\n                        wrap(function (r) { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n                return;\n            }\n            function onRejected(err) {\n                var ret;\n                try {\n                    // prettier-ignore\n                    wrap(function (r) { ret = gen.throw(r); }, \"flow_resume_error\", err); // or yieldError?\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediateWithFallback(function () {\n                        wrap(function (r) { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n            }\n            function next(ret) {\n                if (ret.done) {\n                    // prettier-ignore\n                    setImmediateWithFallback(function () {\n                        wrap(function (r) { resolve(r); }, \"flow_return\", ret.value);\n                    });\n                    return;\n                }\n                // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100\n                if (!ret.value || typeof ret.value.then !== \"function\") {\n                    // istanbul ignore next\n                    throw fail$1(\"Only promises can be yielded to `async`, got: \" + ret);\n                }\n                return ret.value.then(onFulfilled, onRejected);\n            }\n        });\n    };\n    return spawner;\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction splitPatch(patch) {\n    if (!(\"oldValue\" in patch))\n        throw fail$1(\"Patches without `oldValue` field cannot be inversed\");\n    return [stripPatch(patch), invertPatch(patch)];\n}\n/**\n * @internal\n * @hidden\n */\nfunction stripPatch(patch) {\n    // strips `oldvalue` information from the patch, so that it becomes a patch conform the json-patch spec\n    // this removes the ability to undo the patch\n    switch (patch.op) {\n        case \"add\":\n            return { op: \"add\", path: patch.path, value: patch.value };\n        case \"remove\":\n            return { op: \"remove\", path: patch.path };\n        case \"replace\":\n            return { op: \"replace\", path: patch.path, value: patch.value };\n    }\n}\nfunction invertPatch(patch) {\n    switch (patch.op) {\n        case \"add\":\n            return {\n                op: \"remove\",\n                path: patch.path\n            };\n        case \"remove\":\n            return {\n                op: \"add\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n        case \"replace\":\n            return {\n                op: \"replace\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n    }\n}\n/**\n * Simple simple check to check it is a number.\n */\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\n/**\n * Escape slashes and backslashes.\n *\n * http://tools.ietf.org/html/rfc6901\n */\nfunction escapeJsonPath(path) {\n    if (isNumber(path) === true) {\n        return \"\" + path;\n    }\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1)\n        return path;\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescape slashes and backslashes.\n */\nfunction unescapeJsonPath(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n/**\n * Generates a json-path compliant json path from path parts.\n *\n * @param path\n * @returns\n */\nfunction joinJsonPath(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    if (path.length === 0)\n        return \"\";\n    var getPathStr = function (p) { return p.map(escapeJsonPath).join(\"/\"); };\n    if (path[0] === \".\" || path[0] === \"..\") {\n        // relative\n        return getPathStr(path);\n    }\n    else {\n        // absolute\n        return \"/\" + getPathStr(path);\n    }\n}\n/**\n * Splits and decodes a json path into several parts.\n *\n * @param path\n * @returns\n */\nfunction splitJsonPath(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    var parts = path.split(\"/\").map(unescapeJsonPath);\n    var valid = path === \"\" ||\n        path === \".\" ||\n        path === \"..\" ||\n        stringStartsWith(path, \"/\") ||\n        stringStartsWith(path, \"./\") ||\n        stringStartsWith(path, \"../\");\n    if (!valid) {\n        throw fail$1(\"a json path must be either rooted, empty or relative, but got '\" + path + \"'\");\n    }\n    // '/a/b/c' -> [\"a\", \"b\", \"c\"]\n    // '../../b/c' -> [\"..\", \"..\", \"b\", \"c\"]\n    // '' -> []\n    // '/' -> ['']\n    // './a' -> [\".\", \"a\"]\n    // /./a' -> [\".\", \"a\"] equivalent to './a'\n    if (parts[0] === \"\") {\n        parts.shift();\n    }\n    return parts;\n}\n\nvar SnapshotProcessor = /** @class */ (function (_super) {\n    __extends(SnapshotProcessor, _super);\n    function SnapshotProcessor(_subtype, _processors, name) {\n        var _this = _super.call(this, name || _subtype.name) || this;\n        _this._subtype = _subtype;\n        _this._processors = _processors;\n        return _this;\n    }\n    Object.defineProperty(SnapshotProcessor.prototype, \"flags\", {\n        get: function () {\n            return this._subtype.flags | TypeFlags.SnapshotProcessor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SnapshotProcessor.prototype.describe = function () {\n        return \"snapshotProcessor(\" + this._subtype.describe() + \")\";\n    };\n    SnapshotProcessor.prototype.preProcessSnapshot = function (sn) {\n        if (this._processors.preProcessor) {\n            return this._processors.preProcessor.call(null, sn);\n        }\n        return sn;\n    };\n    SnapshotProcessor.prototype.postProcessSnapshot = function (sn) {\n        if (this._processors.postProcessor) {\n            return this._processors.postProcessor.call(null, sn);\n        }\n        return sn;\n    };\n    SnapshotProcessor.prototype._fixNode = function (node) {\n        var _this = this;\n        // the node has to use these methods rather than the original type ones\n        proxyNodeTypeMethods(node.type, this, \"isAssignableFrom\", \"create\");\n        var oldGetSnapshot = node.getSnapshot;\n        node.getSnapshot = function () {\n            return _this.postProcessSnapshot(oldGetSnapshot.call(node));\n        };\n    };\n    SnapshotProcessor.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        var processedInitialValue = isStateTreeNode(initialValue)\n            ? initialValue\n            : this.preProcessSnapshot(initialValue);\n        var node = this._subtype.instantiate(parent, subpath, environment, processedInitialValue);\n        this._fixNode(node);\n        return node;\n    };\n    SnapshotProcessor.prototype.reconcile = function (current, newValue, parent, subpath) {\n        var node = this._subtype.reconcile(current, isStateTreeNode(newValue) ? newValue : this.preProcessSnapshot(newValue), parent, subpath);\n        if (node !== current) {\n            this._fixNode(node);\n        }\n        return node;\n    };\n    SnapshotProcessor.prototype.getSnapshot = function (node, applyPostProcess) {\n        if (applyPostProcess === void 0) { applyPostProcess = true; }\n        var sn = this._subtype.getSnapshot(node);\n        return applyPostProcess ? this.postProcessSnapshot(sn) : sn;\n    };\n    SnapshotProcessor.prototype.isValidSnapshot = function (value, context) {\n        var processedSn = this.preProcessSnapshot(value);\n        return this._subtype.validate(processedSn, context);\n    };\n    SnapshotProcessor.prototype.getSubTypes = function () {\n        return this._subtype;\n    };\n    SnapshotProcessor.prototype.is = function (thing) {\n        var value = isType(thing)\n            ? this._subtype\n            : isStateTreeNode(thing)\n                ? getSnapshot(thing, false)\n                : this.preProcessSnapshot(thing);\n        return this._subtype.validate(value, [{ path: \"\", type: this._subtype }]).length === 0;\n    };\n    return SnapshotProcessor;\n}(BaseType));\nfunction proxyNodeTypeMethods(nodeType, snapshotProcessorType) {\n    var e_1, _a;\n    var methods = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        methods[_i - 2] = arguments[_i];\n    }\n    try {\n        for (var methods_1 = __values(methods), methods_1_1 = methods_1.next(); !methods_1_1.done; methods_1_1 = methods_1.next()) {\n            var method = methods_1_1.value;\n            nodeType[method] = snapshotProcessorType[method].bind(snapshotProcessorType);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (methods_1_1 && !methods_1_1.done && (_a = methods_1.return)) _a.call(methods_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\n/**\n * `types.snapshotProcessor` - Runs a pre/post snapshot processor before/after serializing a given type.\n *\n * Example:\n * ```ts\n * const Todo1 = types.model({ text: types.string })\n * // in the backend the text type must be null when empty\n * interface BackendTodo {\n *     text: string | null\n * }\n * const Todo2 = types.snapshotProcessor(Todo1, {\n *     // from snapshot to instance\n *     preProcessor(sn: BackendTodo) {\n *         return {\n *             text: sn.text || \"\";\n *         }\n *     },\n *     // from instance to snapshot\n *     postProcessor(sn): BackendTodo {\n *         return {\n *             text: !sn.text ? null : sn.text\n *         }\n *     }\n * })\n * ```\n *\n * @param type Type to run the processors over.\n * @param processors Processors to run.\n * @param name Type name, or undefined to inherit the inner type one.\n * @returns\n */\nfunction snapshotProcessor(type, processors, name) {\n    assertIsType(type, 1);\n    if (devMode()) {\n        if (processors.postProcessor && typeof processors.postProcessor !== \"function\") {\n            // istanbul ignore next\n            throw fail(\"postSnapshotProcessor must be a function\");\n        }\n        if (processors.preProcessor && typeof processors.preProcessor !== \"function\") {\n            // istanbul ignore next\n            throw fail(\"preSnapshotProcessor must be a function\");\n        }\n    }\n    return new SnapshotProcessor(type, processors, name);\n}\n\nvar needsIdentifierError = \"Map.put can only be used to store complex values that have an identifier type attribute\";\nfunction tryCollectModelTypes(type, modelTypes) {\n    var e_1, _a;\n    var subtypes = type.getSubTypes();\n    if (subtypes === cannotDetermineSubtype) {\n        return false;\n    }\n    if (subtypes) {\n        var subtypesArray = asArray(subtypes);\n        try {\n            for (var subtypesArray_1 = __values(subtypesArray), subtypesArray_1_1 = subtypesArray_1.next(); !subtypesArray_1_1.done; subtypesArray_1_1 = subtypesArray_1.next()) {\n                var subtype = subtypesArray_1_1.value;\n                if (!tryCollectModelTypes(subtype, modelTypes))\n                    return false;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (subtypesArray_1_1 && !subtypesArray_1_1.done && (_a = subtypesArray_1.return)) _a.call(subtypesArray_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    if (type instanceof ModelType) {\n        modelTypes.push(type);\n    }\n    return true;\n}\n/**\n * @internal\n * @hidden\n */\nvar MapIdentifierMode;\n(function (MapIdentifierMode) {\n    MapIdentifierMode[MapIdentifierMode[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    MapIdentifierMode[MapIdentifierMode[\"YES\"] = 1] = \"YES\";\n    MapIdentifierMode[MapIdentifierMode[\"NO\"] = 2] = \"NO\";\n})(MapIdentifierMode || (MapIdentifierMode = {}));\nvar MSTMap = /** @class */ (function (_super) {\n    __extends(MSTMap, _super);\n    function MSTMap(initialData) {\n        return _super.call(this, initialData, observable.ref.enhancer) || this;\n    }\n    MSTMap.prototype.get = function (key) {\n        // maybe this is over-enthousiastic? normalize numeric keys to strings\n        return _super.prototype.get.call(this, \"\" + key);\n    };\n    MSTMap.prototype.has = function (key) {\n        return _super.prototype.has.call(this, \"\" + key);\n    };\n    MSTMap.prototype.delete = function (key) {\n        return _super.prototype.delete.call(this, \"\" + key);\n    };\n    MSTMap.prototype.set = function (key, value) {\n        return _super.prototype.set.call(this, \"\" + key, value);\n    };\n    MSTMap.prototype.put = function (value) {\n        if (!value)\n            throw fail$1(\"Map.put cannot be used to set empty values\");\n        if (isStateTreeNode(value)) {\n            var node = getStateTreeNode(value);\n            if (devMode()) {\n                if (!node.identifierAttribute) {\n                    throw fail$1(needsIdentifierError);\n                }\n            }\n            if (node.identifier === null) {\n                throw fail$1(needsIdentifierError);\n            }\n            this.set(node.identifier, value);\n            return value;\n        }\n        else if (!isMutable(value)) {\n            throw fail$1(\"Map.put can only be used to store complex values\");\n        }\n        else {\n            var mapNode = getStateTreeNode(this);\n            var mapType = mapNode.type;\n            if (mapType.identifierMode !== MapIdentifierMode.YES) {\n                throw fail$1(needsIdentifierError);\n            }\n            var idAttr = mapType.mapIdentifierAttribute;\n            var id = value[idAttr];\n            if (!isValidIdentifier(id)) {\n                // try again but this time after creating a node for the value\n                // since it might be an optional identifier\n                var newNode = this.put(mapType.getChildType().create(value, mapNode.environment));\n                return this.put(getSnapshot(newNode));\n            }\n            var key = normalizeIdentifier(id);\n            this.set(key, value);\n            return this.get(key);\n        }\n    };\n    return MSTMap;\n}(ObservableMap));\n/**\n * @internal\n * @hidden\n */\nvar MapType = /** @class */ (function (_super) {\n    __extends(MapType, _super);\n    function MapType(name, _subType, hookInitializers) {\n        if (hookInitializers === void 0) { hookInitializers = []; }\n        var _this = _super.call(this, name) || this;\n        _this._subType = _subType;\n        _this.identifierMode = MapIdentifierMode.UNKNOWN;\n        _this.mapIdentifierAttribute = undefined;\n        _this.flags = TypeFlags.Map;\n        _this.hookInitializers = [];\n        _this._determineIdentifierMode();\n        _this.hookInitializers = hookInitializers;\n        return _this;\n    }\n    MapType.prototype.hooks = function (hooks) {\n        var hookInitializers = this.hookInitializers.length > 0 ? this.hookInitializers.concat(hooks) : [hooks];\n        return new MapType(this.name, this._subType, hookInitializers);\n    };\n    MapType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        this._determineIdentifierMode();\n        return createObjectNode(this, parent, subpath, environment, initialValue);\n    };\n    MapType.prototype._determineIdentifierMode = function () {\n        if (this.identifierMode !== MapIdentifierMode.UNKNOWN) {\n            return;\n        }\n        var modelTypes = [];\n        if (tryCollectModelTypes(this._subType, modelTypes)) {\n            var identifierAttribute_1 = undefined;\n            modelTypes.forEach(function (type) {\n                if (type.identifierAttribute) {\n                    if (identifierAttribute_1 && identifierAttribute_1 !== type.identifierAttribute) {\n                        throw fail$1(\"The objects in a map should all have the same identifier attribute, expected '\" + identifierAttribute_1 + \"', but child of type '\" + type.name + \"' declared attribute '\" + type.identifierAttribute + \"' as identifier\");\n                    }\n                    identifierAttribute_1 = type.identifierAttribute;\n                }\n            });\n            if (identifierAttribute_1) {\n                this.identifierMode = MapIdentifierMode.YES;\n                this.mapIdentifierAttribute = identifierAttribute_1;\n            }\n            else {\n                this.identifierMode = MapIdentifierMode.NO;\n            }\n        }\n    };\n    MapType.prototype.initializeChildNodes = function (objNode, initialSnapshot) {\n        if (initialSnapshot === void 0) { initialSnapshot = {}; }\n        var subType = objNode.type._subType;\n        var result = {};\n        Object.keys(initialSnapshot).forEach(function (name) {\n            result[name] = subType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n        });\n        return result;\n    };\n    MapType.prototype.createNewInstance = function (childNodes) {\n        return new MSTMap(childNodes);\n    };\n    MapType.prototype.finalizeNewInstance = function (node, instance) {\n        _interceptReads(instance, node.unbox);\n        var type = node.type;\n        type.hookInitializers.forEach(function (initializer) {\n            var hooks = initializer(instance);\n            Object.keys(hooks).forEach(function (name) {\n                var hook = hooks[name];\n                var actionInvoker = createActionInvoker(instance, name, hook);\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n            });\n        });\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    };\n    MapType.prototype.describe = function () {\n        return \"Map<string, \" + this._subType.describe() + \">\";\n    };\n    MapType.prototype.getChildren = function (node) {\n        // return (node.storedValue as ObservableMap<any>).values()\n        return values(node.storedValue);\n    };\n    MapType.prototype.getChildNode = function (node, key) {\n        var childNode = node.storedValue.get(\"\" + key);\n        if (!childNode)\n            throw fail$1(\"Not a child \" + key);\n        return childNode;\n    };\n    MapType.prototype.willChange = function (change) {\n        var node = getStateTreeNode(change.object);\n        var key = change.name;\n        node.assertWritable({ subpath: key });\n        var mapType = node.type;\n        var subType = mapType._subType;\n        switch (change.type) {\n            case \"update\":\n                {\n                    var newValue = change.newValue;\n                    var oldValue = change.object.get(key);\n                    if (newValue === oldValue)\n                        return null;\n                    typecheckInternal(subType, newValue);\n                    change.newValue = subType.reconcile(node.getChildNode(key), change.newValue, node, key);\n                    mapType.processIdentifier(key, change.newValue);\n                }\n                break;\n            case \"add\":\n                {\n                    typecheckInternal(subType, change.newValue);\n                    change.newValue = subType.instantiate(node, key, undefined, change.newValue);\n                    mapType.processIdentifier(key, change.newValue);\n                }\n                break;\n        }\n        return change;\n    };\n    MapType.prototype.processIdentifier = function (expected, node) {\n        if (this.identifierMode === MapIdentifierMode.YES && node instanceof ObjectNode) {\n            var identifier = node.identifier;\n            if (identifier !== expected)\n                throw fail$1(\"A map of objects containing an identifier should always store the object under their own identifier. Trying to store key '\" + identifier + \"', but expected: '\" + expected + \"'\");\n        }\n    };\n    MapType.prototype.getSnapshot = function (node) {\n        var res = {};\n        node.getChildren().forEach(function (childNode) {\n            res[childNode.subpath] = childNode.snapshot;\n        });\n        return res;\n    };\n    MapType.prototype.processInitialSnapshot = function (childNodes) {\n        var processed = {};\n        Object.keys(childNodes).forEach(function (key) {\n            processed[key] = childNodes[key].getSnapshot();\n        });\n        return processed;\n    };\n    MapType.prototype.didChange = function (change) {\n        var node = getStateTreeNode(change.object);\n        switch (change.type) {\n            case \"update\":\n                return void node.emitPatch({\n                    op: \"replace\",\n                    path: escapeJsonPath(change.name),\n                    value: change.newValue.snapshot,\n                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                }, node);\n            case \"add\":\n                return void node.emitPatch({\n                    op: \"add\",\n                    path: escapeJsonPath(change.name),\n                    value: change.newValue.snapshot,\n                    oldValue: undefined\n                }, node);\n            case \"delete\":\n                // a node got deleted, get the old snapshot and make the node die\n                var oldSnapshot = change.oldValue.snapshot;\n                change.oldValue.die();\n                // emit the patch\n                return void node.emitPatch({\n                    op: \"remove\",\n                    path: escapeJsonPath(change.name),\n                    oldValue: oldSnapshot\n                }, node);\n        }\n    };\n    MapType.prototype.applyPatchLocally = function (node, subpath, patch) {\n        var target = node.storedValue;\n        switch (patch.op) {\n            case \"add\":\n            case \"replace\":\n                target.set(subpath, patch.value);\n                break;\n            case \"remove\":\n                target.delete(subpath);\n                break;\n        }\n    };\n    MapType.prototype.applySnapshot = function (node, snapshot) {\n        typecheckInternal(this, snapshot);\n        var target = node.storedValue;\n        var currentKeys = {};\n        Array.from(target.keys()).forEach(function (key) {\n            currentKeys[key] = false;\n        });\n        if (snapshot) {\n            // Don't use target.replace, as it will throw away all existing items first\n            for (var key in snapshot) {\n                target.set(key, snapshot[key]);\n                currentKeys[\"\" + key] = true;\n            }\n        }\n        Object.keys(currentKeys).forEach(function (key) {\n            if (currentKeys[key] === false)\n                target.delete(key);\n        });\n    };\n    MapType.prototype.getChildType = function () {\n        return this._subType;\n    };\n    MapType.prototype.isValidSnapshot = function (value, context) {\n        var _this = this;\n        if (!isPlainObject(value)) {\n            return typeCheckFailure(context, value, \"Value is not a plain object\");\n        }\n        return flattenTypeErrors(Object.keys(value).map(function (path) {\n            return _this._subType.validate(value[path], getContextForPath(context, path, _this._subType));\n        }));\n    };\n    MapType.prototype.getDefaultSnapshot = function () {\n        return EMPTY_OBJECT;\n    };\n    MapType.prototype.removeChild = function (node, subpath) {\n        node.storedValue.delete(subpath);\n    };\n    __decorate([\n        action\n    ], MapType.prototype, \"applySnapshot\", null);\n    return MapType;\n}(ComplexType));\n/**\n * `types.map` - Creates a key based collection type who's children are all of a uniform declared type.\n * If the type stored in a map has an identifier, it is mandatory to store the child under that identifier in the map.\n *\n * This type will always produce [observable maps](https://mobx.js.org/refguide/map.html)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   id: types.identifier,\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.map(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: {} })\n * unprotect(s)\n * s.todos.set(17, { task: \"Grab coffee\", id: 17 })\n * s.todos.put({ task: \"Grab cookie\", id: 18 }) // put will infer key from the identifier\n * console.log(s.todos.get(17).task) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\nfunction map(subtype) {\n    return new MapType(\"map<string, \" + subtype.name + \">\", subtype);\n}\n/**\n * Returns if a given value represents a map type.\n *\n * @param type\n * @returns `true` if it is a map type.\n */\nfunction isMapType(type) {\n    return isType(type) && (type.flags & TypeFlags.Map) > 0;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar ArrayType = /** @class */ (function (_super) {\n    __extends(ArrayType, _super);\n    function ArrayType(name, _subType, hookInitializers) {\n        if (hookInitializers === void 0) { hookInitializers = []; }\n        var _this = _super.call(this, name) || this;\n        _this._subType = _subType;\n        _this.flags = TypeFlags.Array;\n        _this.hookInitializers = [];\n        _this.hookInitializers = hookInitializers;\n        return _this;\n    }\n    ArrayType.prototype.hooks = function (hooks) {\n        var hookInitializers = this.hookInitializers.length > 0 ? this.hookInitializers.concat(hooks) : [hooks];\n        return new ArrayType(this.name, this._subType, hookInitializers);\n    };\n    ArrayType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        return createObjectNode(this, parent, subpath, environment, initialValue);\n    };\n    ArrayType.prototype.initializeChildNodes = function (objNode, snapshot) {\n        if (snapshot === void 0) { snapshot = []; }\n        var subType = objNode.type._subType;\n        var result = {};\n        snapshot.forEach(function (item, index) {\n            var subpath = \"\" + index;\n            result[subpath] = subType.instantiate(objNode, subpath, undefined, item);\n        });\n        return result;\n    };\n    ArrayType.prototype.createNewInstance = function (childNodes) {\n        return observable.array(convertChildNodesToArray(childNodes), mobxShallow);\n    };\n    ArrayType.prototype.finalizeNewInstance = function (node, instance) {\n        _getAdministration(instance).dehancer = node.unbox;\n        var type = node.type;\n        type.hookInitializers.forEach(function (initializer) {\n            var hooks = initializer(instance);\n            Object.keys(hooks).forEach(function (name) {\n                var hook = hooks[name];\n                var actionInvoker = createActionInvoker(instance, name, hook);\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n            });\n        });\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    };\n    ArrayType.prototype.describe = function () {\n        return this._subType.describe() + \"[]\";\n    };\n    ArrayType.prototype.getChildren = function (node) {\n        return node.storedValue.slice();\n    };\n    ArrayType.prototype.getChildNode = function (node, key) {\n        var index = Number(key);\n        if (index < node.storedValue.length)\n            return node.storedValue[index];\n        throw fail$1(\"Not a child: \" + key);\n    };\n    ArrayType.prototype.willChange = function (change) {\n        var node = getStateTreeNode(change.object);\n        node.assertWritable({ subpath: \"\" + change.index });\n        var subType = node.type._subType;\n        var childNodes = node.getChildren();\n        switch (change.type) {\n            case \"update\":\n                {\n                    if (change.newValue === change.object[change.index])\n                        return null;\n                    var updatedNodes = reconcileArrayChildren(node, subType, [childNodes[change.index]], [change.newValue], [change.index]);\n                    if (!updatedNodes) {\n                        return null;\n                    }\n                    change.newValue = updatedNodes[0];\n                }\n                break;\n            case \"splice\":\n                {\n                    var index_1 = change.index, removedCount = change.removedCount, added = change.added;\n                    var addedNodes = reconcileArrayChildren(node, subType, childNodes.slice(index_1, index_1 + removedCount), added, added.map(function (_, i) { return index_1 + i; }));\n                    if (!addedNodes) {\n                        return null;\n                    }\n                    change.added = addedNodes;\n                    // update paths of remaining items\n                    for (var i = index_1 + removedCount; i < childNodes.length; i++) {\n                        childNodes[i].setParent(node, \"\" + (i + added.length - removedCount));\n                    }\n                }\n                break;\n        }\n        return change;\n    };\n    ArrayType.prototype.getSnapshot = function (node) {\n        return node.getChildren().map(function (childNode) { return childNode.snapshot; });\n    };\n    ArrayType.prototype.processInitialSnapshot = function (childNodes) {\n        var processed = [];\n        Object.keys(childNodes).forEach(function (key) {\n            processed.push(childNodes[key].getSnapshot());\n        });\n        return processed;\n    };\n    ArrayType.prototype.didChange = function (change) {\n        var node = getStateTreeNode(change.object);\n        switch (change.type) {\n            case \"update\":\n                return void node.emitPatch({\n                    op: \"replace\",\n                    path: \"\" + change.index,\n                    value: change.newValue.snapshot,\n                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                }, node);\n            case \"splice\":\n                for (var i = change.removedCount - 1; i >= 0; i--)\n                    node.emitPatch({\n                        op: \"remove\",\n                        path: \"\" + (change.index + i),\n                        oldValue: change.removed[i].snapshot\n                    }, node);\n                for (var i = 0; i < change.addedCount; i++)\n                    node.emitPatch({\n                        op: \"add\",\n                        path: \"\" + (change.index + i),\n                        value: node.getChildNode(\"\" + (change.index + i)).snapshot,\n                        oldValue: undefined\n                    }, node);\n                return;\n        }\n    };\n    ArrayType.prototype.applyPatchLocally = function (node, subpath, patch) {\n        var target = node.storedValue;\n        var index = subpath === \"-\" ? target.length : Number(subpath);\n        switch (patch.op) {\n            case \"replace\":\n                target[index] = patch.value;\n                break;\n            case \"add\":\n                target.splice(index, 0, patch.value);\n                break;\n            case \"remove\":\n                target.splice(index, 1);\n                break;\n        }\n    };\n    ArrayType.prototype.applySnapshot = function (node, snapshot) {\n        typecheckInternal(this, snapshot);\n        var target = node.storedValue;\n        target.replace(snapshot);\n    };\n    ArrayType.prototype.getChildType = function () {\n        return this._subType;\n    };\n    ArrayType.prototype.isValidSnapshot = function (value, context) {\n        var _this = this;\n        if (!isArray(value)) {\n            return typeCheckFailure(context, value, \"Value is not an array\");\n        }\n        return flattenTypeErrors(value.map(function (item, index) {\n            return _this._subType.validate(item, getContextForPath(context, \"\" + index, _this._subType));\n        }));\n    };\n    ArrayType.prototype.getDefaultSnapshot = function () {\n        return EMPTY_ARRAY;\n    };\n    ArrayType.prototype.removeChild = function (node, subpath) {\n        node.storedValue.splice(Number(subpath), 1);\n    };\n    __decorate([\n        action\n    ], ArrayType.prototype, \"applySnapshot\", null);\n    return ArrayType;\n}(ComplexType));\n/**\n * `types.array` - Creates an index based collection type who's children are all of a uniform declared type.\n *\n * This type will always produce [observable arrays](https://mobx.js.org/refguide/array.html)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: [] })\n * unprotect(s) // needed to allow modifying outside of an action\n * s.todos.push({ task: \"Grab coffee\" })\n * console.log(s.todos[0]) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\nfunction array(subtype) {\n    assertIsType(subtype, 1);\n    return new ArrayType(subtype.name + \"[]\", subtype);\n}\nfunction reconcileArrayChildren(parent, childType, oldNodes, newValues, newPaths) {\n    var nothingChanged = true;\n    for (var i = 0;; i++) {\n        var hasNewNode = i <= newValues.length - 1;\n        var oldNode = oldNodes[i];\n        var newValue = hasNewNode ? newValues[i] : undefined;\n        var newPath = \"\" + newPaths[i];\n        // for some reason, instead of newValue we got a node, fallback to the storedValue\n        // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681\n        if (isNode(newValue))\n            newValue = newValue.storedValue;\n        if (!oldNode && !hasNewNode) {\n            // both are empty, end\n            break;\n        }\n        else if (!hasNewNode) {\n            // new one does not exists\n            nothingChanged = false;\n            oldNodes.splice(i, 1);\n            if (oldNode instanceof ObjectNode) {\n                // since it is going to be returned by pop/splice/shift better create it before killing it\n                // so it doesn't end up in an undead state\n                oldNode.createObservableInstanceIfNeeded();\n            }\n            oldNode.die();\n            i--;\n        }\n        else if (!oldNode) {\n            // there is no old node, create it\n            // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.\n            if (isStateTreeNode(newValue) && getStateTreeNode(newValue).parent === parent) {\n                // this node is owned by this parent, but not in the reconcilable set, so it must be double\n                throw fail$1(\"Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '\" + parent.path + \"/\" + newPath + \"', but it lives already at '\" + getStateTreeNode(newValue).path + \"'\");\n            }\n            nothingChanged = false;\n            var newNode = valueAsNode(childType, parent, newPath, newValue);\n            oldNodes.splice(i, 0, newNode);\n        }\n        else if (areSame(oldNode, newValue)) {\n            // both are the same, reconcile\n            oldNodes[i] = valueAsNode(childType, parent, newPath, newValue, oldNode);\n        }\n        else {\n            // nothing to do, try to reorder\n            var oldMatch = undefined;\n            // find a possible candidate to reuse\n            for (var j = i; j < oldNodes.length; j++) {\n                if (areSame(oldNodes[j], newValue)) {\n                    oldMatch = oldNodes.splice(j, 1)[0];\n                    break;\n                }\n            }\n            nothingChanged = false;\n            var newNode = valueAsNode(childType, parent, newPath, newValue, oldMatch);\n            oldNodes.splice(i, 0, newNode);\n        }\n    }\n    return nothingChanged ? null : oldNodes;\n}\n/**\n * Convert a value to a node at given parent and subpath. Attempts to reuse old node if possible and given.\n */\nfunction valueAsNode(childType, parent, subpath, newValue, oldNode) {\n    // ensure the value is valid-ish\n    typecheckInternal(childType, newValue);\n    function getNewNode() {\n        // the new value has a MST node\n        if (isStateTreeNode(newValue)) {\n            var childNode = getStateTreeNode(newValue);\n            childNode.assertAlive(EMPTY_OBJECT);\n            // the node lives here\n            if (childNode.parent !== null && childNode.parent === parent) {\n                childNode.setParent(parent, subpath);\n                return childNode;\n            }\n        }\n        // there is old node and new one is a value/snapshot\n        if (oldNode) {\n            return childType.reconcile(oldNode, newValue, parent, subpath);\n        }\n        // nothing to do, create from scratch\n        return childType.instantiate(parent, subpath, undefined, newValue);\n    }\n    var newNode = getNewNode();\n    if (oldNode && oldNode !== newNode) {\n        if (oldNode instanceof ObjectNode) {\n            // since it is going to be returned by pop/splice/shift better create it before killing it\n            // so it doesn't end up in an undead state\n            oldNode.createObservableInstanceIfNeeded();\n        }\n        oldNode.die();\n    }\n    return newNode;\n}\n/**\n * Check if a node holds a value.\n */\nfunction areSame(oldNode, newValue) {\n    // never consider dead old nodes for reconciliation\n    if (!oldNode.isAlive) {\n        return false;\n    }\n    // the new value has the same node\n    if (isStateTreeNode(newValue)) {\n        var newNode = getStateTreeNode(newValue);\n        return newNode.isAlive && newNode === oldNode;\n    }\n    // the provided value is the snapshot of the old node\n    if (oldNode.snapshot === newValue) {\n        return true;\n    }\n    // new value is a snapshot with the correct identifier\n    return (oldNode instanceof ObjectNode &&\n        oldNode.identifier !== null &&\n        oldNode.identifierAttribute &&\n        isPlainObject(newValue) &&\n        oldNode.identifier === normalizeIdentifier(newValue[oldNode.identifierAttribute]) &&\n        oldNode.type.is(newValue));\n}\n/**\n * Returns if a given value represents an array type.\n *\n * @param type\n * @returns `true` if the type is an array type.\n */\nfunction isArrayType(type) {\n    return isType(type) && (type.flags & TypeFlags.Array) > 0;\n}\n\nvar PRE_PROCESS_SNAPSHOT = \"preProcessSnapshot\";\nvar POST_PROCESS_SNAPSHOT = \"postProcessSnapshot\";\nfunction objectTypeToString() {\n    return getStateTreeNode(this).toString();\n}\nvar defaultObjectOptions = {\n    name: \"AnonymousModel\",\n    properties: {},\n    initializers: EMPTY_ARRAY\n};\nfunction toPropertiesObject(declaredProps) {\n    // loop through properties and ensures that all items are types\n    return Object.keys(declaredProps).reduce(function (props, key) {\n        var _a, _b, _c;\n        // warn if user intended a HOOK\n        if (key in Hook)\n            throw fail$1(\"Hook '\" + key + \"' was defined as property. Hooks should be defined as part of the actions\");\n        // the user intended to use a view\n        var descriptor = Object.getOwnPropertyDescriptor(props, key);\n        if (\"get\" in descriptor) {\n            throw fail$1(\"Getters are not supported as properties. Please use views instead\");\n        }\n        // undefined and null are not valid\n        var value = descriptor.value;\n        if (value === null || value === undefined) {\n            throw fail$1(\"The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?\");\n            // its a primitive, convert to its type\n        }\n        else if (isPrimitive(value)) {\n            return Object.assign({}, props, (_a = {},\n                _a[key] = optional(getPrimitiveFactoryFromValue(value), value),\n                _a));\n            // map defaults to empty object automatically for models\n        }\n        else if (value instanceof MapType) {\n            return Object.assign({}, props, (_b = {},\n                _b[key] = optional(value, {}),\n                _b));\n        }\n        else if (value instanceof ArrayType) {\n            return Object.assign({}, props, (_c = {}, _c[key] = optional(value, []), _c));\n            // its already a type\n        }\n        else if (isType(value)) {\n            return props;\n            // its a function, maybe the user wanted a view?\n        }\n        else if (devMode() && typeof value === \"function\") {\n            throw fail$1(\"Invalid type definition for property '\" + key + \"', it looks like you passed a function. Did you forget to invoke it, or did you intend to declare a view / action?\");\n            // no other complex values\n        }\n        else if (devMode() && typeof value === \"object\") {\n            throw fail$1(\"Invalid type definition for property '\" + key + \"', it looks like you passed an object. Try passing another model type or a types.frozen.\");\n            // WTF did you pass in mate?\n        }\n        else {\n            throw fail$1(\"Invalid type definition for property '\" + key + \"', cannot infer a type from a value like '\" + value + \"' (\" + typeof value + \")\");\n        }\n    }, declaredProps);\n}\n/**\n * @internal\n * @hidden\n */\nvar ModelType = /** @class */ (function (_super) {\n    __extends(ModelType, _super);\n    function ModelType(opts) {\n        var _this = _super.call(this, opts.name || defaultObjectOptions.name) || this;\n        _this.flags = TypeFlags.Object;\n        _this.named = function (name) {\n            return _this.cloneAndEnhance({ name: name });\n        };\n        _this.props = function (properties) {\n            return _this.cloneAndEnhance({ properties: properties });\n        };\n        _this.preProcessSnapshot = function (preProcessor) {\n            var currentPreprocessor = _this.preProcessor;\n            if (!currentPreprocessor)\n                return _this.cloneAndEnhance({ preProcessor: preProcessor });\n            else\n                return _this.cloneAndEnhance({\n                    preProcessor: function (snapshot) { return currentPreprocessor(preProcessor(snapshot)); }\n                });\n        };\n        _this.postProcessSnapshot = function (postProcessor) {\n            var currentPostprocessor = _this.postProcessor;\n            if (!currentPostprocessor)\n                return _this.cloneAndEnhance({ postProcessor: postProcessor });\n            else\n                return _this.cloneAndEnhance({\n                    postProcessor: function (snapshot) { return postProcessor(currentPostprocessor(snapshot)); }\n                });\n        };\n        Object.assign(_this, defaultObjectOptions, opts);\n        // ensures that any default value gets converted to its related type\n        _this.properties = toPropertiesObject(_this.properties);\n        freeze(_this.properties); // make sure nobody messes with it\n        _this.propertyNames = Object.keys(_this.properties);\n        _this.identifierAttribute = _this._getIdentifierAttribute();\n        return _this;\n    }\n    ModelType.prototype._getIdentifierAttribute = function () {\n        var identifierAttribute = undefined;\n        this.forAllProps(function (propName, propType) {\n            if (propType.flags & TypeFlags.Identifier) {\n                if (identifierAttribute)\n                    throw fail$1(\"Cannot define property '\" + propName + \"' as object identifier, property '\" + identifierAttribute + \"' is already defined as identifier property\");\n                identifierAttribute = propName;\n            }\n        });\n        return identifierAttribute;\n    };\n    ModelType.prototype.cloneAndEnhance = function (opts) {\n        return new ModelType({\n            name: opts.name || this.name,\n            properties: Object.assign({}, this.properties, opts.properties),\n            initializers: this.initializers.concat(opts.initializers || []),\n            preProcessor: opts.preProcessor || this.preProcessor,\n            postProcessor: opts.postProcessor || this.postProcessor\n        });\n    };\n    ModelType.prototype.actions = function (fn) {\n        var _this = this;\n        var actionInitializer = function (self) {\n            _this.instantiateActions(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [actionInitializer] });\n    };\n    ModelType.prototype.instantiateActions = function (self, actions) {\n        // check if return is correct\n        if (!isPlainObject(actions))\n            throw fail$1(\"actions initializer should return a plain object containing actions\");\n        // bind actions to the object created\n        Object.keys(actions).forEach(function (name) {\n            // warn if preprocessor was given\n            if (name === PRE_PROCESS_SNAPSHOT)\n                throw fail$1(\"Cannot define action '\" + PRE_PROCESS_SNAPSHOT + \"', it should be defined using 'type.preProcessSnapshot(fn)' instead\");\n            // warn if postprocessor was given\n            if (name === POST_PROCESS_SNAPSHOT)\n                throw fail$1(\"Cannot define action '\" + POST_PROCESS_SNAPSHOT + \"', it should be defined using 'type.postProcessSnapshot(fn)' instead\");\n            var action2 = actions[name];\n            // apply hook composition\n            var baseAction = self[name];\n            if (name in Hook && baseAction) {\n                var specializedAction_1 = action2;\n                action2 = function () {\n                    baseAction.apply(null, arguments);\n                    specializedAction_1.apply(null, arguments);\n                };\n            }\n            // the goal of this is to make sure actions using \"this\" can call themselves,\n            // while still allowing the middlewares to register them\n            var middlewares = action2.$mst_middleware; // make sure middlewares are not lost\n            var boundAction = action2.bind(actions);\n            boundAction.$mst_middleware = middlewares;\n            var actionInvoker = createActionInvoker(self, name, boundAction);\n            actions[name] = actionInvoker;\n            (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, name, actionInvoker);\n        });\n    };\n    ModelType.prototype.volatile = function (fn) {\n        var _this = this;\n        var stateInitializer = function (self) {\n            _this.instantiateVolatileState(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [stateInitializer] });\n    };\n    ModelType.prototype.instantiateVolatileState = function (self, state) {\n        // check views return\n        if (!isPlainObject(state))\n            throw fail$1(\"volatile state initializer should return a plain object containing state\");\n        set(self, state);\n    };\n    ModelType.prototype.extend = function (fn) {\n        var _this = this;\n        var initializer = function (self) {\n            var _a = fn(self), actions = _a.actions, views = _a.views, state = _a.state, rest = __rest(_a, [\"actions\", \"views\", \"state\"]);\n            for (var key in rest)\n                throw fail$1(\"The `extend` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '\" + key + \"'\");\n            if (state)\n                _this.instantiateVolatileState(self, state);\n            if (views)\n                _this.instantiateViews(self, views);\n            if (actions)\n                _this.instantiateActions(self, actions);\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [initializer] });\n    };\n    ModelType.prototype.views = function (fn) {\n        var _this = this;\n        var viewInitializer = function (self) {\n            _this.instantiateViews(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [viewInitializer] });\n    };\n    ModelType.prototype.instantiateViews = function (self, views) {\n        // check views return\n        if (!isPlainObject(views))\n            throw fail$1(\"views initializer should return a plain object containing views\");\n        Object.keys(views).forEach(function (key) {\n            // is this a computed property?\n            var descriptor = Object.getOwnPropertyDescriptor(views, key);\n            if (\"get\" in descriptor) {\n                if (isComputedProp(self, key)) {\n                    var computedValue = _getAdministration(self, key);\n                    // TODO: mobx currently does not allow redefining computes yet, pending #1121\n                    // FIXME: this binds to the internals of mobx!\n                    computedValue.derivation = descriptor.get;\n                    computedValue.scope = self;\n                    if (descriptor.set)\n                        computedValue.setter = action(computedValue.name + \"-setter\", descriptor.set);\n                }\n                else {\n                    computed(self, key, descriptor, true);\n                }\n            }\n            else if (typeof descriptor.value === \"function\") {\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, key, descriptor.value);\n            }\n            else {\n                throw fail$1(\"A view member should either be a function or getter based property\");\n            }\n        });\n    };\n    ModelType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        var value = isStateTreeNode(initialValue)\n            ? initialValue\n            : this.applySnapshotPreProcessor(initialValue);\n        return createObjectNode(this, parent, subpath, environment, value);\n        // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class\n        // that pre-reserves all these fields for fast object-member lookups\n    };\n    ModelType.prototype.initializeChildNodes = function (objNode, initialSnapshot) {\n        if (initialSnapshot === void 0) { initialSnapshot = {}; }\n        var type = objNode.type;\n        var result = {};\n        type.forAllProps(function (name, childType) {\n            result[name] = childType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n        });\n        return result;\n    };\n    ModelType.prototype.createNewInstance = function (childNodes) {\n        return observable.object(childNodes, EMPTY_OBJECT, mobxShallow);\n    };\n    ModelType.prototype.finalizeNewInstance = function (node, instance) {\n        addHiddenFinalProp(instance, \"toString\", objectTypeToString);\n        this.forAllProps(function (name) {\n            _interceptReads(instance, name, node.unbox);\n        });\n        this.initializers.reduce(function (self, fn) { return fn(self); }, instance);\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    };\n    ModelType.prototype.willChange = function (chg) {\n        // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n        var change = chg;\n        var node = getStateTreeNode(change.object);\n        var subpath = change.name;\n        node.assertWritable({ subpath: subpath });\n        var childType = node.type.properties[subpath];\n        // only properties are typed, state are stored as-is references\n        if (childType) {\n            typecheckInternal(childType, change.newValue);\n            change.newValue = childType.reconcile(node.getChildNode(subpath), change.newValue, node, subpath);\n        }\n        return change;\n    };\n    ModelType.prototype.didChange = function (chg) {\n        // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n        var change = chg;\n        var childNode = getStateTreeNode(change.object);\n        var childType = childNode.type.properties[change.name];\n        if (!childType) {\n            // don't emit patches for volatile state\n            return;\n        }\n        var oldChildValue = change.oldValue ? change.oldValue.snapshot : undefined;\n        childNode.emitPatch({\n            op: \"replace\",\n            path: escapeJsonPath(change.name),\n            value: change.newValue.snapshot,\n            oldValue: oldChildValue\n        }, childNode);\n    };\n    ModelType.prototype.getChildren = function (node) {\n        var _this = this;\n        var res = [];\n        this.forAllProps(function (name) {\n            res.push(_this.getChildNode(node, name));\n        });\n        return res;\n    };\n    ModelType.prototype.getChildNode = function (node, key) {\n        if (!(key in this.properties))\n            throw fail$1(\"Not a value property: \" + key);\n        var childNode = _getAdministration(node.storedValue, key).value; // TODO: blegh!\n        if (!childNode)\n            throw fail$1(\"Node not available for property \" + key);\n        return childNode;\n    };\n    ModelType.prototype.getSnapshot = function (node, applyPostProcess) {\n        var _this = this;\n        if (applyPostProcess === void 0) { applyPostProcess = true; }\n        var res = {};\n        this.forAllProps(function (name, type) {\n            getAtom(node.storedValue, name).reportObserved();\n            res[name] = _this.getChildNode(node, name).snapshot;\n        });\n        if (applyPostProcess) {\n            return this.applySnapshotPostProcessor(res);\n        }\n        return res;\n    };\n    ModelType.prototype.processInitialSnapshot = function (childNodes) {\n        var processed = {};\n        Object.keys(childNodes).forEach(function (key) {\n            processed[key] = childNodes[key].getSnapshot();\n        });\n        return this.applySnapshotPostProcessor(processed);\n    };\n    ModelType.prototype.applyPatchLocally = function (node, subpath, patch) {\n        if (!(patch.op === \"replace\" || patch.op === \"add\")) {\n            throw fail$1(\"object does not support operation \" + patch.op);\n        }\n        node.storedValue[subpath] = patch.value;\n    };\n    ModelType.prototype.applySnapshot = function (node, snapshot) {\n        var preProcessedSnapshot = this.applySnapshotPreProcessor(snapshot);\n        typecheckInternal(this, preProcessedSnapshot);\n        this.forAllProps(function (name) {\n            node.storedValue[name] = preProcessedSnapshot[name];\n        });\n    };\n    ModelType.prototype.applySnapshotPreProcessor = function (snapshot) {\n        var processor = this.preProcessor;\n        return processor ? processor.call(null, snapshot) : snapshot;\n    };\n    ModelType.prototype.applySnapshotPostProcessor = function (snapshot) {\n        var postProcessor = this.postProcessor;\n        if (postProcessor)\n            return postProcessor.call(null, snapshot);\n        return snapshot;\n    };\n    ModelType.prototype.getChildType = function (propertyName) {\n        assertIsString(propertyName, 1);\n        return this.properties[propertyName];\n    };\n    ModelType.prototype.isValidSnapshot = function (value, context) {\n        var _this = this;\n        var snapshot = this.applySnapshotPreProcessor(value);\n        if (!isPlainObject(snapshot)) {\n            return typeCheckFailure(context, snapshot, \"Value is not a plain object\");\n        }\n        return flattenTypeErrors(this.propertyNames.map(function (key) {\n            return _this.properties[key].validate(snapshot[key], getContextForPath(context, key, _this.properties[key]));\n        }));\n    };\n    ModelType.prototype.forAllProps = function (fn) {\n        var _this = this;\n        this.propertyNames.forEach(function (key) { return fn(key, _this.properties[key]); });\n    };\n    ModelType.prototype.describe = function () {\n        var _this = this;\n        // optimization: cache\n        return (\"{ \" +\n            this.propertyNames.map(function (key) { return key + \": \" + _this.properties[key].describe(); }).join(\"; \") +\n            \" }\");\n    };\n    ModelType.prototype.getDefaultSnapshot = function () {\n        return EMPTY_OBJECT;\n    };\n    ModelType.prototype.removeChild = function (node, subpath) {\n        node.storedValue[subpath] = undefined;\n    };\n    __decorate([\n        action\n    ], ModelType.prototype, \"applySnapshot\", null);\n    return ModelType;\n}(ComplexType));\n/**\n * `types.model` - Creates a new model type by providing a name, properties, volatile state and actions.\n *\n * See the [model type](/concepts/trees#creating-models) description or the [getting started](intro/getting-started.md#getting-started-1) tutorial.\n */\nfunction model() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var name = typeof args[0] === \"string\" ? args.shift() : \"AnonymousModel\";\n    var properties = args.shift() || {};\n    return new ModelType({ name: name, properties: properties });\n}\n/**\n * `types.compose` - Composes a new model from one or more existing model types.\n * This method can be invoked in two forms:\n * Given 2 or more model types, the types are composed into a new Type.\n * Given first parameter as a string and 2 or more model types,\n * the types are composed into a new Type with the given name\n */\nfunction compose() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    // TODO: just join the base type names if no name is provided\n    var hasTypename = typeof args[0] === \"string\";\n    var typeName = hasTypename ? args[0] : \"AnonymousModel\";\n    if (hasTypename) {\n        args.shift();\n    }\n    // check all parameters\n    if (devMode()) {\n        args.forEach(function (type, i) {\n            assertArg(type, isModelType, \"mobx-state-tree model type\", hasTypename ? i + 2 : i + 1);\n        });\n    }\n    return args\n        .reduce(function (prev, cur) {\n        return prev.cloneAndEnhance({\n            name: prev.name + \"_\" + cur.name,\n            properties: cur.properties,\n            initializers: cur.initializers,\n            preProcessor: function (snapshot) {\n                return cur.applySnapshotPreProcessor(prev.applySnapshotPreProcessor(snapshot));\n            },\n            postProcessor: function (snapshot) {\n                return cur.applySnapshotPostProcessor(prev.applySnapshotPostProcessor(snapshot));\n            }\n        });\n    })\n        .named(typeName);\n}\n/**\n * Returns if a given value represents a model type.\n *\n * @param type\n * @returns\n */\nfunction isModelType(type) {\n    return isType(type) && (type.flags & TypeFlags.Object) > 0;\n}\n\n// TODO: implement CoreType using types.custom ?\n/**\n * @internal\n * @hidden\n */\nvar CoreType = /** @class */ (function (_super) {\n    __extends(CoreType, _super);\n    function CoreType(name, flags, checker, initializer) {\n        if (initializer === void 0) { initializer = identity; }\n        var _this = _super.call(this, name) || this;\n        _this.flags = flags;\n        _this.checker = checker;\n        _this.initializer = initializer;\n        _this.flags = flags;\n        return _this;\n    }\n    CoreType.prototype.describe = function () {\n        return this.name;\n    };\n    CoreType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    };\n    CoreType.prototype.createNewInstance = function (snapshot) {\n        return this.initializer(snapshot);\n    };\n    CoreType.prototype.isValidSnapshot = function (value, context) {\n        if (isPrimitive(value) && this.checker(value)) {\n            return typeCheckSuccess();\n        }\n        var typeName = this.name === \"Date\" ? \"Date or a unix milliseconds timestamp\" : this.name;\n        return typeCheckFailure(context, value, \"Value is not a \" + typeName);\n    };\n    return CoreType;\n}(SimpleType));\n/**\n * `types.string` - Creates a type that can only contain a string value.\n * This type is used for string values by default\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *   firstName: types.string,\n *   lastName: \"Doe\"\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nvar string = new CoreType(\"string\", TypeFlags.String, function (v) { return typeof v === \"string\"; });\n/**\n * `types.number` - Creates a type that can only contain a numeric value.\n * This type is used for numeric values by default\n *\n * Example:\n * ```ts\n * const Vector = types.model({\n *   x: types.number,\n *   y: 1.5\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nvar number = new CoreType(\"number\", TypeFlags.Number, function (v) { return typeof v === \"number\"; });\n/**\n * `types.integer` - Creates a type that can only contain an integer value.\n * This type is used for integer values by default\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.integer,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nvar integer = new CoreType(\"integer\", TypeFlags.Integer, function (v) { return isInteger(v); });\n/**\n * `types.boolean` - Creates a type that can only contain a boolean value.\n * This type is used for boolean values by default\n *\n * Example:\n * ```ts\n * const Thing = types.model({\n *   isCool: types.boolean,\n *   isAwesome: false\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nvar boolean = new CoreType(\"boolean\", TypeFlags.Boolean, function (v) { return typeof v === \"boolean\"; });\n/**\n * `types.null` - The type of the value `null`\n */\nvar nullType = new CoreType(\"null\", TypeFlags.Null, function (v) { return v === null; });\n/**\n * `types.undefined` - The type of the value `undefined`\n */\nvar undefinedType = new CoreType(\"undefined\", TypeFlags.Undefined, function (v) { return v === undefined; });\nvar _DatePrimitive = new CoreType(\"Date\", TypeFlags.Date, function (v) { return typeof v === \"number\" || v instanceof Date; }, function (v) { return (v instanceof Date ? v : new Date(v)); });\n_DatePrimitive.getSnapshot = function (node) {\n    return node.storedValue.getTime();\n};\n/**\n * `types.Date` - Creates a type that can only contain a javascript Date value.\n *\n * Example:\n * ```ts\n * const LogLine = types.model({\n *   timestamp: types.Date,\n * })\n *\n * LogLine.create({ timestamp: new Date() })\n * ```\n */\nvar DatePrimitive = _DatePrimitive;\n/**\n * @internal\n * @hidden\n */\nfunction getPrimitiveFactoryFromValue(value) {\n    switch (typeof value) {\n        case \"string\":\n            return string;\n        case \"number\":\n            return number; // In the future, isInteger(value) ? integer : number would be interesting, but would be too breaking for now\n        case \"boolean\":\n            return boolean;\n        case \"object\":\n            if (value instanceof Date)\n                return DatePrimitive;\n    }\n    throw fail$1(\"Cannot determine primitive type from value \" + value);\n}\n/**\n * Returns if a given value represents a primitive type.\n *\n * @param type\n * @returns\n */\nfunction isPrimitiveType(type) {\n    return (isType(type) &&\n        (type.flags &\n            (TypeFlags.String |\n                TypeFlags.Number |\n                TypeFlags.Integer |\n                TypeFlags.Boolean |\n                TypeFlags.Date)) >\n            0);\n}\n\n/**\n * @internal\n * @hidden\n */\nvar Literal = /** @class */ (function (_super) {\n    __extends(Literal, _super);\n    function Literal(value) {\n        var _this = _super.call(this, JSON.stringify(value)) || this;\n        _this.flags = TypeFlags.Literal;\n        _this.value = value;\n        return _this;\n    }\n    Literal.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    };\n    Literal.prototype.describe = function () {\n        return JSON.stringify(this.value);\n    };\n    Literal.prototype.isValidSnapshot = function (value, context) {\n        if (isPrimitive(value) && value === this.value) {\n            return typeCheckSuccess();\n        }\n        return typeCheckFailure(context, value, \"Value is not a literal \" + JSON.stringify(this.value));\n    };\n    return Literal;\n}(SimpleType));\n/**\n * `types.literal` - The literal type will return a type that will match only the exact given type.\n * The given value must be a primitive, in order to be serialized to a snapshot correctly.\n * You can use literal to match exact strings for example the exact male or female string.\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *     name: types.string,\n *     gender: types.union(types.literal('male'), types.literal('female'))\n * })\n * ```\n *\n * @param value The value to use in the strict equal check\n * @returns\n */\nfunction literal(value) {\n    // check that the given value is a primitive\n    assertArg(value, isPrimitive, \"primitive\", 1);\n    return new Literal(value);\n}\n/**\n * Returns if a given value represents a literal type.\n *\n * @param type\n * @returns\n */\nfunction isLiteralType(type) {\n    return isType(type) && (type.flags & TypeFlags.Literal) > 0;\n}\n\nvar Refinement = /** @class */ (function (_super) {\n    __extends(Refinement, _super);\n    function Refinement(name, _subtype, _predicate, _message) {\n        var _this = _super.call(this, name) || this;\n        _this._subtype = _subtype;\n        _this._predicate = _predicate;\n        _this._message = _message;\n        return _this;\n    }\n    Object.defineProperty(Refinement.prototype, \"flags\", {\n        get: function () {\n            return this._subtype.flags | TypeFlags.Refinement;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Refinement.prototype.describe = function () {\n        return this.name;\n    };\n    Refinement.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        // create the child type\n        return this._subtype.instantiate(parent, subpath, environment, initialValue);\n    };\n    Refinement.prototype.isAssignableFrom = function (type) {\n        return this._subtype.isAssignableFrom(type);\n    };\n    Refinement.prototype.isValidSnapshot = function (value, context) {\n        var subtypeErrors = this._subtype.validate(value, context);\n        if (subtypeErrors.length > 0)\n            return subtypeErrors;\n        var snapshot = isStateTreeNode(value) ? getStateTreeNode(value).snapshot : value;\n        if (!this._predicate(snapshot)) {\n            return typeCheckFailure(context, value, this._message(value));\n        }\n        return typeCheckSuccess();\n    };\n    Refinement.prototype.reconcile = function (current, newValue, parent, subpath) {\n        return this._subtype.reconcile(current, newValue, parent, subpath);\n    };\n    Refinement.prototype.getSubTypes = function () {\n        return this._subtype;\n    };\n    return Refinement;\n}(BaseType));\n/**\n * `types.refinement` - Creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.\n *\n * @param name\n * @param type\n * @param predicate\n * @returns\n */\nfunction refinement() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var name = typeof args[0] === \"string\" ? args.shift() : isType(args[0]) ? args[0].name : null;\n    var type = args[0];\n    var predicate = args[1];\n    var message = args[2]\n        ? args[2]\n        : function (v) { return \"Value does not respect the refinement predicate\"; };\n    // ensures all parameters are correct\n    assertIsType(type, [1, 2]);\n    assertIsString(name, 1);\n    assertIsFunction(predicate, [2, 3]);\n    assertIsFunction(message, [3, 4]);\n    return new Refinement(name, type, predicate, message);\n}\n/**\n * Returns if a given value is a refinement type.\n *\n * @param type\n * @returns\n */\nfunction isRefinementType(type) {\n    return (type.flags & TypeFlags.Refinement) > 0;\n}\n\n/**\n * `types.enumeration` - Can be used to create an string based enumeration.\n * (note: this methods is just sugar for a union of string literals)\n *\n * Example:\n * ```ts\n * const TrafficLight = types.model({\n *   color: types.enumeration(\"Color\", [\"Red\", \"Orange\", \"Green\"])\n * })\n * ```\n *\n * @param name descriptive name of the enumeration (optional)\n * @param options possible values this enumeration can have\n * @returns\n */\nfunction enumeration(name, options) {\n    var realOptions = typeof name === \"string\" ? options : name;\n    // check all options\n    if (devMode()) {\n        realOptions.forEach(function (option, i) {\n            assertIsString(option, i + 1);\n        });\n    }\n    var type = union.apply(void 0, __spread(realOptions.map(function (option) { return literal(\"\" + option); })));\n    if (typeof name === \"string\")\n        type.name = name;\n    return type;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar Union = /** @class */ (function (_super) {\n    __extends(Union, _super);\n    function Union(name, _types, options) {\n        var _this = _super.call(this, name) || this;\n        _this._types = _types;\n        _this._eager = true;\n        options = __assign({ eager: true, dispatcher: undefined }, options);\n        _this._dispatcher = options.dispatcher;\n        if (!options.eager)\n            _this._eager = false;\n        return _this;\n    }\n    Object.defineProperty(Union.prototype, \"flags\", {\n        get: function () {\n            var result = TypeFlags.Union;\n            this._types.forEach(function (type) {\n                result |= type.flags;\n            });\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Union.prototype.isAssignableFrom = function (type) {\n        return this._types.some(function (subType) { return subType.isAssignableFrom(type); });\n    };\n    Union.prototype.describe = function () {\n        return \"(\" + this._types.map(function (factory) { return factory.describe(); }).join(\" | \") + \")\";\n    };\n    Union.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        var type = this.determineType(initialValue, undefined);\n        if (!type)\n            throw fail$1(\"No matching type for union \" + this.describe()); // can happen in prod builds\n        return type.instantiate(parent, subpath, environment, initialValue);\n    };\n    Union.prototype.reconcile = function (current, newValue, parent, subpath) {\n        var type = this.determineType(newValue, current.type);\n        if (!type)\n            throw fail$1(\"No matching type for union \" + this.describe()); // can happen in prod builds\n        return type.reconcile(current, newValue, parent, subpath);\n    };\n    Union.prototype.determineType = function (value, reconcileCurrentType) {\n        // try the dispatcher, if defined\n        if (this._dispatcher) {\n            return this._dispatcher(value);\n        }\n        // find the most accomodating type\n        // if we are using reconciliation try the current node type first (fix for #1045)\n        if (reconcileCurrentType) {\n            if (reconcileCurrentType.is(value)) {\n                return reconcileCurrentType;\n            }\n            return this._types.filter(function (t) { return t !== reconcileCurrentType; }).find(function (type) { return type.is(value); });\n        }\n        else {\n            return this._types.find(function (type) { return type.is(value); });\n        }\n    };\n    Union.prototype.isValidSnapshot = function (value, context) {\n        if (this._dispatcher) {\n            return this._dispatcher(value).validate(value, context);\n        }\n        var allErrors = [];\n        var applicableTypes = 0;\n        for (var i = 0; i < this._types.length; i++) {\n            var type = this._types[i];\n            var errors = type.validate(value, context);\n            if (errors.length === 0) {\n                if (this._eager)\n                    return typeCheckSuccess();\n                else\n                    applicableTypes++;\n            }\n            else {\n                allErrors.push(errors);\n            }\n        }\n        if (applicableTypes === 1)\n            return typeCheckSuccess();\n        return typeCheckFailure(context, value, \"No type is applicable for the union\").concat(flattenTypeErrors(allErrors));\n    };\n    Union.prototype.getSubTypes = function () {\n        return this._types;\n    };\n    return Union;\n}(BaseType));\n/**\n * `types.union` - Create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function of the form `(snapshot) => Type`.\n *\n * @param optionsOrType\n * @param otherTypes\n * @returns\n */\nfunction union(optionsOrType) {\n    var otherTypes = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        otherTypes[_i - 1] = arguments[_i];\n    }\n    var options = isType(optionsOrType) ? undefined : optionsOrType;\n    var types = isType(optionsOrType) ? __spread([optionsOrType], otherTypes) : otherTypes;\n    var name = \"(\" + types.map(function (type) { return type.name; }).join(\" | \") + \")\";\n    // check all options\n    if (devMode()) {\n        if (options) {\n            assertArg(options, function (o) { return isPlainObject(o); }, \"object { eager?: boolean, dispatcher?: Function }\", 1);\n        }\n        types.forEach(function (type, i) {\n            assertIsType(type, options ? i + 2 : i + 1);\n        });\n    }\n    return new Union(name, types, options);\n}\n/**\n * Returns if a given value represents a union type.\n *\n * @param type\n * @returns\n */\nfunction isUnionType(type) {\n    return (type.flags & TypeFlags.Union) > 0;\n}\n\n/**\n * @hidden\n * @internal\n */\nvar OptionalValue = /** @class */ (function (_super) {\n    __extends(OptionalValue, _super);\n    function OptionalValue(_subtype, _defaultValue, optionalValues) {\n        var _this = _super.call(this, _subtype.name) || this;\n        _this._subtype = _subtype;\n        _this._defaultValue = _defaultValue;\n        _this.optionalValues = optionalValues;\n        return _this;\n    }\n    Object.defineProperty(OptionalValue.prototype, \"flags\", {\n        get: function () {\n            return this._subtype.flags | TypeFlags.Optional;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    OptionalValue.prototype.describe = function () {\n        return this._subtype.describe() + \"?\";\n    };\n    OptionalValue.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        if (this.optionalValues.indexOf(initialValue) >= 0) {\n            var defaultInstanceOrSnapshot = this.getDefaultInstanceOrSnapshot();\n            return this._subtype.instantiate(parent, subpath, environment, defaultInstanceOrSnapshot);\n        }\n        return this._subtype.instantiate(parent, subpath, environment, initialValue);\n    };\n    OptionalValue.prototype.reconcile = function (current, newValue, parent, subpath) {\n        return this._subtype.reconcile(current, this.optionalValues.indexOf(newValue) < 0 && this._subtype.is(newValue)\n            ? newValue\n            : this.getDefaultInstanceOrSnapshot(), parent, subpath);\n    };\n    OptionalValue.prototype.getDefaultInstanceOrSnapshot = function () {\n        var defaultInstanceOrSnapshot = typeof this._defaultValue === \"function\"\n            ? this._defaultValue()\n            : this._defaultValue;\n        // while static values are already snapshots and checked on types.optional\n        // generator functions must always be rechecked just in case\n        if (typeof this._defaultValue === \"function\") {\n            typecheckInternal(this, defaultInstanceOrSnapshot);\n        }\n        return defaultInstanceOrSnapshot;\n    };\n    OptionalValue.prototype.isValidSnapshot = function (value, context) {\n        // defaulted values can be skipped\n        if (this.optionalValues.indexOf(value) >= 0) {\n            return typeCheckSuccess();\n        }\n        // bounce validation to the sub-type\n        return this._subtype.validate(value, context);\n    };\n    OptionalValue.prototype.isAssignableFrom = function (type) {\n        return this._subtype.isAssignableFrom(type);\n    };\n    OptionalValue.prototype.getSubTypes = function () {\n        return this._subtype;\n    };\n    return OptionalValue;\n}(BaseType));\nfunction checkOptionalPreconditions(type, defaultValueOrFunction) {\n    // make sure we never pass direct instances\n    if (typeof defaultValueOrFunction !== \"function\" && isStateTreeNode(defaultValueOrFunction)) {\n        throw fail$1(\"default value cannot be an instance, pass a snapshot or a function that creates an instance/snapshot instead\");\n    }\n    assertIsType(type, 1);\n    if (devMode()) {\n        // we only check default values if they are passed directly\n        // if they are generator functions they will be checked once they are generated\n        // we don't check generator function results here to avoid generating a node just for type-checking purposes\n        // which might generate side-effects\n        if (typeof defaultValueOrFunction !== \"function\") {\n            typecheckInternal(type, defaultValueOrFunction);\n        }\n    }\n}\n/**\n * `types.optional` - Can be used to create a property with a default value.\n *\n * Depending on the third argument (`optionalValues`) there are two ways of operation:\n * - If the argument is not provided, then if a value is not provided in the snapshot (`undefined` or missing),\n *   it will default to the provided `defaultValue`\n * - If the argument is provided, then if the value in the snapshot matches one of the optional values inside the array then it will\n *   default to the provided `defaultValue`. Additionally, if one of the optional values inside the array is `undefined` then a missing\n *   property is also valid.\n *\n *   Note that it is also possible to include values of the same type as the intended subtype as optional values,\n *   in this case the optional value will be transformed into the `defaultValue` (e.g. `types.optional(types.string, \"unnamed\", [undefined, \"\"])`\n *   will transform the snapshot values `undefined` (and therefore missing) and empty strings into the string `\"unnamed\"` when it gets\n *   instantiated).\n *\n * If `defaultValue` is a function, the function will be invoked for every new instance.\n * Applying a snapshot in which the optional value is one of the optional values (or `undefined`/_not_ present if none are provided) causes the\n * value to be reset.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string,\n *   subtitle1: types.optional(types.string, \"\", [null]),\n *   subtitle2: types.optional(types.string, \"\", [null, undefined]),\n *   done: types.optional(types.boolean, false),\n *   created: types.optional(types.Date, () => new Date()),\n * })\n *\n * // if done is missing / undefined it will become false\n * // if created is missing / undefined it will get a freshly generated timestamp\n * // if subtitle1 is null it will default to \"\", but it cannot be missing or undefined\n * // if subtitle2 is null or undefined it will default to \"\"; since it can be undefined it can also be missing\n * const todo = Todo.create({ title: \"Get coffee\", subtitle1: null })\n * ```\n *\n * @param type\n * @param defaultValueOrFunction\n * @param optionalValues an optional array with zero or more primitive values (string, number, boolean, null or undefined)\n *                       that will be converted into the default. `[ undefined ]` is assumed when none is provided\n * @returns\n */\nfunction optional(type, defaultValueOrFunction, optionalValues) {\n    checkOptionalPreconditions(type, defaultValueOrFunction);\n    return new OptionalValue(type, defaultValueOrFunction, optionalValues ? optionalValues : undefinedAsOptionalValues);\n}\nvar undefinedAsOptionalValues = [undefined];\n/**\n * Returns if a value represents an optional type.\n *\n * @template IT\n * @param type\n * @returns\n */\nfunction isOptionalType(type) {\n    return isType(type) && (type.flags & TypeFlags.Optional) > 0;\n}\n\nvar optionalUndefinedType = optional(undefinedType, undefined);\nvar optionalNullType = optional(nullType, null);\n/**\n * `types.maybe` - Maybe will make a type nullable, and also optional.\n * The value `undefined` will be used to represent nullability.\n *\n * @param type\n * @returns\n */\nfunction maybe(type) {\n    assertIsType(type, 1);\n    return union(type, optionalUndefinedType);\n}\n/**\n * `types.maybeNull` - Maybe will make a type nullable, and also optional.\n * The value `null` will be used to represent no value.\n *\n * @param type\n * @returns\n */\nfunction maybeNull(type) {\n    assertIsType(type, 1);\n    return union(type, optionalNullType);\n}\n\nvar Late = /** @class */ (function (_super) {\n    __extends(Late, _super);\n    function Late(name, _definition) {\n        var _this = _super.call(this, name) || this;\n        _this._definition = _definition;\n        return _this;\n    }\n    Object.defineProperty(Late.prototype, \"flags\", {\n        get: function () {\n            return (this._subType ? this._subType.flags : 0) | TypeFlags.Late;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Late.prototype.getSubType = function (mustSucceed) {\n        if (!this._subType) {\n            var t = undefined;\n            try {\n                t = this._definition();\n            }\n            catch (e) {\n                if (e instanceof ReferenceError)\n                    // can happen in strict ES5 code when a definition is self refering\n                    t = undefined;\n                else\n                    throw e;\n            }\n            if (mustSucceed && t === undefined)\n                throw fail$1(\"Late type seems to be used too early, the definition (still) returns undefined\");\n            if (t) {\n                if (devMode() && !isType(t))\n                    throw fail$1(\"Failed to determine subtype, make sure types.late returns a type definition.\");\n                this._subType = t;\n            }\n        }\n        return this._subType;\n    };\n    Late.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        return this.getSubType(true).instantiate(parent, subpath, environment, initialValue);\n    };\n    Late.prototype.reconcile = function (current, newValue, parent, subpath) {\n        return this.getSubType(true).reconcile(current, newValue, parent, subpath);\n    };\n    Late.prototype.describe = function () {\n        var t = this.getSubType(false);\n        return t ? t.name : \"<uknown late type>\";\n    };\n    Late.prototype.isValidSnapshot = function (value, context) {\n        var t = this.getSubType(false);\n        if (!t) {\n            // See #916; the variable the definition closure is pointing to wasn't defined yet, so can't be evaluted yet here\n            return typeCheckSuccess();\n        }\n        return t.validate(value, context);\n    };\n    Late.prototype.isAssignableFrom = function (type) {\n        var t = this.getSubType(false);\n        return t ? t.isAssignableFrom(type) : false;\n    };\n    Late.prototype.getSubTypes = function () {\n        var subtype = this.getSubType(false);\n        return subtype ? subtype : cannotDetermineSubtype;\n    };\n    return Late;\n}(BaseType));\n/**\n * `types.late` - Defines a type that gets implemented later. This is useful when you have to deal with circular dependencies.\n * Please notice that when defining circular dependencies TypeScript isn't smart enough to inference them.\n *\n * Example:\n * ```ts\n *   // TypeScript isn't smart enough to infer self referencing types.\n *  const Node = types.model({\n *       children: types.array(types.late((): IAnyModelType => Node)) // then typecast each array element to Instance<typeof Node>\n *  })\n * ```\n *\n * @param name The name to use for the type that will be returned.\n * @param type A function that returns the type that will be defined.\n * @returns\n */\nfunction late(nameOrType, maybeType) {\n    var name = typeof nameOrType === \"string\" ? nameOrType : \"late(\" + nameOrType.toString() + \")\";\n    var type = typeof nameOrType === \"string\" ? maybeType : nameOrType;\n    // checks that the type is actually a late type\n    if (devMode()) {\n        if (!(typeof type === \"function\" && type.length === 0))\n            throw fail$1(\"Invalid late type, expected a function with zero arguments that returns a type, got: \" +\n                type);\n    }\n    return new Late(name, type);\n}\n/**\n * Returns if a given value represents a late type.\n *\n * @param type\n * @returns\n */\nfunction isLateType(type) {\n    return isType(type) && (type.flags & TypeFlags.Late) > 0;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar Frozen = /** @class */ (function (_super) {\n    __extends(Frozen, _super);\n    function Frozen(subType) {\n        var _this = _super.call(this, subType ? \"frozen(\" + subType.name + \")\" : \"frozen\") || this;\n        _this.subType = subType;\n        _this.flags = TypeFlags.Frozen;\n        return _this;\n    }\n    Frozen.prototype.describe = function () {\n        return \"<any immutable value>\";\n    };\n    Frozen.prototype.instantiate = function (parent, subpath, environment, value) {\n        // create the node\n        return createScalarNode(this, parent, subpath, environment, deepFreeze(value));\n    };\n    Frozen.prototype.isValidSnapshot = function (value, context) {\n        if (!isSerializable(value)) {\n            return typeCheckFailure(context, value, \"Value is not serializable and cannot be frozen\");\n        }\n        if (this.subType)\n            return this.subType.validate(value, context);\n        return typeCheckSuccess();\n    };\n    return Frozen;\n}(SimpleType));\nvar untypedFrozenInstance = new Frozen();\n/**\n * `types.frozen` - Frozen can be used to store any value that is serializable in itself (that is valid JSON).\n * Frozen values need to be immutable or treated as if immutable. They need be serializable as well.\n * Values stored in frozen will snapshotted as-is by MST, and internal changes will not be tracked.\n *\n * This is useful to store complex, but immutable values like vectors etc. It can form a powerful bridge to parts of your application that should be immutable, or that assume data to be immutable.\n *\n * Note: if you want to store free-form state that is mutable, or not serializeable, consider using volatile state instead.\n *\n * Frozen properties can be defined in three different ways\n * 1. `types.frozen(SubType)` - provide a valid MST type and frozen will check if the provided data conforms the snapshot for that type\n * 2. `types.frozen({ someDefaultValue: true})` - provide a primitive value, object or array, and MST will infer the type from that object, and also make it the default value for the field\n * 3. `types.frozen<TypeScriptType>()` - provide a typescript type, to help in strongly typing the field (design time only)\n *\n * Example:\n * ```ts\n * const GameCharacter = types.model({\n *   name: string,\n *   location: types.frozen({ x: 0, y: 0})\n * })\n *\n * const hero = GameCharacter.create({\n *   name: \"Mario\",\n *   location: { x: 7, y: 4 }\n * })\n *\n * hero.location = { x: 10, y: 2 } // OK\n * hero.location.x = 7 // Not ok!\n * ```\n *\n * ```ts\n * type Point = { x: number, y: number }\n *    const Mouse = types.model({\n *         loc: types.frozen<Point>()\n *    })\n * ```\n *\n * @param defaultValueOrType\n * @returns\n */\nfunction frozen(arg) {\n    if (arguments.length === 0)\n        return untypedFrozenInstance;\n    else if (isType(arg))\n        return new Frozen(arg);\n    else\n        return optional(untypedFrozenInstance, arg);\n}\n/**\n * Returns if a given value represents a frozen type.\n *\n * @param type\n * @returns\n */\nfunction isFrozenType(type) {\n    return isType(type) && (type.flags & TypeFlags.Frozen) > 0;\n}\n\nfunction getInvalidationCause(hook) {\n    switch (hook) {\n        case Hook.beforeDestroy:\n            return \"destroy\";\n        case Hook.beforeDetach:\n            return \"detach\";\n        default:\n            return undefined;\n    }\n}\nvar StoredReference = /** @class */ (function () {\n    function StoredReference(value, targetType) {\n        this.targetType = targetType;\n        if (isValidIdentifier(value)) {\n            this.identifier = value;\n        }\n        else if (isStateTreeNode(value)) {\n            var targetNode = getStateTreeNode(value);\n            if (!targetNode.identifierAttribute)\n                throw fail$1(\"Can only store references with a defined identifier attribute.\");\n            var id = targetNode.unnormalizedIdentifier;\n            if (id === null || id === undefined) {\n                throw fail$1(\"Can only store references to tree nodes with a defined identifier.\");\n            }\n            this.identifier = id;\n        }\n        else {\n            throw fail$1(\"Can only store references to tree nodes or identifiers, got: '\" + value + \"'\");\n        }\n    }\n    StoredReference.prototype.updateResolvedReference = function (node) {\n        var normalizedId = normalizeIdentifier(this.identifier);\n        var root = node.root;\n        var lastCacheModification = root.identifierCache.getLastCacheModificationPerId(normalizedId);\n        if (!this.resolvedReference ||\n            this.resolvedReference.lastCacheModification !== lastCacheModification) {\n            var targetType = this.targetType;\n            // reference was initialized with the identifier of the target\n            var target = root.identifierCache.resolve(targetType, normalizedId);\n            if (!target) {\n                throw new InvalidReferenceError(\"[mobx-state-tree] Failed to resolve reference '\" + this.identifier + \"' to type '\" + this.targetType.name + \"' (from node: \" + node.path + \")\");\n            }\n            this.resolvedReference = {\n                node: target,\n                lastCacheModification: lastCacheModification\n            };\n        }\n    };\n    Object.defineProperty(StoredReference.prototype, \"resolvedValue\", {\n        get: function () {\n            this.updateResolvedReference(this.node);\n            return this.resolvedReference.node.value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return StoredReference;\n}());\n/**\n * @internal\n * @hidden\n */\nvar InvalidReferenceError = /** @class */ (function (_super) {\n    __extends(InvalidReferenceError, _super);\n    function InvalidReferenceError(m) {\n        var _this = _super.call(this, m) || this;\n        Object.setPrototypeOf(_this, InvalidReferenceError.prototype);\n        return _this;\n    }\n    return InvalidReferenceError;\n}(Error));\n/**\n * @internal\n * @hidden\n */\nvar BaseReferenceType = /** @class */ (function (_super) {\n    __extends(BaseReferenceType, _super);\n    function BaseReferenceType(targetType, onInvalidated) {\n        var _this = _super.call(this, \"reference(\" + targetType.name + \")\") || this;\n        _this.targetType = targetType;\n        _this.onInvalidated = onInvalidated;\n        _this.flags = TypeFlags.Reference;\n        return _this;\n    }\n    BaseReferenceType.prototype.describe = function () {\n        return this.name;\n    };\n    BaseReferenceType.prototype.isAssignableFrom = function (type) {\n        return this.targetType.isAssignableFrom(type);\n    };\n    BaseReferenceType.prototype.isValidSnapshot = function (value, context) {\n        return isValidIdentifier(value)\n            ? typeCheckSuccess()\n            : typeCheckFailure(context, value, \"Value is not a valid identifier, which is a string or a number\");\n    };\n    BaseReferenceType.prototype.fireInvalidated = function (cause, storedRefNode, referenceId, refTargetNode) {\n        // to actually invalidate a reference we need an alive parent,\n        // since it is a scalar value (immutable-ish) and we need to change it\n        // from the parent\n        var storedRefParentNode = storedRefNode.parent;\n        if (!storedRefParentNode || !storedRefParentNode.isAlive) {\n            return;\n        }\n        var storedRefParentValue = storedRefParentNode.storedValue;\n        if (!storedRefParentValue) {\n            return;\n        }\n        this.onInvalidated({\n            cause: cause,\n            parent: storedRefParentValue,\n            invalidTarget: refTargetNode ? refTargetNode.storedValue : undefined,\n            invalidId: referenceId,\n            replaceRef: function (newRef) {\n                applyPatch(storedRefNode.root.storedValue, {\n                    op: \"replace\",\n                    value: newRef,\n                    path: storedRefNode.path\n                });\n            },\n            removeRef: function () {\n                if (isModelType(storedRefParentNode.type)) {\n                    this.replaceRef(undefined);\n                }\n                else {\n                    applyPatch(storedRefNode.root.storedValue, {\n                        op: \"remove\",\n                        path: storedRefNode.path\n                    });\n                }\n            }\n        });\n    };\n    BaseReferenceType.prototype.addTargetNodeWatcher = function (storedRefNode, referenceId) {\n        var _this = this;\n        // this will make sure the target node becomes created\n        var refTargetValue = this.getValue(storedRefNode);\n        if (!refTargetValue) {\n            return undefined;\n        }\n        var refTargetNode = getStateTreeNode(refTargetValue);\n        var hookHandler = function (_, refTargetNodeHook) {\n            var cause = getInvalidationCause(refTargetNodeHook);\n            if (!cause) {\n                return;\n            }\n            _this.fireInvalidated(cause, storedRefNode, referenceId, refTargetNode);\n        };\n        var refTargetDetachHookDisposer = refTargetNode.registerHook(Hook.beforeDetach, hookHandler);\n        var refTargetDestroyHookDisposer = refTargetNode.registerHook(Hook.beforeDestroy, hookHandler);\n        return function () {\n            refTargetDetachHookDisposer();\n            refTargetDestroyHookDisposer();\n        };\n    };\n    BaseReferenceType.prototype.watchTargetNodeForInvalidations = function (storedRefNode, identifier, customGetSet) {\n        var _this = this;\n        if (!this.onInvalidated) {\n            return;\n        }\n        var onRefTargetDestroyedHookDisposer;\n        // get rid of the watcher hook when the stored ref node is destroyed\n        // detached is ignored since scalar nodes (where the reference resides) cannot be detached\n        storedRefNode.registerHook(Hook.beforeDestroy, function () {\n            if (onRefTargetDestroyedHookDisposer) {\n                onRefTargetDestroyedHookDisposer();\n            }\n        });\n        var startWatching = function (sync) {\n            // re-create hook in case the stored ref gets reattached\n            if (onRefTargetDestroyedHookDisposer) {\n                onRefTargetDestroyedHookDisposer();\n            }\n            // make sure the target node is actually there and initialized\n            var storedRefParentNode = storedRefNode.parent;\n            var storedRefParentValue = storedRefParentNode && storedRefParentNode.storedValue;\n            if (storedRefParentNode && storedRefParentNode.isAlive && storedRefParentValue) {\n                var refTargetNodeExists = void 0;\n                if (customGetSet) {\n                    refTargetNodeExists = !!customGetSet.get(identifier, storedRefParentValue);\n                }\n                else {\n                    refTargetNodeExists = storedRefNode.root.identifierCache.has(_this.targetType, normalizeIdentifier(identifier));\n                }\n                if (!refTargetNodeExists) {\n                    // we cannot change the reference in sync mode\n                    // since we are in the middle of a reconciliation/instantiation and the change would be overwritten\n                    // for those cases just let the wrong reference be assigned and fail upon usage\n                    // (like current references do)\n                    // this means that effectively this code will only run when it is created from a snapshot\n                    if (!sync) {\n                        _this.fireInvalidated(\"invalidSnapshotReference\", storedRefNode, identifier, null);\n                    }\n                }\n                else {\n                    onRefTargetDestroyedHookDisposer = _this.addTargetNodeWatcher(storedRefNode, identifier);\n                }\n            }\n        };\n        if (storedRefNode.state === NodeLifeCycle.FINALIZED) {\n            // already attached, so the whole tree is ready\n            startWatching(true);\n        }\n        else {\n            if (!storedRefNode.isRoot) {\n                // start watching once the whole tree is ready\n                storedRefNode.root.registerHook(Hook.afterCreationFinalization, function () {\n                    // make sure to attach it so it can start listening\n                    if (storedRefNode.parent) {\n                        storedRefNode.parent.createObservableInstanceIfNeeded();\n                    }\n                });\n            }\n            // start watching once the node is attached somewhere / parent changes\n            storedRefNode.registerHook(Hook.afterAttach, function () {\n                startWatching(false);\n            });\n        }\n    };\n    return BaseReferenceType;\n}(SimpleType));\n/**\n * @internal\n * @hidden\n */\nvar IdentifierReferenceType = /** @class */ (function (_super) {\n    __extends(IdentifierReferenceType, _super);\n    function IdentifierReferenceType(targetType, onInvalidated) {\n        return _super.call(this, targetType, onInvalidated) || this;\n    }\n    IdentifierReferenceType.prototype.getValue = function (storedRefNode) {\n        if (!storedRefNode.isAlive)\n            return undefined;\n        var storedRef = storedRefNode.storedValue;\n        return storedRef.resolvedValue;\n    };\n    IdentifierReferenceType.prototype.getSnapshot = function (storedRefNode) {\n        var ref = storedRefNode.storedValue;\n        return ref.identifier;\n    };\n    IdentifierReferenceType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        var identifier = isStateTreeNode(initialValue)\n            ? getIdentifier(initialValue)\n            : initialValue;\n        var storedRef = new StoredReference(initialValue, this.targetType);\n        var storedRefNode = createScalarNode(this, parent, subpath, environment, storedRef);\n        storedRef.node = storedRefNode;\n        this.watchTargetNodeForInvalidations(storedRefNode, identifier, undefined);\n        return storedRefNode;\n    };\n    IdentifierReferenceType.prototype.reconcile = function (current, newValue, parent, subpath) {\n        if (!current.isDetaching && current.type === this) {\n            var compareByValue = isStateTreeNode(newValue);\n            var ref = current.storedValue;\n            if ((!compareByValue && ref.identifier === newValue) ||\n                (compareByValue && ref.resolvedValue === newValue)) {\n                current.setParent(parent, subpath);\n                return current;\n            }\n        }\n        var newNode = this.instantiate(parent, subpath, undefined, newValue);\n        current.die(); // noop if detaching\n        return newNode;\n    };\n    return IdentifierReferenceType;\n}(BaseReferenceType));\n/**\n * @internal\n * @hidden\n */\nvar CustomReferenceType = /** @class */ (function (_super) {\n    __extends(CustomReferenceType, _super);\n    function CustomReferenceType(targetType, options, onInvalidated) {\n        var _this = _super.call(this, targetType, onInvalidated) || this;\n        _this.options = options;\n        return _this;\n    }\n    CustomReferenceType.prototype.getValue = function (storedRefNode) {\n        if (!storedRefNode.isAlive)\n            return undefined;\n        var referencedNode = this.options.get(storedRefNode.storedValue, storedRefNode.parent ? storedRefNode.parent.storedValue : null);\n        return referencedNode;\n    };\n    CustomReferenceType.prototype.getSnapshot = function (storedRefNode) {\n        return storedRefNode.storedValue;\n    };\n    CustomReferenceType.prototype.instantiate = function (parent, subpath, environment, newValue) {\n        var identifier = isStateTreeNode(newValue)\n            ? this.options.set(newValue, parent ? parent.storedValue : null)\n            : newValue;\n        var storedRefNode = createScalarNode(this, parent, subpath, environment, identifier);\n        this.watchTargetNodeForInvalidations(storedRefNode, identifier, this.options);\n        return storedRefNode;\n    };\n    CustomReferenceType.prototype.reconcile = function (current, newValue, parent, subpath) {\n        var newIdentifier = isStateTreeNode(newValue)\n            ? this.options.set(newValue, current ? current.storedValue : null)\n            : newValue;\n        if (!current.isDetaching &&\n            current.type === this &&\n            current.storedValue === newIdentifier) {\n            current.setParent(parent, subpath);\n            return current;\n        }\n        var newNode = this.instantiate(parent, subpath, undefined, newIdentifier);\n        current.die(); // noop if detaching\n        return newNode;\n    };\n    return CustomReferenceType;\n}(BaseReferenceType));\n/**\n * `types.reference` - Creates a reference to another type, which should have defined an identifier.\n * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.\n */\nfunction reference(subType, options) {\n    assertIsType(subType, 1);\n    if (devMode()) {\n        if (arguments.length === 2 && typeof arguments[1] === \"string\") {\n            // istanbul ignore next\n            throw fail$1(\"References with base path are no longer supported. Please remove the base path.\");\n        }\n    }\n    var getSetOptions = options ? options : undefined;\n    var onInvalidated = options\n        ? options.onInvalidated\n        : undefined;\n    if (getSetOptions && (getSetOptions.get || getSetOptions.set)) {\n        if (devMode()) {\n            if (!getSetOptions.get || !getSetOptions.set) {\n                throw fail$1(\"reference options must either contain both a 'get' and a 'set' method or none of them\");\n            }\n        }\n        return new CustomReferenceType(subType, {\n            get: getSetOptions.get,\n            set: getSetOptions.set\n        }, onInvalidated);\n    }\n    else {\n        return new IdentifierReferenceType(subType, onInvalidated);\n    }\n}\n/**\n * Returns if a given value represents a reference type.\n *\n * @param type\n * @returns\n */\nfunction isReferenceType(type) {\n    return (type.flags & TypeFlags.Reference) > 0;\n}\n/**\n * `types.safeReference` - A safe reference is like a standard reference, except that it accepts the undefined value by default\n * and automatically sets itself to undefined (when the parent is a model) / removes itself from arrays and maps\n * when the reference it is pointing to gets detached/destroyed.\n *\n * The optional options parameter object accepts a parameter named `acceptsUndefined`, which is set to true by default, so it is suitable\n * for model properties.\n * When used inside collections (arrays/maps), it is recommended to set this option to false so it can't take undefined as value,\n * which is usually the desired in those cases.\n *\n * Strictly speaking it is a `types.maybe(types.reference(X))` (when `acceptsUndefined` is set to true, the default) and\n * `types.reference(X)` (when `acceptsUndefined` is set to false), both of them with a customized `onInvalidated` option.\n *\n * @param subType\n * @param options\n * @returns\n */\nfunction safeReference(subType, options) {\n    var refType = reference(subType, __assign(__assign({}, options), { onInvalidated: function (ev) {\n            ev.removeRef();\n        } }));\n    if (options && options.acceptsUndefined === false) {\n        return refType;\n    }\n    else {\n        return maybe(refType);\n    }\n}\n\nvar BaseIdentifierType = /** @class */ (function (_super) {\n    __extends(BaseIdentifierType, _super);\n    function BaseIdentifierType(name, validType) {\n        var _this = _super.call(this, name) || this;\n        _this.validType = validType;\n        _this.flags = TypeFlags.Identifier;\n        return _this;\n    }\n    BaseIdentifierType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        if (!parent || !(parent.type instanceof ModelType))\n            throw fail$1(\"Identifier types can only be instantiated as direct child of a model type\");\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    };\n    BaseIdentifierType.prototype.reconcile = function (current, newValue, parent, subpath) {\n        // we don't consider detaching here since identifier are scalar nodes, and scalar nodes cannot be detached\n        if (current.storedValue !== newValue)\n            throw fail$1(\"Tried to change identifier from '\" + current.storedValue + \"' to '\" + newValue + \"'. Changing identifiers is not allowed.\");\n        current.setParent(parent, subpath);\n        return current;\n    };\n    BaseIdentifierType.prototype.isValidSnapshot = function (value, context) {\n        if (typeof value !== this.validType) {\n            return typeCheckFailure(context, value, \"Value is not a valid \" + this.describe() + \", expected a \" + this.validType);\n        }\n        return typeCheckSuccess();\n    };\n    return BaseIdentifierType;\n}(SimpleType));\n/**\n * @internal\n * @hidden\n */\nvar IdentifierType = /** @class */ (function (_super) {\n    __extends(IdentifierType, _super);\n    function IdentifierType() {\n        var _this = _super.call(this, \"identifier\", \"string\") || this;\n        _this.flags = TypeFlags.Identifier;\n        return _this;\n    }\n    IdentifierType.prototype.describe = function () {\n        return \"identifier\";\n    };\n    return IdentifierType;\n}(BaseIdentifierType));\n/**\n * @internal\n * @hidden\n */\nvar IdentifierNumberType = /** @class */ (function (_super) {\n    __extends(IdentifierNumberType, _super);\n    function IdentifierNumberType() {\n        return _super.call(this, \"identifierNumber\", \"number\") || this;\n    }\n    IdentifierNumberType.prototype.getSnapshot = function (node) {\n        return node.storedValue;\n    };\n    IdentifierNumberType.prototype.describe = function () {\n        return \"identifierNumber\";\n    };\n    return IdentifierNumberType;\n}(BaseIdentifierType));\n/**\n * `types.identifier` - Identifiers are used to make references, lifecycle events and reconciling works.\n * Inside a state tree, for each type can exist only one instance for each given identifier.\n * For example there couldn't be 2 instances of user with id 1. If you need more, consider using references.\n * Identifier can be used only as type property of a model.\n * This type accepts as parameter the value type of the identifier field that can be either string or number.\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifier,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\nvar identifier = new IdentifierType();\n/**\n * `types.identifierNumber` - Similar to `types.identifier`. This one will serialize from / to a number when applying snapshots\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifierNumber,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\nvar identifierNumber = new IdentifierNumberType();\n/**\n * Returns if a given value represents an identifier type.\n *\n * @param type\n * @returns\n */\nfunction isIdentifierType(type) {\n    return isType(type) && (type.flags & TypeFlags.Identifier) > 0;\n}\n/**\n * @internal\n * @hidden\n */\nfunction normalizeIdentifier(id) {\n    return \"\" + id;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isValidIdentifier(id) {\n    return typeof id === \"string\" || typeof id === \"number\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsValidIdentifier(id, argNumber) {\n    assertArg(id, isValidIdentifier, \"string or number (identifier)\", argNumber);\n}\n\n/**\n * `types.custom` - Creates a custom type. Custom types can be used for arbitrary immutable values, that have a serializable representation. For example, to create your own Date representation, Decimal type etc.\n *\n * The signature of the options is:\n * ```ts\n * export interface CustomTypeOptions<S, T> {\n *     // Friendly name\n *     name: string\n *     // given a serialized value and environment, how to turn it into the target type\n *     fromSnapshot(snapshot: S, env: any): T\n *     // return the serialization of the current value\n *     toSnapshot(value: T): S\n *     // if true, this is a converted value, if false, it's a snapshot\n *     isTargetType(value: T | S): value is T\n *     // a non empty string is assumed to be a validation error\n *     getValidationMessage?(snapshot: S): string\n * }\n * ```\n *\n * Example:\n * ```ts\n * const DecimalPrimitive = types.custom<string, Decimal>({\n *     name: \"Decimal\",\n *     fromSnapshot(value: string) {\n *         return new Decimal(value)\n *     },\n *     toSnapshot(value: Decimal) {\n *         return value.toString()\n *     },\n *     isTargetType(value: string | Decimal): boolean {\n *         return value instanceof Decimal\n *     },\n *     getValidationMessage(value: string): string {\n *         if (/^-?\\d+\\.\\d+$/.test(value)) return \"\" // OK\n *         return `'${value}' doesn't look like a valid decimal number`\n *     }\n * })\n *\n * const Wallet = types.model({\n *     balance: DecimalPrimitive\n * })\n * ```\n *\n * @param options\n * @returns\n */\nfunction custom(options) {\n    return new CustomType(options);\n}\n/**\n * @internal\n * @hidden\n */\nvar CustomType = /** @class */ (function (_super) {\n    __extends(CustomType, _super);\n    function CustomType(options) {\n        var _this = _super.call(this, options.name) || this;\n        _this.options = options;\n        _this.flags = TypeFlags.Custom;\n        return _this;\n    }\n    CustomType.prototype.describe = function () {\n        return this.name;\n    };\n    CustomType.prototype.isValidSnapshot = function (value, context) {\n        if (this.options.isTargetType(value))\n            return typeCheckSuccess();\n        var typeError = this.options.getValidationMessage(value);\n        if (typeError) {\n            return typeCheckFailure(context, value, \"Invalid value for type '\" + this.name + \"': \" + typeError);\n        }\n        return typeCheckSuccess();\n    };\n    CustomType.prototype.getSnapshot = function (node) {\n        return this.options.toSnapshot(node.storedValue);\n    };\n    CustomType.prototype.instantiate = function (parent, subpath, environment, initialValue) {\n        var valueToStore = this.options.isTargetType(initialValue)\n            ? initialValue\n            : this.options.fromSnapshot(initialValue, parent && parent.root.environment);\n        return createScalarNode(this, parent, subpath, environment, valueToStore);\n    };\n    CustomType.prototype.reconcile = function (current, value, parent, subpath) {\n        var isSnapshot = !this.options.isTargetType(value);\n        // in theory customs use scalar nodes which cannot be detached, but still...\n        if (!current.isDetaching) {\n            var unchanged = current.type === this &&\n                (isSnapshot ? value === current.snapshot : value === current.storedValue);\n            if (unchanged) {\n                current.setParent(parent, subpath);\n                return current;\n            }\n        }\n        var valueToStore = isSnapshot\n            ? this.options.fromSnapshot(value, parent.root.environment)\n            : value;\n        var newNode = this.instantiate(parent, subpath, undefined, valueToStore);\n        current.die(); // noop if detaching\n        return newNode;\n    };\n    return CustomType;\n}(SimpleType));\n\n// we import the types to re-export them inside types.\nvar types = {\n    enumeration: enumeration,\n    model: model,\n    compose: compose,\n    custom: custom,\n    reference: reference,\n    safeReference: safeReference,\n    union: union,\n    optional: optional,\n    literal: literal,\n    maybe: maybe,\n    maybeNull: maybeNull,\n    refinement: refinement,\n    string: string,\n    boolean: boolean,\n    number: number,\n    integer: integer,\n    Date: DatePrimitive,\n    map: map,\n    array: array,\n    frozen: frozen,\n    identifier: identifier,\n    identifierNumber: identifierNumber,\n    late: late,\n    undefined: undefinedType,\n    null: nullType,\n    snapshotProcessor: snapshotProcessor\n};\n\nexport { addDisposer, addMiddleware, applyAction, applyPatch, applySnapshot, cast, castFlowReturn, castToReferenceSnapshot, castToSnapshot, clone, createActionTrackingMiddleware, createActionTrackingMiddleware2, decorate, destroy, detach, escapeJsonPath, flow, getChildType, getEnv, getIdentifier, getLivelinessChecking, getMembers, getNodeId, getParent, getParentOfType, getPath, getPathParts, getPropertyMembers, getRelativePath, getRoot, getRunningActionContext, getSnapshot, getType, hasParent, hasParentOfType, isActionContextChildOf, isActionContextThisOrChildOf, isAlive, isArrayType, isFrozenType, isIdentifierType, isLateType, isLiteralType, isMapType, isModelType, isOptionalType, isPrimitiveType, isProtected, isReferenceType, isRefinementType, isRoot, isStateTreeNode, isType, isUnionType, isValidReference, joinJsonPath, onAction, onPatch, onSnapshot, process$1 as process, protect, recordActions, recordPatches, resolveIdentifier, resolvePath, setLivelinessChecking, setLivelynessChecking, splitJsonPath, tryReference, tryResolve, typecheck, types, unescapeJsonPath, unprotect, walk };\n"]},"metadata":{},"sourceType":"module"}